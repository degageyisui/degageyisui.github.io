<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[noip模拟赛1]]></title>
    <url>%2F2018%2F10%2F17%2F12%2F</url>
    <content type="text"><![CDATA[T1Description每天中午，美丽的重庆一中都会上演一场华丽的千人大竞走。大量人流短时间涌进第二食堂， 食堂班长小 H 表示不淡定了，他必须合理安排饭堂饭菜的价格，来让同学们有愉快的心情就餐。已知第一饭堂饭菜的价格是有 N 位数字的整数，如果一个价格有不小于K（1≤K≤N） 个数位完全相同，那么这个价格就被认为是漂亮的，否则这个价格被认为是不漂亮的。 小 H 想改变其中一个饭菜价格，改变价格中的一位数字需要花费一些钱， 钱数等于改前和改后的数字之差的绝对值。小 H 希望你能把这个价格改地漂亮，求出最小花费，同时给出字典序最小的修改方案。 Input输入文件名为 canteen.in。输入的第一行两个空格隔开的数字 N 和 K(1≤K≤N)。 第二行是一个长度为 N 位的数字， 表示原来的价格。 Output输出文件名为 canteen.out。输出包含两行，第一行一个整数， 表示最小费用。 第二行是字典序最小的方案。 Sample Input6 5889696 Sample Output4888688 Hint对于 30%的数据： N≤10对于 100%的数据： N≤100 000 Solution比较水的一道贪心a，只是要注意细节，维护两个东西：最小费用和最小字典序。显然最小费用优先级更大。我们枚举相同的k个数字从0到9，对于每一个确定的st,用i=0~9依次考虑变的数字，注意先执行st+i，再执行st-i以保证字典序最优。然后对于小于st的从后往前改，大于st的从前往后改来保证字典序。 tips（想好细节,think twice,code once）上代码： The Code#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt; #define maxn 100005using namespace std;int n,k;char s[maxn];char ss[maxn];char tt[maxn];int cnt[10];int minn=0x3f3f3f3f;int yb[10];int calc[10];bool cmp()&#123; for(int i=1;i&lt;=n;i++)&#123; if(tt[i]&lt;ss[i]) return true; else if(tt[i]&gt;ss[i]) return false; &#125; return false;&#125;void init()&#123; scanf("%d%d",&amp;n,&amp;k); scanf("%s",s+1); for(int i=1;i&lt;=n;i++) cnt[s[i]-'0']++,ss[i]='9';//最大化 for(int st=0;st&lt;=9;st++)&#123; int t=k;//要变的个数 int ans=0;//要花的钱 for(int i=0;i&lt;=9;i++)&#123; if(i==0)&#123; if(cnt[st]&gt;=t) break; t-=cnt[st]; &#125; else&#123; int t1=st+i,t2=st-i; if(t1&lt;=9)&#123; if(cnt[t1]&gt;=t)&#123;ans+=t*i;break;&#125; t-=cnt[t1];ans+=cnt[t1]*i; &#125; if(t2&gt;=0)&#123; if(cnt[t2]&gt;=t)&#123;ans+=t*i;break;&#125; t-=cnt[t2];ans+=cnt[t2]*i; &#125; &#125; &#125; minn=min(minn,ans); calc[st]=ans; &#125; for(int st=0;st&lt;=9;st++)&#123; if(calc[st]==minn)&#123; for(int i=1;i&lt;=n;i++) tt[i]=s[i]; memset(yb,0,sizeof(yb)); int t=k;//要变的个数 for(int i=0;i&lt;=9;i++)&#123; if(i==0)&#123; if(cnt[st]&gt;=t) break; t-=cnt[st]; &#125; else&#123; int t1=st+i,t2=st-i; if(t1&lt;=9)&#123; if(cnt[t1]&gt;=t)&#123;yb[t1]=t;break;&#125; t-=cnt[t1];yb[t1]=cnt[t1]; &#125; if(t2&gt;=0)&#123; if(cnt[t2]&gt;=t)&#123;yb[t2]=t;break;&#125; t-=cnt[t2];yb[t2]=cnt[t2]; &#125; &#125; &#125; for(int i=0;i&lt;=9;i++)&#123; if(yb[i])&#123; if(i&gt;st)&#123; for(int j=1;j&lt;=n;j++) if(s[j]==(i+'0')) if(yb[i])tt[j]=st+'0',yb[i]--; else&#123;break;&#125; &#125; else&#123; for(int j=n;j&gt;=1;j--) if(s[j]==(i+'0')) if(yb[i])tt[j]=st+'0',yb[i]--; else&#123;break;&#125; &#125; &#125; &#125; if(cmp()) for(int i=1;i&lt;=n;i++) ss[i]=tt[i]; &#125; &#125; printf("%d\n",minn); for(int i=1;i&lt;=n;i++) printf("%c",ss[i]); /*memset(dp,0x3f,sizeof(dp)); for(int i=1;i&lt;=9;i++) dp[0][i]=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=min(i,k);j++) for(int kk=1;kk&lt;=9;kk++)&#123; dp[j][kk]=min(dp[j][kk],dp[j-1][kk]+abs(s[i]-'0'-kk)); &#125; int minn=0x3f3f3f3f; for(int i=1;i&lt;=9;i++) minn=min(minn,dp[k][i]); printf("%d",minn);*/&#125;int main()&#123; //freopen("canteen.in","r",stdin); //freopen("canteen.out","w",stdout); init(); return 0;&#125; T2Description小 M 新设计了一款战略游戏。游戏的地图包含有 N 个阵地（用 1..N 编号），用 N-1 条战略交通线把它们连接起来， 地图中任意两个阵地都能直接或间接地相互到达。 小 M 为每条交通线设定一个名为“战略重要性”的参数，它是一个正整数，且这个数值越大，说明这条交通线的战略重要性越大。 小 M 还设计了一个阵地间的“战略相关性”的度量标准， 那就是两个阵地间路径上“战略重要性”最小的交通线。小 M 已经完成了游戏大多数模块的代码， 还有一个在线查询模块没有完成，即对于用户查询： k， v，表示查询与阵地 v“战略相关性” 不小于 k 的阵地的数目。由于小 M 还要负责游戏的推广， 所以这个查询模块的代码就交给你了。 Input输入文件名为 strategy.in。第一行输入包含 N 和 Q。 接下来的 N-1 行描述地图中的交通线。 每行包括三个整数 pi,qi 和 ri ( 1≤pi,qi≤N， ri&lt;=1000000000 )，表示阵地 pi 和 qi的战略重要性为 ri 。接下来的 Q 行描述了 Q 次查询。 每行包含两个整数，k 和 v (1≤k≤1,000,000,000, 1≤v≤N )，表示一次查询。 Output输出文件名为 strategy.out。输出 Q 行。在第 i 行输出第 i 次查询的的答案。 Sample Input4 31 2 32 3 22 4 41 24 13 1 Sample Output302 Hint对于 20%的数据： N,Q≤3 00对于 50%的数据： N,Q≤5 000对于 100%的数据： N,Q≤100 000 Solution首先会想到离线处理，再根据单调性，想到用并查集维护，将大于等于k的边所连接的点加入并查集，这样对于每个联通块，其中任意两点都是符合“战略相关性”大于等于k的，所以对于每个询问，答案就是v所在联通块点个数减1即可。 上代码： The Code#include&lt;bits/stdc++.h&gt;using namespace std;#define maxn 100005struct eage&#123; int u,v,len; friend bool operator &lt;(eage a,eage b)&#123; return a.len&gt;b.len; &#125;&#125;e[maxn];int np=0;int n,q,x,y,z,fa[maxn],sz[maxn];struct node&#123; int id,k,v,ans; friend bool operator&lt;(node a,node b)&#123; return a.k&gt;b.k; &#125;&#125;nd[maxn];bool cmp(node a,node b)&#123; return a.id&lt;b.id;&#125;int find(int i)&#123; if(fa[i]==i) return i; int root=find(fa[i]); fa[i]=root; return root;&#125;void link(int x,int y)&#123; int fx=find(x),fy=find(y); if(fx!=fy)&#123; fa[fx]=fy; sz[fy]+=sz[fx]; &#125;&#125;bool check(int x,int y)&#123; int fx=find(x),fy=find(y); if(fx!=fy) return false; return true;&#125;void init()&#123; scanf("%d%d",&amp;n,&amp;q); for(int i=1;i&lt;=n;i++) fa[i]=i,sz[i]=1; for(int i=1;i&lt;n;i++)&#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); e[++np]=(eage)&#123;x,y,z&#125;; &#125; for(int i=1;i&lt;=q;i++)&#123; scanf("%d%d",&amp;nd[i].k,&amp;nd[i].v);nd[i].id=i; &#125; sort(e+1,e+np+1);sort(nd+1,nd+q+1); int j=1; for(int i=1;i&lt;=q;i++)&#123; while(j&lt;=np&amp;&amp;e[j].len&gt;=nd[i].k)&#123; link(e[j].u,e[j].v); j++; &#125; nd[i].ans=sz[find(nd[i].v)]-1; &#125; sort(nd+1,nd+q+1,cmp); for(int i=1;i&lt;=q;i++) printf("%d\n",nd[i].ans);&#125;int main()&#123; init(); return 0;&#125; T3Description小 Y 正用图章和颜料在草稿纸上乱涂颜色。对于数学敏感的他，突然发现这是一个有意思的数学问题：给出有 N 个格子的纸、宽度为 K 个格子的图章和 M 种不同的颜色，每次用图章把纸上连续的 K 个格子上染任意一种颜色，最后把纸涂满，那么小 Y 想知道最后纸上的颜色序列有多少种不同的情况？ Input输入文件名为 paint.in输入数据仅一行，包含三个整数 N,M,K，他们中间用一个空格分开，分别表示纸张的长度，颜色数目和图章的宽度。 Output输入文件名为 paint.out输出文件仅一行，一个非负整数，表示答案。这个数可能很大，请模1000000007 后输出。 Sample Input3 2 2 Sample Output6 Hint对于 20%的数据 N,M,K≤5对于 50%的数据 N,K≤1 000对于 100%的数据 N,M,K≤10 000 000 Solution真的是数学问题吗？？？首先要明白一点，合法的是要求至少有一个长度为K的相同颜色的块。（这个都没有想出来我好蒻A qwq）然后正难则反，我们只要求出不合法的总个数，然后用总的方法数减去不合法的即为合法的方案数，那么这里用dp,设f[i]为前i个不合法的方案数，那么就不会出现连续k个，所以：$f[i]=f[i-1] \ast m （i&lt;k）​$ $f[i]=(f[i-1]+f[i-2]+…+f[i-k+1]) \ast (m-1) (i&gt;=k)$ 第i个和第i-k个必须不一样再简单加个滑动窗口就可以O(n)过了233333 tips题目中有mod的话，一般不是dp就是数学（套路！！！）上代码： The Code#include&lt;bits/stdc++.h&gt;#define maxn 10000005using namespace std;typedef long long ll;const ll mod=1000000007;int n,m,k;ll dp[maxn];ll qkpow(ll t,int pos)&#123; if(pos==0) return 1; if(pos==1) return t%mod; ll tt=qkpow(t,pos/2); if(pos&amp;1) return tt*tt%mod*t%mod; else return tt*tt%mod;&#125;void init()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); ll all=qkpow(m,n); dp[0]=1; ll sum=0; for(int i=1;i&lt;k;i++) dp[i]=dp[i-1]*m%mod,sum=(sum+dp[i])%mod; for(int i=k;i&lt;=n;i++)&#123; dp[i]=(sum)*(m-1)%mod; sum=(sum+dp[i]-dp[i-k+1]+mod)%mod; &#125; ll ans=(all-dp[n]+mod)%mod; printf("%lld",ans);&#125;int main()&#123; init(); return 0;&#125; 小结：总结套路a鸽子，多想想那些大佬是怎么思考的。（think twice,code once）]]></content>
      <categories>
        <category>noip模拟赛</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>离线</tag>
        <tag>数学</tag>
        <tag>dp</tag>
        <tag>正难则反</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[祎隋]]></title>
    <url>%2F2018%2F10%2F16%2F11%2F</url>
    <content type="text"><![CDATA[童话，被同化前做过的梦《祎隋》 我们因多少人孤单 又有多少人为我们不安 等待是漫长的表演 相安是莫大的荒诞 为搏那一瞬笑颜 熹光几点 我们敢于冒险 心怀本愿 却屡次三番 无法实现 使得停滞不前 初心淡暗 何时起相顾无言 仿佛就从昨天 再忆那春风不及的笑脸 已是许久以前 颔首 低眉 轻笑 每个瞬间 浅唱 微吟 翩舞 总拨心弦 可我没有华丽诗篇 没有道貌伟岸 只有痴心一片 闲心几点 忽而悄然自言 你可曾是我心中的四月天？ 回神漠然 青春已半 不如数月以前 我们未曾相见 窗沿 雨 雷电 深夜未眠 愿初心不变 心境自然 虽喜忧掺半 往前仍是少年]]></content>
      <categories>
        <category>杂诗</category>
      </categories>
      <tags>
        <tag>杂诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF350E Wrong Floyd]]></title>
    <url>%2F2018%2F10%2F16%2F10%2F</url>
    <content type="text"><![CDATA[Description给定n个点,m条边以及k个标记点，要求进行Floyd时只以标记的点为中间点进行松弛操作（每条边边权为1）要求你造出m条边的数据来hack掉这种程序。 Hint3&lt;=n&lt;=300 , 2&lt;=k&lt;=n2&lt;=k&lt;=n , n-1&lt;=m&lt;=n*(n-1)/2; Solution我们只需要任意一点只和非标记点连边就可以了（这样就无法正确更新它到其他点的距离） 具体一下几个细节： 1.判k==n或m&gt;最多可以构出的边maxm； maxm=(n-1)*(n-2)/2+num;（num:非标记点的数量） 2.将随便一个标记点与所以非标记点连边； 3.再随便一个非标记点与未加入图中的点连边来保证图的联通； 4.最后随便加未加的边使边数凑够m即可； The Code#include&lt;bits/stdc++.h&gt;#define maxn 310using namespace std;int n,m,k,x,num;bool vis[maxn],iss[maxn][maxn],viss[maxn];void init()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=n;i++) iss[i][i]=1; for(int i=1;i&lt;=k;i++) scanf("%d",&amp;x),vis[x]=1; num=n-k; int maxx=(n-1)*(n-2)/2+num; if(m&gt;maxx||k==n)&#123; printf("-1");return; &#125; int t,tt=1;int calc=0; while(!vis[tt]) tt++; viss[tt]=1; for(int i=1;i&lt;=n;i++)&#123; if(!vis[i])&#123; t=i; viss[t]=1; printf("%d %d\n",t,tt); iss[t][tt]=iss[tt][t]=1; calc++; &#125; &#125; //保证联通 for(int i=1;i&lt;=n;i++)&#123; if(viss[i]) continue; printf("%d %d\n",i,t); iss[i][t]=iss[t][i]=1; calc++; if(calc==m) break; &#125; for(int i=1;i&lt;=n;i++)&#123; if(calc==m) break; if(i==tt) continue; for(int j=1;j&lt;=n;j++)&#123; if(j==tt) continue; if(iss[i][j]) continue; printf("%d %d\n",i,j); calc++; iss[i][j]=iss[j][i]=1; if(calc==m) break; &#125; &#125;&#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[32.Sort]]></title>
    <url>%2F2018%2F10%2F16%2F9%2F</url>
    <content type="text"><![CDATA[Description众所周知，排序方法有许多种。例如：简单易懂的冒泡排序，平均复杂度较优的快速排序，以及不基于比较的基数排序等等。 现在，小 DD 得到了一个自然数序列 {a1,a2,⋯,an}{a1,a2,⋯,an}。他想要对其按照从小到大的顺序进行排序（即使得每个元素均严格不大于他的后继元素）。但由于基于比较的排序算法复杂度下界已经被证明为 Θ(nlog2n)Θ(nlog2⁡n)，所以小 DD 决定尝试一种全新的排序算法：翻转排序。 在翻转排序中，小 DD 在每次操作中，可以选择一个区间 [l,r][l,r] (1≤l≤r≤n)(1≤l≤r≤n)，并翻转 al,al+1,⋯,aral,al+1,⋯,ar。即，在该次操作完后，序列将会变为 a1,a2,⋯,al−1,ar,ar−1,⋯,al+1,al,ar+1,ar+2,⋯,ana1,a2,⋯,al−1,ar,ar−1,⋯,al+1,al,ar+1,ar+2,⋯,an。 例如，对于序列 [1,6,2,4,3,5][1,6,2,4,3,5]，若选择区间 [2,4][2,4] 进行翻转，则将会得到 [1,4,2,6,3,5][1,4,2,6,3,5]。 定义一次操作的代价为 r−l+1r−l+1，即翻转的区间长度。定义一个操作序列的代价为每次操作的代价之和。现在，请你帮助小 DD 求出一个代价足够小的操作序列（你并不一定要求出代价最小的操作序列）。 Input第一行一个正整数 nn，表示序列长度。 第二行 nn 个空格隔开的非负整数，表示小 DD 得到的自然数序列 a1,a2,⋯,ana1,a2,⋯,an。 Output输出若干行，每行两个空格隔开的正整数 l,rl,r (1≤l≤r≤n)(1≤l≤r≤n)，表示一次翻转区间 [l,r][l,r] 的操作。 最后输出一行 -1 -1，标志着操作序列的结束。 Sample Input4 1 3 2 4 Sample Output2 3 -1 -1 Hint1.下发文件中提供了 checker.cpp，该程序将对于其所在目录下的 sort.in，判断其所在目录下的 sort.out 是否为一个正确的操作序列。若正确，将给出该操作序列的代价。若不正确，将给出错误信息。选手可以借助该程序来更好地检查自己的程序是否正确。 运行时，必须保证 sort.in 为一个合法的输入，且需保证 sort.out 符合题目中描述的输出格式，否则出现任何结果均有可能。 2.对于所有测试数据，保证 1≤n≤500001≤n≤50000，且 0≤ai≤1090≤ai≤109。 （附checker.cpp）#include &lt;algorithm&gt;#include &lt;cstdio&gt;int arr[50005];int main()&#123; FILE *fin = fopen("sort.in", "r"), *fout = fopen("sort.out", "r"); if (!fin) &#123; puts("INVALID : File sort.in not found."); return -1; &#125; if (!fout) &#123; puts("INVALID : File sort.out not found."); return -1; &#125; int n; fscanf(fin, "%d", &amp;n); for (int i = 0; i &lt; n; i++) fscanf(fin, "%d", arr + i); int l, r, sum = 0; while (~fscanf(fout, "%d%d", &amp;l, &amp;r)) &#123; if (l == -1 &amp;&amp; r == -1) break; sum += r - l + 1; if (l &lt;= 0 || l &gt; n) &#123; printf("INVALID : l = %d is not in range [1, %d].\n", l, n); return -1; &#125; if (r &lt;= 0 || r &gt; n) &#123; printf("INVALID : r = %d is not in range [1, %d].\n", r, n); return -1; &#125; if (l &gt; r) &#123; printf("INVALID : %d = l &gt; r = %d.\n", l, r); return -1; &#125; if (sum &gt; 20000000) &#123; puts("INVALID : Too much cost."); return -1; &#125; std::reverse(arr + --l, arr + r); &#125; bool f = true; for (int i = 1; i &lt; n; i++) f &amp;= arr[i] &gt;= arr[i - 1]; if (!f) &#123; puts("INVALID : Not sorted."); return -1; &#125; printf("VALID : Total cost is %d.\n", sum); return 0;&#125;checker Solution本题算是一个比较新颖的题目，实际上是用这种翻转来模拟实现归并排序: 先将给定数列进行离散化，每次选定一个中间的数，将小于等于它的排在左边，大于它的排在右边，再依次递归两边就可以了； 主要是复杂度（进行操作的次数）证明a…. 排一遍要n，由于其非01性，所以进行log2n次的n排，故排一遍将l到r以stdd为标准换为左边小于等于stdd，右边大于等于stdd的操作数为Θ(nlog2n) ； T(n) = 2T(n/2) + Θ(nlog2n),可以解得 T(n) = Θ(nlog22n) ； tql%%%上代码。#include&lt;bits/stdc++.h&gt;#define maxn 50005using namespace std;int n,pos[maxn];struct node&#123; int v,id; friend bool operator&lt;(node a,node b)&#123; return a.v&lt;b.v; &#125;&#125;nd[maxn];int stdd;void run(int l,int r)&#123; if(l==r) return; int mid=l+r&gt;&gt;1; run(l,mid);run(mid+1,r); int L,R;//要翻转的区间 L=R=mid;//L和R的初值 int i=mid,j=mid+1; while(i&gt;=l&amp;&amp;pos[i]&gt;stdd) L=i--; while(j&lt;=r&amp;&amp;pos[j]&lt;=stdd) R=j++; if(L!=R)&#123; printf("%d %d\n",L,R); reverse(pos+L,pos+R+1); &#125; &#125; void msort(int l,int r)&#123; if(l==r) return; int mid=stdd=(l+r)&gt;&gt;1; run(l,r);//将l到r以stdd为标准换为左边小于等于stdd，右边大于等于stdd msort(l,mid);msort(mid+1,r); &#125;void init()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;nd[i].v);nd[i].id=i; &#125; sort(nd+1,nd+n+1); for(int i=1;i&lt;=n;i++) pos[nd[i].id]=i;//离散化位置确定 msort(1,n); printf("-1 -1\n");&#125;int main()&#123; //freopen("sort.in","r",stdin); //freopen("sort.out","w",stdout); init(); return 0;&#125;]]></content>
      <categories>
        <category>Noi.ac</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数对子]]></title>
    <url>%2F2018%2F10%2F16%2F8%2F</url>
    <content type="text"><![CDATA[Description我们定义一个数对 (x,y) 是好的，当且仅当 x≤y，且 x xor y的二进制表示下有奇数个 1 现在给定 nn 个区间 [li,ri]，你需要对于每个 i∈[1,n]，输出有几对好的数 (x,y)满足 x 和 y 都在 [l1,r1]∪[l2,r2]…∪[li,ri]，即两个数都在前 i 个区间的并里 Input第一行一个正整数 n 接下来 n 行每行两个整数 [li,ri]，表示第 i个区间，保证 li≤ri Ouput输出 n 行，第 i行一个整数表示有几对好的数 (x,y) 满足 x,y 都在前 i 个区间的并里 Sample Input3 1 7 3 10 9 20 Sample Output12 25 100 Hint对于 30%30% 的数据，有 1≤n≤1001≤n≤100，1≤li≤ri≤1001≤li≤ri≤100 对于 50%50% 的数据，有 1≤n≤10001≤n≤1000，1≤li≤ri≤232−11≤li≤ri≤232−1 对于 100%100% 的数据，有 1≤n≤1051≤n≤105, 1≤li≤ri≤232−11≤li≤ri≤232−1 时间限制：2s 空间限制：512MB Solutiontips先补充几个小知识点（快速求出一个数的二进制中有多少个1）: x=x&amp;(x-1)（递归求法，适用于单个数） 表达式的意思就是:把x的二进制表示 从低位开始，将遇到的第一个为1的 二进制位 置0。 int calc=0;while(x) x=x&amp;(x-1),calc++;calc即为所求值 求0到x中有多少二进制含1个数为奇数的： long long calc(long long x)&#123; long long tmp=x,tot=0; while(tmp) &#123; if(tmp&amp;1)tot++; tmp&gt;&gt;=1; &#125; return (x&gt;&gt;1)+((x&amp;1) || (tot&amp;1));&#125;证明：00 01 10 11 100 101 110 111....继续下去可以发现规律是偶奇奇偶奇偶偶奇....所以x&gt;&gt;1之前一半的，如果x为奇数（会少算一个）或其本身有奇数个1得加上 所以说探究性质a老哥(这个性质也可以记住) p.s.当线段树叶子节点有n个时，应开总共2^(log2n+1)个点，即2*n个点 正经题解开始：首先，对于每个数对（x,y）, 若要x xor y的二进制表示下有奇数个 1，则必定一者含奇数个1，一者含偶数个。 证明：若两个都为奇数，1.则奇减奇等于偶（重叠个数为奇个）2.奇减偶先为奇（重叠个数为偶数个），奇加奇等于偶 ​ 若两个都为偶数，则可同上证明 ​ 一奇一偶，1.奇减奇等于偶，偶减奇等于奇，奇加偶等于奇2.奇减偶等于奇，偶减偶等于偶，偶加奇等于奇 所以我们采取线段树来维护区间含奇数个1和含偶数个1的个数，对于区间l,r，则用上述中所介绍的calc函数，来calc(r)-calc(l-1)得到奇数个1个数以及r-l+1-（calc(r)-calc(l-1)）得到偶数个1个数 每次输入一个区间加进去统计一个区间，然后输出总的相乘即可。p.s.线段树很好的解决了区间相交的问题，在以及统计过的区间标记vis[now]=1; 上代码： #include&lt;bits/stdc++.h&gt;#define maxn 100005using namespace std;typedef long long ll;ll num[maxn&lt;&lt;4][2];int lc[maxn&lt;&lt;4],rc[maxn&lt;&lt;4],rt=0,np=0;int n;bool vis[maxn&lt;&lt;4];void upload(int now)&#123; num[now][0]=num[lc[now]][0]+num[rc[now]][0]; num[now][1]=num[lc[now]][1]+num[rc[now]][1];&#125;ll calc(ll x)&#123; ll t=x,tot=0; while(t) &#123; if(t&amp;1)tot++; t&gt;&gt;=1; &#125; return (x&gt;&gt;1)+((x&amp;1) || (tot&amp;1));&#125;void update(int &amp;now,ll l,ll r,ll x,ll y)&#123; if(!now) now=++np; if(vis[now]) return; if(l&gt;=x&amp;&amp;r&lt;=y)&#123; num[now][1]=calc(r)-calc(l-1); num[now][0]=r-l+1-num[now][1]; vis[now]=1; return; &#125; ll m=(l+r)&gt;&gt;1; if(y&lt;=m)update(lc[now],l,m,x,y); else if(x&gt;m)update(rc[now],m+1,r,x,y); else&#123; update(lc[now],l,m,x,y); update(rc[now],m+1,r,x,y); &#125; upload(now);&#125;void init()&#123; scanf("%d",&amp;n); ll L,R,mx=1ll&lt;&lt;32; for(int i=1;i&lt;=n;i++)&#123; scanf("%lld%lld",&amp;L,&amp;R); update(rt,1,mx,L,R); printf("%lld\n",num[1][0]*num[1][1]); &#125;&#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>二进制</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[祎隋]]></title>
    <url>%2F2018%2F10%2F16%2F7%2F</url>
    <content type="text"><![CDATA[愿你像个孩子，愿你心生双翼 《祎隋》 青涩 带着年少初识的忐忑 我们相遇了 传奇 三年来我们所追寻的词字 一段故事 从这里轻启 回忆 忘不却从前往事 追不上白驹过隙 再聚 仿佛多年往复 传奇已铸 但我们的故事未完待续 我们的航船才起征途 愿 愿相框里的我们永远闪闪发光 愿你仍是原般模样]]></content>
      <categories>
        <category>杂诗</category>
      </categories>
      <tags>
        <tag>杂诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF351B Jeff and Furik]]></title>
    <url>%2F2018%2F10%2F16%2F6%2F</url>
    <content type="text"><![CDATA[Description给一个1~n的排列p[i]，Jeff先手可以交换任意两个相邻元素，而Furik会有0.5的几率把任意满足p[i] &lt; p[i+1]的p[i]和p[i+1]交换，有0.5的几率把任意满足p[i] &gt; p[i+1]的p[i]和p[i+1]交换，问将整个序列变成升序所需的最小期望步数 Input第一行一整数n表示序列长度，之后一个1~n的排列p[i] (1&lt;=n&lt;=3000) Output输出把整个序列变成升序所需的最小期望步数 Sample Input53 5 2 4 1 Sample Output13.000000 Solution考虑E[i]（i为逆序对个数）的最小期望步数，则E[0]=0,E[1]=1;那么每一次Jeff肯定是交换使逆序对减少一个而Furik则有50%减少一个50%增加一个，故$E[i]=1/2(E[i-2]+1)+1/2(E[i-1+1]+1)$;化简得$E[i]=E[i-2]+4$; 故模拟归并排序求一次逆序对个数便可实现。 Code#include&lt;bits/stdc++.h&gt;#define maxn 3005using namespace std;int n,a[maxn],t[maxn];int msort(int l,int r)&#123; if(l==r) return 0; int m=l+r&gt;&gt;1; int t1=msort(l,m); int t2=msort(m+1,r); int t3=0; int i=l,j=m+1,k=l; while(i&lt;=m&amp;&amp;j&lt;=r)&#123; if(a[i]&gt;a[j])&#123; t3+=m-i+1; t[k++]=a[j++]; &#125; else&#123; t[k++]=a[i++];//本来就应该小于 &#125; &#125; while(i&lt;=m) t[k++]=a[i++]; while(j&lt;=r) t[k++]=a[j++]; for(int p=l;p&lt;=r;p++) a[p]=t[p];//调整 return t1+t2+t3; &#125;void init()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); int nd=msort(1,n); if(nd&amp;1)&#123; printf("%lf",(double)(2*nd-1)); &#125; else printf("%lf",(double)2*nd);&#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>概率期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卡常数]]></title>
    <url>%2F2018%2F10%2F16%2F5%2F</url>
    <content type="text"><![CDATA[Decription（在十进制下）定义 mn(i) 表示把 i 的各位数字从小到大排序得到的数，mx(i) 表示从大到小得到的数。这里的数是允许有前导零的，比如mn(10000)=00001=1 ， mx(132)=321 等。定义 f(i)=mx(i)−mn(i) 。当然，这里 mx(i) 的定义是要在某个整数 k 位十进制数下的。 卡常数指印度数学家Kaprekar发现的常数 6174 。他发现，任取一个各位数字不全相同的四位数 x，不断地使 x=f(x) ，最终总能得到 6174 。 现在Fizzydavid学习了高级的卡常数技巧，他想知道对于五位数的情况。他每次会给你一个带前导零的五位数x，要让你求出操作 x=f(x) 进行 c 次之后的结果。他每次给你的 c 都是一样的。此时 f 定义中的 k=5。 Input第一行两个整数 T,c 。T 表示询问次数，c 的含义如题面。 接下来 T 行每行一个五位数 x ，不足五位会加前导零补到五位。 Output对于每个询问输出一行表示答案。不足五位需要补到五位。 Hint1≤T≤105,1≤c≤109,0≤x&lt;105 。 20%的数据保证 c≤10 。 另外20%的数据保证 T≤10 。 另外30%的数据保证 c≥105 。 时间限制： 2s 空间限制： 512MB Solutionwoc这道题思路很Nice啊。首先会想到肯定每个数进行一定次数之后会循环(不然就没法做了a)。然后这里应该要想到我们对当前的数求循环的时候，我们事实上已经对所有经过的数求出来了，这样稍微处理一下就可以保证每个数只被访问一次。但这样还是会T a。。。于是探究性质：发现对于一个x进行a+b次操作等于先将x进行a次操作，再进行b次操作，或者反过来，再进一步想到可以倍增预处理(Nice啊).这样就欧克了a(注意倍增不要写错a在刷状态的时候QAQ) tips1.以后遇到这种性质都可以考虑倍增(LCA也有这种性质嘛)2.补充一下姿势（雾%nd 输出的整型宽度至少为n位，右对齐，%5d即宽度至少为5位，位数大于5则输出实际位数%0nd 用得比较多，表示输出的整型宽度至少为n位，不足n位用0填充printf（”%05d”,1）输出：00001printf（”%5d”,1）输出：**1（$*$为空格） The Code#include&lt;bits/stdc++.h&gt;#define maxn 100005using namespace std;int n,x,c;int g[100005][31],mx,mn,a[7];int cmp(int x,int y)&#123; return x&gt;y;&#125;int f(int x)&#123; memset(a,0,sizeof(a)); int pos=6; while(x)&#123; a[--pos]=x%10;x/=10; &#125; sort(a+1,a+6);mn=a[1]*10000+a[2]*1000+a[3]*100+a[4]*10+a[5]; sort(a+1,a+6,cmp);mx=a[1]*10000+a[2]*1000+a[3]*100+a[4]*10+a[5]; return mx-mn;&#125;void pre()&#123; for(int i=0;i&lt;=99999;i++) g[i][0]=f(i); for(int j=1;j&lt;=30;j++) for(int i=0;i&lt;=99999;i++) g[i][j]=g[g[i][j-1]][j-1]; &#125;bool vis[31];void init()&#123; scanf("%d%d",&amp;n,&amp;c); for(int i=0;i&lt;=30;i++) if(c&amp;(1&lt;&lt;i)) vis[i]=1; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;x); for(int j=0;j&lt;=30;j++) if(vis[j]) x=g[x][j]; printf("%05d\n",x); &#125;&#125;int main()&#123; pre(); init(); return 0;&#125;]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>倍增</tag>
        <tag>预处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树]]></title>
    <url>%2F2018%2F10%2F16%2F4%2F</url>
    <content type="text"><![CDATA[The Solutionemmmmmmmm，这道题题意读错了a，有点难受…很考细节的一道题，同时告诉我们细节题要对拍。首先我们要维护的是最大的剩余空间，但实质上是最大的最近距离，比如区间所剩为5和4，实际上它们的最近距离都为2。在设定友好函数时要注意。在处理好一般操作之后是特判，主要就是对于两端的处理，因为它们是独立成段的(图中红色部分)，所以只要红色长度大于最近距离即更优。最后要注意标号尽可能小的细节。 The Code#include&lt;bits/stdc++.h&gt;#define maxn 200005using namespace std;struct node&#123; int l,r; friend bool operator &lt;(node a,node b)&#123; if((a.r-a.l)/2!=(b.r-b.l)/2)return (a.r-a.l)/2&gt;(b.r-b.l)/2; //排得是这个最近距离aQAQ 并且不能将2免去，因为奇偶 else return a.l&lt;b.l; &#125;&#125;;set&lt;node&gt;s;set&lt;node&gt;::iterator it;int n,m,x,y;map&lt;int,int&gt;mp;int pre[maxn],next[maxn],st[maxn],rk[maxn];int np=0; void init()&#123; scanf("%d%d",&amp;n,&amp;m); s.insert((node)&#123;0,n+1&#125;); pre[0]=0;next[0]=n+1;pre[n+1]=0;next[n+1]=n+1; for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d",&amp;x,&amp;y); /*if(x==1)&#123; if(t.l==0&amp;&amp;t.r==n+1)&#123; st[np]=1; rk[1]=np; next[0]=1; next[1]=n+1; pre[n+1]=1; s.erase((node)&#123;0,n+1&#125;); s.insert((node)&#123;0,1&#125;);s.insert((node)&#123;1,n+1&#125;); printf("1\n");continue; &#125; if(t.l==1&amp;&amp;t.r==n+1)&#123; st[np]=n; rk[n]=np; pre[n]=1; next[n]=n+1; pre[n+1]=n; next[0]=1; s.erase((node)&#123;1,n+1&#125;); s.insert((node)&#123;1,n&#125;);s.insert((node)&#123;n,n+1&#125;); printf("%d\n",n);continue; &#125;*/ if(x==1)&#123; mp[y]=++np; it=s.begin(); node t=*it; int len=(t.r-t.l)/2; bool ok1=false,ok2=false; int len1=0,len2=0; if(!rk[1]) len1=next[0]-1;if(!rk[n]) len2=n-pre[n+1]; if(len2&gt;len1) ok2=true;else ok1=true;//标号 if(!rk[1]&amp;&amp;ok1)&#123;//要考虑两端点的问题 if(next[0]-1&gt;=len)&#123;//标号优先 st[np]=1; rk[1]=np; next[1]=next[0];pre[next[0]]=1;next[0]=1; s.erase((node)&#123;0,next[1]&#125;); s.insert((node)&#123;0,1&#125;); s.insert((node)&#123;1,next[1]&#125;); printf("1\n");continue; &#125; &#125; if(!rk[n]&amp;&amp;ok2)&#123; if(n-pre[n+1]&gt;len)&#123; st[np]=n; rk[n]=np; pre[n]=pre[n+1];next[pre[n+1]]=n;pre[n+1]=n; s.erase((node)&#123;pre[n],n+1&#125;); s.insert((node)&#123;n,n+1&#125;); s.insert((node)&#123;pre[n],n&#125;); printf("%d\n",n);continue; &#125; &#125; int position=t.l+len;rk[position]=np;st[np]=position; pre[position]=t.l;next[position]=t.r;pre[t.r]=position; next[t.l]=position; printf("%d\n",position); s.erase((node)&#123;pre[position],next[position]&#125;); s.insert((node)&#123;pre[position],position&#125;); s.insert((node)&#123;position,next[position]&#125;); &#125; else&#123; int t=st[mp[y]]; s.erase((node)&#123;pre[t],t&#125;); s.erase((node)&#123;t,next[t]&#125;); s.insert((node)&#123;pre[t],next[t]&#125;); rk[t]=0; next[pre[t]]=next[t]; pre[next[t]]=pre[t]; pre[t]=next[t]=0; &#125; &#125;&#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[减肥计划]]></title>
    <url>%2F2018%2F10%2F15%2F3%2F</url>
    <content type="text"><![CDATA[Solution哇，这道题还是太急了，探究出个性质就直接溜了。首先当$\sum{a_i}$一定时，$\sum{b_i}$越大肯定越优，那么可以dp[i]表示$\sum{a_i}$为i时最大的$\sum{b_i}$之值。由于a的和为$n \ast max({a_i})$，所以总的复杂度会是$n^2 \ast max({a_i})$。显然会超时。所以我们来探求性质，发现当答案为$\frac{\sum{a_i}}{\sum{b_i}}$，若此时有$\frac{a_i}{b_i}$大于它时，那么加入一定会增大，反之加入小于的会减小，所以我们对于一个答案，不断删去小于它的$\frac{a_i}{b_i}$，直到$\sum{a_i}$&lt;m后停下来，那么过程中不会减小，此时再加入大于的即可，所以最多只用dp到$max({a_i})+m$，因此时间复杂度也降为$n \ast (m+max({a_i}))$ ，即可通过此题。 上代码： Code#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;queue&gt;#define maxn 10000005using namespace std;typedef long long ll;int n,m;ll dp[maxn&lt;&lt;1],a[maxn],b[maxn];ll gcd(ll x,ll y)&#123; if(y==0) return x; else return gcd(y,x%y);&#125;ll maxx=0,sum=0;void init()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;a[i],&amp;b[i]),maxx=max(maxx,a[i]),sum+=a[i]; if(sum&lt;m)&#123;printf("-1");return;&#125; for(int i=1;i&lt;=m+maxx;i++) dp[i]=-0x3f3f3f3f; dp[0]=0; for(int i=1;i&lt;=n;i++) for(int j=maxx+m;j&gt;=a[i];j--) dp[j]=max(dp[j],dp[j-a[i]]+b[i]); ll fz=-1,fm=1; for(int i=m;i&lt;=maxx+m;i++) if(fz*i&lt;dp[i]*fm) fz=dp[i],fm=i; ll g=gcd(fz,fm); fz/=g;fm/=g; printf("%d/%d",fz,fm); &#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>dp</tag>
        <tag>正睿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小瓶颈生成树]]></title>
    <url>%2F2018%2F10%2F15%2F2%2F</url>
    <content type="text"><![CDATA[所谓最小瓶颈生成树….就是使得生成树树上最大边权值最小。这里主要介绍一种期望O（M）（线性）的求法，其实主要就是二分，具体思路如下： 类比找第k大值的方法，首先随机一个边权w。 然后将不超过这个边权的边加入，遍历这张图。 如果图连通，那么瓶颈不超过w，于是只需考虑边权不超过w的边。 否则将这些连通点缩起来，考虑边权大于w的边。 每次将问题的规模缩小至一半。 期望时间复杂度O(m)。 相关例题有两道：A.Hangar Hurdles (CERC 16) 有一个n*n的网格图，上面有些格子可行，有些格子是障碍。 有Q个询问，想把一个正方形箱子从(r1,c1)推到(r2,c2)，问箱子最大的大小。（起点终点是正方形箱子的中点） N&lt;=1000 Q&lt;=300000 B.洪蛤吨有一个宽度为L的管道，我们可以视其为一条y=L的直线与X轴所夹的部分。 （所以这根管道的长度可以视为正无穷） 这个管道中有个N个障碍点，第i个障碍点的坐标为(Xi,Yi)。 已知有一个球体，能在不碰到障碍点的前提下，从管道的最左端走到最右端。（即从管道内横坐标负无穷的地方走到横坐标正无穷的地方）。 求这个球体的直径最大是多少。为了避免精度误差，请输出答案保留三位小数的结果。 两题有异曲同工之妙a…（/滑稽，思路差不多…）都可以用最小瓶颈树实现复杂度最小下面上一下t2的代码：（没有用最小瓶颈树优化，逃） #include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;queue&gt;#define maxn 505using namespace std;struct eage&#123; int u,v; double dist;&#125;e[maxn*maxn/2+maxn*2];bool cmp(eage a,eage b)&#123; return a.dist&lt;b.dist;&#125;double dis(int x1,int y1,int x2,int y2)&#123; return sqrt(1.0*(x1-x2)*(x1-x2)+1.0*(y1-y2)*(y1-y2)); &#125;int fa[maxn];int find(int x)&#123; if(fa[x]==x) return x; int root=find(fa[x]); fa[x]=root; return root;&#125;void link(int x,int y)&#123; int fx=find(x),fy=find(y); if(fx!=fy)&#123; fa[fx]=fy; &#125; &#125;bool check(int x,int y)&#123; int fx=find(x),fy=find(y); if(fx!=fy) return false; return true;&#125;int l,n;struct node&#123; int x,y;&#125;nd[maxn];void init()&#123; int pos=0; scanf("%d%d",&amp;n,&amp;l); for(int i=1;i&lt;=n+2;i++) fa[i]=i;//n+1是上，n+2是下 for(int i=1;i&lt;=n;i++)&#123; scanf("%d%d",&amp;nd[i].x,&amp;nd[i].y); &#125; for(int i=1;i&lt;=n;i++)&#123; e[++pos]=(eage)&#123;i,n+1,l-nd[i].y&#125;; e[++pos]=(eage)&#123;i,n+2,nd[i].y&#125;; for(int j=i+1;j&lt;=n;j++)&#123; e[++pos]=(eage)&#123;i,j,dis(nd[i].x,nd[i].y,nd[j].x,nd[j].y)&#125;; &#125; &#125; int cnt=0; sort(e+1,e+pos+1,cmp); for(int i=1;i&lt;=pos;i++)&#123; int u=e[i].u,v=e[i].v; if(check(u,v)) continue; link(u,v); cnt++; if(find(n+1)==find(n+2))&#123;//只要上底和下底连接了就行 这样才能保证极大值可以通过，如果后面更大，那这里是过不了的 printf("%.3f",e[i].dist); break; &#125; &#125;&#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>最小瓶颈生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UpdateAfterEvent]]></title>
    <url>%2F2018%2F10%2F15%2F1%2F</url>
    <content type="text"><![CDATA[Description​ 小松鼠打了10个小时的游戏，一脸满足。却发现周围再次围满了游客，逃！ 她发现整个西湖内的松鼠都以相同的速度在树之间跳跃。每跳跃一次花费一个单位的时间。我们可以把西湖抽象为一张n个点的无向图，初始时每个点上都有若干只松鼠，它们每单位时间都可以沿着一条无向边进行跳跃。 对于一只当前在点i的松鼠，它在接下来的一个单位时间内等概率向相邻的点跳跃。更具体地讲，我们称与点i通过一条无向边直接相连的点为与i相邻的点，假设这样的点有p个，那么对于每一个与i相邻的点，在下一时刻都有1/p的概率跳到它。 超萌小松鼠已知初始时刻（0时刻）每棵树上的松鼠分布情况，她想知道在T时刻，在同一棵树上的松鼠对数的期望。关于“松鼠对数”的解释：假设有4只松鼠在同一棵树上，那么我们称有6对在同一棵树上的松鼠。为了避免精度误差，我们将答案模10^9 + 7输出。 Input​ 第一行三个数n，T。意义如题面中所述。接下来一行n个数，第i个数ai表示第i个点初始时刻有ai只松鼠。接下来n行，每行n个数，第i行第j个数如果为1表示点i与点j间有无向边相连，为0则表示没有。 Output​ 输出一行一个数，表示T时刻在同一棵树上的松鼠对数的期望在模10^9 +7意义下的答案。 Solution这道题考察了许多知识点，考察综合能力。 首先，题目总体是考察概率期望，但切忌陷入思路死角，去求每棵树上的最终期望松鼠对数。实际上，我们对于每只松鼠，去求它到某点的概率p,那么每两只松鼠在某点的期望便是p1p21（还有很多可转化为概率来做的期望题）由于要除法取模，要预先递推求出逆元，复习一下公式：inv[1]=1;inv[i]=(mod-mod/i)*inv[mod%i]%mod. 那么对于松鼠到某点的概率求取，我们先O(N^2)求出最开始互相连点之间的概率，然后每一时刻，枚举中间点，进行概率传递，由于t比较大，可以用矩阵快速幂思想来将其优化到log2n级别。 最后，由于我们计算期望是O（n^3）的，无法过n&lt;=1000的点，发现如下式子： 设p(i,j)为i到j点的概率。假设计算终点在1，则ans=p(1,1)p(2,1)+p(1,1)p(3,1)…..+p(1,1)p(n,1)+p(2,1)p(3,1)+p(2,1)p(4,1)+…….发现可以转化为p(1,1)(p(2,1)+p(3,1)+p(4,1)+….+p(n,1))+p(2,1)(p(3,1)+p(4,1)+…..+p(n,1)).由此发现是可以前缀和优化的，由此只用枚举一点和终点，从而变成O(N^2).当然可以每个统计一次，然后最后除以2.貌似更方便哈….. The Code#include&lt;bits/stdc++.h&gt;#define maxn 1005using namespace std;typedef long long ll;const ll mod=1e9+7;struct matrix&#123; ll a[maxn][maxn];&#125;nd,ans;int n,t,e[maxn][maxn];matrix operator *(matrix &amp;x,matrix &amp;y)&#123; matrix c; memset(c.a,0,sizeof(c.a)); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=n;k++)&#123; c.a[i][j]=(c.a[i][j]+(x.a[i][k]*y.a[k][j])%mod)%mod; &#125; return c;&#125;void pow(int t)&#123; for(int i=1;i&lt;=n;i++) ans.a[i][i]=1; while(t)&#123; if(t&amp;1) ans=ans*nd;//最后为1 nd=nd*nd; t/=2; &#125;&#125;ll p[maxn][maxn],inv[maxn],v[maxn];void init()&#123; scanf("%d%d",&amp;n,&amp;t); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;v[i]); inv[1]=1; for(int i=2;i&lt;=1000;i++) inv[i]=(mod-mod/i)*inv[mod%i]%mod; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf("%d",&amp;e[i][j]); memset(nd.a,0,sizeof(nd.a)); for(int i=1;i&lt;=n;i++)&#123; int res=0; for(int j=1;j&lt;=n;j++) res+=e[i][j]; for(int j=1;j&lt;=n;j++) nd.a[i][j]=inv[res]*e[i][j]; &#125; if(t&gt;1)&#123; pow(t); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) p[i][j]=ans.a[i][j]; &#125; else&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) p[i][j]=nd.a[i][j]; &#125; ll calc=0; for(int i=1;i&lt;=n;i++)&#123; ll t1=0,t2=0; for(int j=1;j&lt;=n;j++)&#123; ll tt=(p[j][i]*v[j])%mod; t1=(t1+tt)%mod; t2=(t2+tt*p[j][i])%mod; &#125; calc=(calc+(t1*t1%mod-t2+mod)%mod*inv[2]%mod)%mod; &#125; printf("%lld",calc);&#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>noip模拟赛</category>
      </categories>
      <tags>
        <tag>概率期望</tag>
        <tag>前缀和优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[祎隋]]></title>
    <url>%2F2018%2F10%2F14%2Fkk%2F</url>
    <content type="text"><![CDATA[祎隋如你，春风十里不及你《祎隋》 无需仰首，我已知晓 那阳光濡缕，和风轻挠 不用回头，我已知晓 那鲜艳裙摆 ，恬然一笑 …… 因你自嘲，为你歌声倾倒 附上小鞠美图一张]]></content>
      <categories>
        <category>杂诗</category>
      </categories>
      <tags>
        <tag>杂诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文章分类]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
