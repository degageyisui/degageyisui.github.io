<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>ZJOI2006 书架</title>
      <link href="/2018/10/22/19/"/>
      <url>/2018/10/22/19/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>小T有一个很大的书柜。这个书柜的构造有些独特，即书柜里的书是从上至下堆放成一列。她用1到n的正整数给每本书都编了号。</p><p>小T在看书的时候，每次取出一本书，看完后放回书柜然后再拿下一本。由于这些书太有吸引力了，所以她看完后常常会忘记原来是放在书柜的什么位置。不过小T的记忆力是非常好的，所以每次放书的时候至少能够将那本书放在拿出来时的位置附近，比如说她拿的时候这本书上面有X本书，那么放回去时这本书上面就只可能有X-1、X或X+1本书。</p><p>当然也有特殊情况，比如在看书的时候突然电话响了或者有朋友来访。这时候粗心的小T会随手把书放在书柜里所有书的最上面或者最下面，然后转身离开。</p><p>久而久之，小T的书柜里的书的顺序就会越来越乱，找到特定的编号的书就变得越来越困难。于是她想请你帮她编写一个图书管理程序，处理她看书时的一些操作，以及回答她的两个提问：(1)编号为X的书在书柜的什么位置；(2)从上到下第i本书的编号是多少。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行有两个数n，m，分别表示书的个数以及命令的条数；第二行为n个正整数：第i个数表示初始时从上至下第i个位置放置的书的编号；第三行到m+2行，每行一条命令。命令有5种形式：</p><p>1． Top S——表示把编号为S的书放在最上面。</p><p>2． Bottom S——表示把编号为S的书放在最下面。</p><p>3． Insert S T——T∈{-1，0，1}，若编号为S的书上面有X本书，则这条命令表示把这本书放回去后它的上面有X+T本书；</p><p>4． Ask S——询问编号为S的书的上面目前有多少本书。</p><p>5． Query S——询问从上面数起的第S本书的编号。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>对于每一条Ask或Query语句你应该输出一行，一个数，代表询问的答案。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>10 10<br>1 3 2 7 5 8 10 4 9 6<br>Query 3<br>Top 5<br>Ask 6<br>Bottom 3<br>Ask 3<br>Top 6<br>Insert 4 -1<br>Query 5<br>Query 2<br>Ask 2</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>2<br>9<br>9<br>7<br>5<br>3</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>100%的数据，n,m &lt;= 80000</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>一道裸的线段平衡树题a…..<br>先上一波权值平衡树的板子（实际操作中可以按情况修改）<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include&lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include&lt;climits&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">#define maxn 1000000+5 </span></span><br><span class="line">int fa[maxn],ch[maxn][<span class="number">2</span>],sz[maxn],cnt[maxn],val[maxn];</span><br><span class="line">int rt=<span class="number">0</span>,np=<span class="number">0</span>;</span><br><span class="line">bool check(int x)&#123;<span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>]==x;&#125;</span><br><span class="line">void link(int x,int y,bool kind)&#123;</span><br><span class="line">fa[x]=y;ch[y][kind]=x;</span><br><span class="line">&#125;</span><br><span class="line">void upload(int x)&#123;</span><br><span class="line">sz[x]=sz[ch[x][<span class="number">0</span>]]+sz[ch[x][<span class="number">1</span>]]+cnt[x];</span><br><span class="line">&#125;</span><br><span class="line">void rotate(int x)&#123;</span><br><span class="line">int y=fa[x],z=fa[y];</span><br><span class="line">bool kind=check(x);</span><br><span class="line">int k=ch[x][!kind];</span><br><span class="line">link(k,y,kind);</span><br><span class="line">link(x,z,check(y));</span><br><span class="line">link(y,x,!kind);</span><br><span class="line">upload(y);upload(x); </span><br><span class="line">&#125;</span><br><span class="line">void splay(int x,int goal)&#123;</span><br><span class="line">    <span class="keyword">while</span>(fa[x]!=goal)&#123;</span><br><span class="line">    int y=fa[x],z=fa[y];</span><br><span class="line">    <span class="keyword">if</span>(z!=goal) (check(x)^check(y))?rotate(x)<span class="symbol">:rotate</span>(y);</span><br><span class="line">    rotate(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(fa[x]==<span class="number">0</span>) rt=x;</span><br><span class="line">&#125;</span><br><span class="line">void find(int x)&#123;</span><br><span class="line">int now=rt;</span><br><span class="line"><span class="keyword">while</span>(ch[now][x&gt;val[now]]&amp;&amp;val[now]!=x)</span><br><span class="line">  now=ch[now][x&gt;val[now]];</span><br><span class="line">splay(now,<span class="number">0</span>);  </span><br><span class="line">&#125;</span><br><span class="line">void insert(int x)&#123;</span><br><span class="line">int now=rt,f=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(now&amp;&amp;val[now]!=x) f=now,now=ch[now][x&gt;val[now]];</span><br><span class="line"><span class="keyword">if</span>(now) cnt[now]++;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">now=++np;</span><br><span class="line">val[now]=x;</span><br><span class="line"><span class="keyword">if</span>(f) ch[f][x&gt;val[f]]=now;</span><br><span class="line">fa[now]=f;</span><br><span class="line">cnt[now]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">splay(now,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">int prnx(int x,bool f)&#123;</span><br><span class="line">find(x);</span><br><span class="line">int now=rt;</span><br><span class="line"><span class="keyword">if</span>(val[now]&gt;x&amp;&amp;f<span class="params">||</span>val[now]&lt;x&amp;&amp;!f) <span class="keyword">return</span> now;</span><br><span class="line">now=ch[now][f];</span><br><span class="line"><span class="keyword">while</span>(ch[now][!f]) now=ch[now][!f];</span><br><span class="line"><span class="keyword">return</span> now; </span><br><span class="line">&#125;</span><br><span class="line">void del(int x)&#123;</span><br><span class="line">int pre=prnx(x,<span class="number">0</span>),last=prnx(x,<span class="number">1</span>);</span><br><span class="line">splay(pre,<span class="number">0</span>);splay(last,pre);</span><br><span class="line">int delt=ch[last][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(cnt[delt])&#123;cnt[delt]--;splay(delt,<span class="number">0</span>);&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ch[last][<span class="number">0</span>]=<span class="number">0</span>;splay(last,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int kth(int now,int k)&#123;</span><br><span class="line"><span class="keyword">if</span>(k&lt;=sz[ch[now][<span class="number">0</span>]]) <span class="keyword">return</span> kth(ch[now][<span class="number">0</span>],k);</span><br><span class="line"><span class="keyword">if</span>(sz[ch[now][<span class="number">0</span>]]+cnt[now]&lt;k) <span class="keyword">return</span> kth(ch[now][<span class="number">1</span>],k-sz[ch[now][<span class="number">0</span>]]-cnt[now]);</span><br><span class="line">splay(now,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> val[now];</span><br><span class="line">&#125;</span><br><span class="line">int kth(int x)&#123;</span><br><span class="line">int now=rt,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;val[now]) now=ch[now][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ans+=ch[now][<span class="number">0</span>]?sz[ch[now][<span class="number">0</span>]]<span class="symbol">:</span><span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(val[now]==x)&#123;splay(now,<span class="number">0</span>);<span class="keyword">return</span> ans+<span class="number">1</span>;&#125;</span><br><span class="line">ans+=cnt[now];</span><br><span class="line">now=ch[now][<span class="number">1</span>]; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">insert(INT_MIN);</span><br><span class="line">insert(INT_MAX);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=<span class="number">50000</span>;i++) insert(i);</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=<span class="number">50000</span>;i++) kth(rt,i); </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这道题是线段平衡树，对于每个操作画下图，想一下就欧克了，没什么好说的….</p><p>上代码：<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">#define maxn 80005</span></span><br><span class="line">int n,m,np=<span class="number">0</span>,rt=<span class="number">0</span>;</span><br><span class="line">int fa[maxn],ch[maxn][<span class="number">2</span>],sz[maxn];</span><br><span class="line">int val[maxn],rk[maxn];</span><br><span class="line">bool check(int x)&#123;<span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>]==x;&#125;</span><br><span class="line">void link(int x,int y,bool kind)&#123;</span><br><span class="line">    fa[x]=y;ch[y][kind]=x;</span><br><span class="line">&#125;</span><br><span class="line">void upload(int x)&#123;</span><br><span class="line">    sz[x]=sz[ch[x][<span class="number">0</span>]]+sz[ch[x][<span class="number">1</span>]]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">void rotate(int x)&#123;</span><br><span class="line">    int y=fa[x];</span><br><span class="line">    int z=fa[y];</span><br><span class="line">    bool kind=check(x);</span><br><span class="line">    int k=ch[x][!kind];</span><br><span class="line">    link(k,y,kind);</span><br><span class="line">    link(x,z,check(y));</span><br><span class="line">    link(y,x,!kind);</span><br><span class="line">    upload(y);upload(x);</span><br><span class="line">&#125;</span><br><span class="line">void splay(int x,int goal)&#123;</span><br><span class="line">    <span class="keyword">while</span>(fa[x]!=goal)&#123;</span><br><span class="line">        int y=fa[x],z=fa[y];</span><br><span class="line">        <span class="keyword">if</span>(z!=goal) (check(x)^check(y))?rotate(x)<span class="symbol">:rotate</span>(y);</span><br><span class="line">        rotate(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==<span class="number">0</span>) rt=x;</span><br><span class="line">&#125;</span><br><span class="line">void insert(int x)&#123;</span><br><span class="line">    int now=rt,f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(now) f=now,now=ch[now][<span class="number">1</span>];</span><br><span class="line">    now=++np;</span><br><span class="line">    link(now,f,<span class="number">1</span>);</span><br><span class="line">    splay(now,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">int nxt(int x,bool f)&#123;<span class="regexp">//</span>前提要将x旋转到根 </span><br><span class="line">    x=ch[x][f];</span><br><span class="line">    <span class="keyword">while</span>(ch[x][!f]) x=ch[x][!f];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">void del(int x)&#123;</span><br><span class="line">    splay(x,<span class="number">0</span>);</span><br><span class="line">    int pre=nxt(x,<span class="number">0</span>),nxtt=nxt(x,<span class="number">1</span>);</span><br><span class="line">    splay(pre,<span class="number">0</span>);splay(nxtt,pre);</span><br><span class="line">    ch[nxtt][<span class="number">0</span>]=<span class="number">0</span>;splay(nxtt,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">int kth(int now,int k)&#123;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=sz[ch[now][<span class="number">0</span>]]) <span class="keyword">return</span> kth(ch[now][<span class="number">0</span>],k);</span><br><span class="line">    <span class="keyword">if</span>(sz[ch[now][<span class="number">0</span>]]+<span class="number">1</span>&lt;k) <span class="keyword">return</span> kth(ch[now][<span class="number">1</span>],k-sz[ch[now][<span class="number">0</span>]]-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125; </span><br><span class="line">int s,k;</span><br><span class="line">char op[<span class="number">10</span>];</span><br><span class="line">void init()&#123;</span><br><span class="line">    scanf(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">2</span>;i&lt;=n+<span class="number">1</span>;i++) scanf(<span class="string">"%d"</span>,&amp;val[i]),rk[val[i]]=i;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n+<span class="number">2</span>;i++) insert(i);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        scanf(<span class="string">"%s"</span>,op);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'T'</span>)&#123;</span><br><span class="line">            scanf(<span class="string">"%d"</span>,&amp;s);</span><br><span class="line">            int t=rk[s];</span><br><span class="line">            del(t);</span><br><span class="line">            /*splay(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            int nxtt=nxt(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            splay(nxtt,<span class="number">0</span>);splay(<span class="number">1</span>,nxtt);</span><br><span class="line">            link(t,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            splay(t,<span class="number">0</span>);*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">            splay(1,0);</span></span><br><span class="line"><span class="regexp">            int nxtt=nxt(1,1);</span></span><br><span class="line"><span class="regexp">            splay(nxtt,1);</span></span><br><span class="line"><span class="regexp">            link(t,nxtt,0);</span></span><br><span class="line"><span class="regexp">            splay(t,0); </span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        else if(op[0]=='B')&#123;</span></span><br><span class="line"><span class="regexp">            scanf("%d",&amp;s);</span></span><br><span class="line"><span class="regexp">            int t=rk[s];</span></span><br><span class="line"><span class="regexp">            del(t);</span></span><br><span class="line"><span class="regexp">            /</span>*splay(n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">            int pre=nxt(n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">            splay(pre,<span class="number">0</span>);splay(n+<span class="number">2</span>,pre);</span><br><span class="line">            link(t,n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">            splay(t,<span class="number">0</span>);*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">            splay(n+2,0);</span></span><br><span class="line"><span class="regexp">            int pre=nxt(n+2,0);</span></span><br><span class="line"><span class="regexp">            splay(pre,n+2);</span></span><br><span class="line"><span class="regexp">            link(t,pre,1);</span></span><br><span class="line"><span class="regexp">            splay(t,0);</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        else if(op[0]=='I')&#123;</span></span><br><span class="line"><span class="regexp">            scanf("%d%d",&amp;s,&amp;k);</span></span><br><span class="line"><span class="regexp">            if(k==0) continue;</span></span><br><span class="line"><span class="regexp">            int t=rk[s];</span></span><br><span class="line"><span class="regexp">            splay(t,0);</span></span><br><span class="line"><span class="regexp">            if(k==1)&#123;</span></span><br><span class="line"><span class="regexp">                int nxtt=nxt(t,1);</span></span><br><span class="line"><span class="regexp">                swap(rk[val[t]],rk[val[nxtt]]);</span></span><br><span class="line"><span class="regexp">                swap(val[t],val[nxtt]);</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            else&#123;</span></span><br><span class="line"><span class="regexp">                int nxtt=nxt(t,0);</span></span><br><span class="line"><span class="regexp">                swap(rk[val[t]],rk[val[nxtt]]);</span></span><br><span class="line"><span class="regexp">                swap(val[t],val[nxtt]);</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        else if(op[0]=='A')&#123;</span></span><br><span class="line"><span class="regexp">            scanf("%d",&amp;s);</span></span><br><span class="line"><span class="regexp">            int t=rk[s];</span></span><br><span class="line"><span class="regexp">            splay(t,0);</span></span><br><span class="line"><span class="regexp">            printf("%d\n",sz[ch[t][0]]-1);/</span><span class="regexp">/减去最开始加入的1 </span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        else if(op[0]=='Q')&#123;</span></span><br><span class="line"><span class="regexp">            scanf("%d",&amp;s);</span></span><br><span class="line"><span class="regexp">            printf("%d\n",val[kth(rt,s+1)]);/</span><span class="regexp">/减去1 </span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">int main()&#123;</span></span><br><span class="line"><span class="regexp">    init();</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">    return 0;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> noip模拟赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 平衡树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SCOI2011 糖果</title>
      <link href="/2018/10/22/18/"/>
      <url>/2018/10/22/18/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>幼儿园里有N个小朋友，lxhgww老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。但是小朋友们也有嫉妒心，总是会提出一些要求，比如小明不希望小红分到的糖果比他的多，于是在分配糖果的时候，lxhgww需要满足小朋友们的K个要求。幼儿园的糖果总是有限的，lxhgww想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>输入的第一行是两个整数N，K。接下来K行，表示这些点需要满足的关系，每行3个数字，X，A，B。如果X=1， 表示第A个小朋友分到的糖果必须和第B个小朋友分到的糖果一样多；如果X=2， 表示第A个小朋友分到的糖果必须少于第B个小朋友分到的糖果；如果X=3， 表示第A个小朋友分到的糖果必须不少于第B个小朋友分到的糖果；如果X=4， 表示第A个小朋友分到的糖果必须多于第B个小朋友分到的糖果；如果X=5， 表示第A个小朋友分到的糖果必须不多于第B个小朋友分到的糖果；</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>输出一行，表示lxhgww老师至少需要准备的糖果数，如果不能满足小朋友们的所有要求，就输出-1。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>5 7<br>1 1 2<br>2 3 2<br>4 4 1<br>3 4 5<br>5 4 5<br>2 3 5<br>4 5 1</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>11</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>11<br>说明<br>【数据范围】</p><p>对于30%的数据，保证 N&lt;=100</p><p>对于100%的数据，保证 N&lt;=100000</p><p>对于所有的数据，保证 K&lt;=100000，1&lt;=X&lt;=5，1&lt;=A, B&lt;=N</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先，这道题要看出是一个差分约束系统，而求至少便是求最小值，所以应转化为$d[j]&gt;=d[i]+Wij$，<del>这样跑最长路(只有用spfa)并且判0环就行了</del>，然而发现这样只会有60，<br>因为数据大和毒，导致判0环会炸。然后发现可以强联通分量缩点，那么每个分量的值肯定是一样的，如果边中有1就说明不符合。最后加一个超级起点，从它开始拓扑加dp就能过了。</p><p>上代码：<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define maxn 150005</span></span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,op,a,b;</span><br><span class="line">typedef long long ll;</span><br><span class="line">struct eage&#123;</span><br><span class="line">int to,<span class="keyword">next</span>,len;</span><br><span class="line">&#125;e[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line">int np=<span class="number">0</span>,first[maxn];</span><br><span class="line">void add(int u,int v,int len)&#123;</span><br><span class="line">e[++np]=(eage)&#123;v,first[u],len&#125;;</span><br><span class="line">first[u]=np;</span><br><span class="line">&#125;</span><br><span class="line">ll d[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int st[maxn],top=<span class="number">0</span>,low[maxn],dfn[maxn],clock<span class="number">_</span>=<span class="number">0</span>,belong[maxn],cc=<span class="number">0</span>;</span><br><span class="line">bool ok=<span class="literal">false</span>;</span><br><span class="line">int stt[maxn],topp=<span class="number">0</span>;</span><br><span class="line">bool run()&#123;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=topp;i++)&#123;</span><br><span class="line">int t=stt[i];</span><br><span class="line"><span class="keyword">for</span>(int p=first[t];p;p=e[p].<span class="keyword">next</span>)&#123;</span><br><span class="line">int j=e[p].to,c=e[p].len;</span><br><span class="line"><span class="keyword">if</span>(belong[j]==belong[t]&amp;&amp;c==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int i)&#123;</span><br><span class="line">vis[i]=<span class="number">1</span>;</span><br><span class="line">dfn[i]=low[i]=++clock<span class="number">_</span>;</span><br><span class="line">st[++top]=i;</span><br><span class="line"><span class="keyword">for</span>(int p=first[i];p;p=e[p].<span class="keyword">next</span>)&#123;</span><br><span class="line">int j=e[p].to;</span><br><span class="line"><span class="keyword">if</span>(vis[j])&#123;</span><br><span class="line"><span class="keyword">if</span>(!belong[j]) low[i]=min(low[i],dfn[j]);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">dfs(j);</span><br><span class="line">low[i]=min(low[i],low[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(low[i]==dfn[i])&#123;</span><br><span class="line">cc++;topp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">int t=st[top--];</span><br><span class="line">belong[t]=cc;</span><br><span class="line">stt[++topp]=t;</span><br><span class="line"><span class="keyword">if</span>(t==i) <span class="keyword">break</span>;</span><br><span class="line">&#125; </span><br><span class="line">bool okk=run(); </span><br><span class="line"><span class="keyword">if</span>(okk==<span class="literal">true</span>) ok=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">struct node&#123;</span><br><span class="line">int to;ll len;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;node&gt;g[maxn];</span><br><span class="line">queue&lt;int&gt;q; </span><br><span class="line">int rd[maxn];</span><br><span class="line">void work()&#123;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(int p=first[i];p;p=e[p].<span class="keyword">next</span>)&#123;</span><br><span class="line">int j=e[p].to;ll c=e[p].len;</span><br><span class="line"><span class="keyword">if</span>(belong[j]!=belong[i]) g[belong[i]].push_back((node)&#123;belong[j],c&#125;),rd[belong[j]]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d[belong[n+<span class="number">1</span>]]=<span class="number">0</span>;</span><br><span class="line">q.push(belong[n+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">int i=q.front();q.pop();</span><br><span class="line"><span class="keyword">for</span>(int j=<span class="number">0</span>;j&lt;g[i].size();j++)&#123;</span><br><span class="line">node t=g[i][j];</span><br><span class="line">    int kk=t.to;ll c=t.len;</span><br><span class="line">    d[kk]=max(d[kk],d[i]+c);</span><br><span class="line">    rd[kk]--;</span><br><span class="line">    <span class="keyword">if</span>(rd[kk]==<span class="number">0</span>) q.push(kk);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    scanf(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    d[n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">scanf(<span class="string">"%d%d%d"</span>,&amp;op,&amp;a,&amp;b);</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">add(a,b,<span class="number">0</span>);</span><br><span class="line">add(b,a,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">add(a,b,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>)&#123;</span><br><span class="line">add(b,a,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">4</span>)&#123;</span><br><span class="line">add(b,a,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">5</span>)&#123;</span><br><span class="line">add(a,b,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++) add(n+<span class="number">1</span>,i,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[i]) dfs(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ok) printf(<span class="string">"-1"</span>);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">work();</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++) ans+=d[belong[i]];</span><br><span class="line">printf(<span class="string">"%lld"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">/<span class="regexp">/freopen("in.txt","r",stdin);</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/freopen("out.txt","w",stdout); </span></span><br><span class="line"><span class="regexp">init();</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">return 0;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> noip模拟赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 缩点 </tag>
            
            <tag> 拓扑 </tag>
            
            <tag> 差分约束系统 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>约束</title>
      <link href="/2018/10/20/17/"/>
      <url>/2018/10/20/17/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>现有 n 个点， n 条有向边。 要求将 n 个点分入两个集合 A， B，使得对于集合<br>A 中的每一个点 x，存在一个集合 B 中的点 y，从 y 到 x 有一条有向边。 问集合<br>A 最多能包含几个点。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行一个整数 n，表示总共有 n 个点。<br>接下来一行 n 个整数，表示一个序列 a， a[i]代表存在一条从第 i 个点到第<br>a[i]个点的有向边。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>一行一个数 ans， ans 是集合 A 最多能包含的点数。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>5<br>2 4 5 3 1</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>2</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>对于 30%的数据， n&lt;=10<br>对于 100%的数据， n&lt;=100000</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>发现一个点最多连向另外一个点，可以想一下发现是环加内向树。<br>那么对于入度为0的点便只能加入B集合，那么a[x]定可以为A集合，所以拓扑排序，将遇到的<br>为标记的或x和a[x]都为B的，将a[x]加入A。<br>最后剩下环，将环上的B集合的标记清空(这样可以更大)，然后以环上的A集合点向没有标记的点<br>蔓延赋值，最后就能得到最佳情况。</p><p>上代码：<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define maxn 100005</span></span><br><span class="line">using namespace std;</span><br><span class="line">int n,x,rd[maxn],a[maxn];</span><br><span class="line">queue&lt;int&gt;q;</span><br><span class="line">int color[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int calc;</span><br><span class="line">void init()&#123;</span><br><span class="line">scanf(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">scanf(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">a[i]=x;</span><br><span class="line">rd[x]++;</span><br><span class="line">&#125; </span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(rd[i]==<span class="number">0</span>) q.push(i),color[i]=<span class="number">1</span>;</span><br><span class="line">    int ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">    int i=q.front();q.pop();</span><br><span class="line">    <span class="keyword">if</span>(!color[a[i]])&#123;</span><br><span class="line">    color[a[i]]=<span class="number">3</span>-color[i];</span><br><span class="line">    <span class="keyword">if</span>(color[a[i]]==<span class="number">2</span>) ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(color[i]==<span class="number">1</span>&amp;&amp;color[a[i]]==<span class="number">1</span>) color[a[i]]=<span class="number">2</span>,ans++;</span><br><span class="line">rd[a[i]]--;</span><br><span class="line"><span class="keyword">if</span>(rd[a[i]]==<span class="number">0</span>) q.push(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(rd[i]&amp;&amp;color[i]==<span class="number">1</span>) color[i]=<span class="number">0</span>;<span class="regexp">//</span>将<span class="number">1</span>清完，从<span class="number">2</span>开始会更多 </span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(rd[i]&amp;&amp;color[i])&#123;</span><br><span class="line">int x=i;</span><br><span class="line"><span class="keyword">while</span>(!color[a[x]])&#123;</span><br><span class="line">color[a[x]]=<span class="number">3</span>-color[x];</span><br><span class="line"><span class="keyword">if</span>(color[a[x]]==<span class="number">2</span>) ans++;</span><br><span class="line">x=a[x];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">/*<span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">   <span class="keyword">if</span>(!color[i])&#123;</span><br><span class="line">   color[i]=<span class="number">1</span>;</span><br><span class="line">   int x=i;</span><br><span class="line">   <span class="keyword">while</span>(!color[a[x]])&#123;</span><br><span class="line">   color[a[x]]=<span class="number">3</span>-color[x];</span><br><span class="line">   <span class="keyword">if</span>(color[a[x]]==<span class="number">2</span>) ans++;</span><br><span class="line">   x=a[x];</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;*<span class="regexp">/</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">printf("%d",ans);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">int main()&#123;</span></span><br><span class="line"><span class="regexp">init();</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">return 0;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 拓扑 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>键盘</title>
      <link href="/2018/10/20/16/"/>
      <url>/2018/10/20/16/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>现在文本框中有一个 x 个字符的字符串,希望在经过一系列操作后得到看到<br>一个长度恰好为 n 的字符串。<br>现可以有 5 种操作:<br>1.敲击 1 次键盘,输入一个字符<br>2.敲击 2 次键盘(Ctrl+A),选中所有已经输入的字符<br>3.敲击 2 次键盘(Ctrl+C),复制所有选中的字符到剪贴板<br>4.敲击 2 次键盘(Ctrl+V),把剪贴板中的所有字符输出(不清空剪贴板)<br>5.敲击 1 次键盘(Backspace),若没有选中字符则删除一个字符否则删除所<br>有选中的字符<br>选中状态仅影响复制操作。<br>问至少敲击几次键盘才能得到一个长度为 n 的字符串。</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>对于 100%的数据 $n,x&lt;=10^6$</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>这道题思路很nice啊，如果不考虑backspace操作的话，那么是可以递推来做的。但如果有的话，那么可以3次清空为0，然后一直乘2大约140步左右可以大于$10^6$，也就是说极限步数是<br>n+143，实际上会远远不到这个上限，那么若x能到y则连一条边，由调和级数算下来(缩放)大约为nlogn，再最短路跑一遍大约$nlog^2n$，因为上限远远没满卡一下常数能过。(主要为这方面题提供一种思路)</p><h3 id="dij代码-会T三个点qwq，可能以为1-5操作距离太近不太友好"><a href="#dij代码-会T三个点qwq，可能以为1-5操作距离太近不太友好" class="headerlink" title="dij代码(会T三个点qwq，可能以为1,5操作距离太近不太友好)"></a>dij代码(会T三个点qwq，可能以为1,5操作距离太近不太友好)</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define maxn 2000305</span></span><br><span class="line">using namespace std;</span><br><span class="line">int n,x,dist[maxn];</span><br><span class="line">struct node&#123;</span><br><span class="line">int v,id;</span><br><span class="line">friend bool operator &lt;(node a,node b)&#123;</span><br><span class="line"><span class="keyword">return</span> a.v&gt;b.v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt;q; </span><br><span class="line">bool vis[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">scanf(<span class="string">"%d%d"</span>,&amp;x,&amp;n);</span><br><span class="line">memset(dist,<span class="number">0x3f</span>,sizeof(dist));</span><br><span class="line"><span class="keyword">if</span>(x&gt;n)&#123;</span><br><span class="line">   dist[n]=x-n;</span><br><span class="line">   dist[<span class="number">0</span>]=<span class="number">3</span>;</span><br><span class="line">   q.push((node)&#123;dist[<span class="number">0</span>],<span class="number">0</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">dist[n]=n-x;dist[x]=<span class="number">0</span>;q.push((node)&#123;dist[x],x&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">node t=q.top();q.pop();</span><br><span class="line">int i=t.id;<span class="keyword">if</span>(vis[i]) continue;</span><br><span class="line">vis[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i&lt;n) <span class="keyword">if</span>(dist[i+<span class="number">1</span>]&gt;dist[i]+<span class="number">1</span>)&#123;dist[i+<span class="number">1</span>]=dist[i]+<span class="number">1</span>;q.push((node)&#123;dist[i+<span class="number">1</span>],i+<span class="number">1</span>&#125;);&#125;;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>) continue;</span><br><span class="line"><span class="keyword">if</span>(dist[i-<span class="number">1</span>]&gt;dist[i]+<span class="number">1</span>)&#123;dist[i-<span class="number">1</span>]=dist[i]+<span class="number">1</span>;q.push((node)&#123;dist[i-<span class="number">1</span>],i-<span class="number">1</span>&#125;);&#125;;</span><br><span class="line">int len=<span class="number">4</span>;</span><br><span class="line">int m=<span class="number">2</span>*i;</span><br><span class="line"><span class="keyword">while</span>(m&lt;=n)&#123;</span><br><span class="line"><span class="keyword">if</span>(dist[m]&gt;dist[i]+len+<span class="number">2</span>)&#123;</span><br><span class="line">dist[m]=dist[i]+len+<span class="number">2</span>;q.push((node)&#123;dist[m],m&#125;);</span><br><span class="line">&#125;</span><br><span class="line">m=m+i;len+=<span class="number">2</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dist[n]&gt;dist[i]+len+<span class="number">2</span>+m-n) dist[n]=dist[i]+len+<span class="number">2</span>+m-n;<span class="regexp">//</span>超过的最快方法 </span><br><span class="line">&#125; </span><br><span class="line">printf(<span class="string">"%d"</span>,dist[n]);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="spfa-而spfa由于直接按加的顺序展开所以会好很多…"><a href="#spfa-而spfa由于直接按加的顺序展开所以会好很多…" class="headerlink" title="spfa(而spfa由于直接按加的顺序展开所以会好很多…)"></a>spfa(而spfa由于直接按加的顺序展开所以会好很多…)</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define maxn 2000305</span></span><br><span class="line">using namespace std;</span><br><span class="line">int n,x,dist[maxn];</span><br><span class="line">/*struct node&#123;</span><br><span class="line">int v,id;</span><br><span class="line">friend bool operator &lt;(node a,node b)&#123;</span><br><span class="line"><span class="keyword">return</span> a.v&gt;b.v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/priority_queue&lt;node&gt;q; </span></span><br><span class="line"><span class="regexp">queue&lt;int&gt;q;</span></span><br><span class="line"><span class="regexp">bool vis[maxn];</span></span><br><span class="line"><span class="regexp">void init()&#123;</span></span><br><span class="line"><span class="regexp">scanf("%d%d",&amp;x,&amp;n);</span></span><br><span class="line"><span class="regexp">memset(dist,0x3f,sizeof(dist));</span></span><br><span class="line"><span class="regexp">if(x&gt;n)&#123;</span></span><br><span class="line"><span class="regexp">   dist[n]=x-n;</span></span><br><span class="line"><span class="regexp">   dist[0]=3;</span></span><br><span class="line"><span class="regexp">   q.push(0);vis[0]=1;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">else&#123;</span></span><br><span class="line"><span class="regexp">dist[n]=n-x;dist[x]=0;q.push(x);vis[x]=1;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">while(!q.empty())&#123;</span></span><br><span class="line"><span class="regexp">int i=q.front();q.pop();</span></span><br><span class="line"><span class="regexp">vis[i]=0;</span></span><br><span class="line"><span class="regexp">if(i&lt;n) if(dist[i+1]&gt;dist[i]+1)&#123;dist[i+1]=dist[i]+1;if(!vis[i+1]) vis[i+1]=1,q.push(i+1);&#125;;</span></span><br><span class="line"><span class="regexp">if(i==0) continue;</span></span><br><span class="line"><span class="regexp">if(dist[i-1]&gt;dist[i]+1)&#123;dist[i-1]=dist[i]+1;if(!vis[i-1]) vis[i-1]=1,q.push(i-1);&#125;;</span></span><br><span class="line"><span class="regexp">int len=4;</span></span><br><span class="line"><span class="regexp">int m=2*i;</span></span><br><span class="line"><span class="regexp">while(m&lt;=n)&#123;</span></span><br><span class="line"><span class="regexp">if(dist[m]&gt;dist[i]+len+2)&#123;</span></span><br><span class="line"><span class="regexp">dist[m]=dist[i]+len+2;if(!vis[m]) vis[m]=1,q.push(m);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">m=m+i;len+=2; </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">if(dist[n]&gt;dist[i]+len+2+m-n) dist[n]=dist[i]+len+2+m-n;/</span><span class="regexp">/超过的最快方法 </span></span><br><span class="line"><span class="regexp">&#125; </span></span><br><span class="line"><span class="regexp">printf("%d",dist[n]);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">int main()&#123;</span></span><br><span class="line"><span class="regexp">init();</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">return 0;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
            <tag> 隐式图 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>祎隋</title>
      <link href="/2018/10/20/15/"/>
      <url>/2018/10/20/15/</url>
      
        <content type="html"><![CDATA[<font size="6" color="pink">生活，靠容忍和退让支撑着前行</font><p>《祎隋》</p><p>年幼时</p><p>你含糊地</p><p>把热情挥洒</p><p>年老时</p><p>你明白地</p><p>将运命呈出</p><p><img src="http://i4.bvimg.com/665863/fab3f3820c5ea04b.jpg" alt="小鞠"></p>]]></content>
      
      
      <categories>
          
          <category> 杂诗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂诗 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>noip模拟赛2</title>
      <link href="/2018/10/18/13/"/>
      <url>/2018/10/18/13/</url>
      
        <content type="html"><![CDATA[<h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>小 H 最近迷上了名为“石头，剪刀，布”的游戏。<br>游戏规则很简单：比赛双方同时数到三，然后同时出一个手势，代表“石<br>头”、“剪刀”或“布”。“石头”胜“剪刀”，“剪刀”胜“布”，“布”胜“石<br>头”。举个例子， 小 H 出“石头”， 对方出“布”，则对方胜利。当然，也可<br>以“平局”（如果双方手势相同的话）。<br>小 H 对阵小 B。 小 H 作为一个匹托专家，能够预测小 B 未来 N 回合的手<br>势。 但作为具有数学头脑的人， 他又是比较懒的，以至于他只愿意变换固<br>定次数的手势来完成游戏。例如， 他只想变 1 次，则他可能出“石头”几<br>次，剩下的都出“布”；或者其他。<br>现在小 H 与小 B 准备进行 N 回合的比赛，且已经测出小 B 未来 N 回合<br>的手势，小 H 只愿意改变 K 次手势（最开始手势任意）。请你帮小 H 求出他<br>最多能赢多少场</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>输入文件名为 game.in。<br>输入的第一行两个空格隔开的数字 N 和 K，分别表示比赛的回合数和<br>小 H 变换手势的次数。 接下来的 N 行，每行一个字母，表示小 B 的手势： ’H’<br>表示石头、 ’S’表示剪刀、 ’P’表示布</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>输出文件名为 game.out。<br>输出一行一个整数， 小 H 最多能赢的场数</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><p>5 1<br>P P H P S</p><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><p>4</p><h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><p>对于 30%的数据： N≤20<br>对于 100%的数据： N≤100 000， K≤20</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>一道水水的dp啊qwq，刷表和i-1到i转移都可以。注意细节…O($n \ast k$)实现就欧克。</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cctype&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cmath&gt;</span></span><br><span class="line"><span class="comment">#include&lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include&lt;queue&gt;</span></span><br><span class="line"><span class="comment">#include&lt;map&gt;</span></span><br><span class="line"><span class="comment">#include&lt;set&gt;</span></span><br><span class="line"><span class="comment">#include&lt;vector&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">#define maxn 100005</span></span><br><span class="line">int n,k,a[maxn],dp[maxn][<span class="number">22</span>][<span class="number">3</span>];<span class="regexp">//</span><span class="number">0</span><span class="symbol">:</span>石头,<span class="number">1</span>：剪刀,<span class="number">2</span><span class="symbol">:</span>布 </span><br><span class="line">char s[<span class="number">2</span>];</span><br><span class="line">void init()&#123;</span><br><span class="line">scanf(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;scanf(<span class="string">"%s"</span>,s);<span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'H'</span>)a[i]=<span class="number">0</span>;<span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'S'</span>) a[i]=<span class="number">1</span>;<span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'P'</span>) a[i]=<span class="number">2</span>;&#125;;</span><br><span class="line">/<span class="regexp">/dp[0][0][0]=dp[0][0][1]=dp[0][0][2]=0;</span></span><br><span class="line"><span class="regexp">for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="regexp">for(int j=0;j&lt;=min(i,k);j++)</span></span><br><span class="line"><span class="regexp">for(int kk=0;kk&lt;=2;kk++)&#123;/</span><span class="regexp">/枚举上一个的手势 </span></span><br><span class="line"><span class="regexp">int f=0;</span></span><br><span class="line"><span class="regexp">if(a[i]==2&amp;&amp;kk==1) f=1; </span></span><br><span class="line"><span class="regexp">if(a[i]==1&amp;&amp;kk==0) f=1;</span></span><br><span class="line"><span class="regexp">if(a[i]==0&amp;&amp;kk==2) f=1;</span></span><br><span class="line"><span class="regexp">dp[i][j][kk]=max(dp[i][j][kk],dp[i-1][j][kk]+f);/</span><span class="regexp">/不换</span></span><br><span class="line"><span class="regexp">int tt=(a[i]-1+3)%3;</span></span><br><span class="line"><span class="regexp">if(j&gt;=1)&#123;</span></span><br><span class="line"><span class="regexp">if(tt==kk) continue;/</span><span class="regexp">/不换..对身体好 </span></span><br><span class="line"><span class="regexp">dp[i][j][tt]=max(dp[i][j][tt],dp[i-1][j-1][kk]+1); </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">int maxx=0;</span></span><br><span class="line"><span class="regexp">for(int i=0;i&lt;=2;i++) maxx=max(maxx,dp[n][k][i]);</span></span><br><span class="line"><span class="regexp">printf("%d",maxx);</span></span><br><span class="line"><span class="regexp">&#125; </span></span><br><span class="line"><span class="regexp">int main()&#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/freopen("game.in","r",stdin);</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/freopen("game.out","w",stdout);</span></span><br><span class="line"><span class="regexp">init();</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">return 0;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p>为补贴家用，小 M 终于谋得一份兼职——牛奶销售员。<br>小 M 打算把牛奶销售到 N 个城市，这 N 个城市编号为 1..N。这些城市<br>之间有 R 条高速公路和 P 条泥泞小道连接。每条高速路或泥泞小道连接 N<br>个城市中的 A 和 B， 需要的花费为 C，对于高速路的花费 C， 一定是大于等<br>于 0 的；然而对于泥泞小道，由于边远城市的人民感谢送奶工的辛劳，会<br>额外付更多的奶钱， 所以有些小道的花费可能为负数（表示有收益）。高速<br>公路是双向的，可以从 A 走到 B，也可以从 B 走到 A；然后泥泞小道则不是<br>双向的，只能从 A 走到 B。事实上， 由于泥泞道路经过的都是蛮荒之地，所<br>以政府为了社会和谐，出台了一些政策保证： 如果一条泥泞小道可以从 A<br>到 B，那么保证不可能通过高速路或泥泞小道从 B 再回到 A。<br>小 M 的销售中心在城市 S，现在他想知道，把牛奶从 S 送到每个城市的<br>最小花费的，或者根本就不能送到。</p><h2 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h2><p>输入文件名为 sales.in。<br>输入的第 1 行包含四个空格隔开的整数: N, R, P 和 S，他们的意义如题<br>目描述。 第 2 到 R+1 行每行含三个空格隔开的整数： A, B 和 C，表示一条高<br>速公路双向连接城市 A 和 B，需要的花费为 C。 第 R+2 到 R+P+1 行每行包含<br>三个空格隔开的整数： A, B 和 C，表示一条泥泞小道可以从城市 A 到 B，需<br>要的花费为 C。</p><h2 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h2><p>输出文件名为 sales.out。<br>输出有 N 行，每行一个整数，第 i 行表示从 S 到达城市 i 的最小花费，<br>如果不存在输出”NO PATH”。</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h3><p>6 3 3 4<br>1 2 5<br>3 4 5<br>5 6 10<br>3 5 -100<br>4 6 -100<br>1 3 -10</p><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h3><p>NO PATH<br>NO PATH<br>5<br>0<br>-95<br>-100</p><h2 id="Hint-1"><a href="#Hint-1" class="headerlink" title="Hint"></a>Hint</h2><p>对于 30%的数据： N≤10 000<br>对于 100%的数据： 1≤N≤25,000 , 1≤P,R≤50,000<br>高速公路的 C： 0≤C≤10,000<br>泥泞小道的 C： -10,000≤C≤10,000</p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><p>这道题真的傻缺了啊qwq，别人想的是有负权边不能跑dij，我tm想的是没有负环直接跑dij，感觉复杂度差不多就直接交上去了哇qwq。实际上你的复杂度超乎你想象。<br><strong>开始正经：</strong><br>这道题有两种解法：<br>1.spfa+slf优化，好像勉强过得到？直接用双端队列deque维护一下。slf优化还是能加就加吧，毕竟挺简单的。不过关于spfa，<font color="red"><del>它已经死了.</del></font>所以稳妥一点还是用dij吧，对身体好a.<br>2.dij+缩点+拓扑：woc这个思路真的很nice啊，首先发现可以缩点连成一个DAG图，然后对于每个联通块单独跑dij，这样算下来总复杂度也就nlogn左右（事实证明真的跑得飞快！法1时间几乎是它的十倍）.然后就是注意细节的实现，也为这种<strong>混合图</strong>提供了一种思路。当把所有的入边处理完之后用vector记录入点，就可以队首存入多个起点，一次dij跑完，复杂度被大大减少.（可以回顾noip2017逛公园）.</p><p>上代码：<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define maxn 25005</span></span><br><span class="line"><span class="comment">#define maxm 150005</span></span><br><span class="line">using namespace std;</span><br><span class="line">struct eage&#123;</span><br><span class="line">int to,<span class="keyword">next</span>,len;</span><br><span class="line">&#125;e[maxm];</span><br><span class="line">int np=<span class="number">0</span>,first[maxn];</span><br><span class="line">void add(int u,int v,int len)&#123;</span><br><span class="line">e[++np]=(eage)&#123;v,first[u],len&#125;;</span><br><span class="line">first[u]=np;</span><br><span class="line">&#125;</span><br><span class="line">int n,r,p,s,x,y,z,dfn[maxn],low[maxn],belong[maxn],cc=<span class="number">0</span>,clock<span class="number">_</span>=<span class="number">0</span>;</span><br><span class="line">int st[maxn],top=<span class="number">0</span>,rd[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">vector&lt;int&gt;g[maxn];</span><br><span class="line">struct noded&#123;</span><br><span class="line">int from,to,len;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;noded&gt;b[maxn];</span><br><span class="line">void dfs(int i,int f)&#123;</span><br><span class="line">vis[i]=<span class="number">1</span>;</span><br><span class="line">st[++top]=i;</span><br><span class="line">low[i]=dfn[i]=++clock<span class="number">_</span>;</span><br><span class="line"><span class="keyword">for</span>(int p=first[i];p;p=e[p].<span class="keyword">next</span>)&#123;</span><br><span class="line">int j=e[p].to;</span><br><span class="line"><span class="keyword">if</span>(vis[j])&#123;</span><br><span class="line"><span class="keyword">if</span>(!belong[j]) low[i]=min(low[i],dfn[j]);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">dfs(j,i);</span><br><span class="line">low[i]=min(low[i],low[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(low[i]==dfn[i])&#123;</span><br><span class="line">    cc++;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    int t=st[top--];</span><br><span class="line">    belong[t]=cc;</span><br><span class="line">    <span class="keyword">if</span>(t==i) <span class="keyword">break</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int dist[maxn];</span><br><span class="line">bool viss[maxn];</span><br><span class="line">struct node&#123;</span><br><span class="line">int v,id;</span><br><span class="line">friend bool operator &lt;(node a,node b)&#123;</span><br><span class="line"><span class="keyword">return</span> a.v&gt;b.v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void dij(int s)&#123;</span><br><span class="line">    priority_queue&lt;node&gt;q;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;g[s].size();i++)&#123;</span><br><span class="line">int t=g[s][i];</span><br><span class="line">q.push((node)&#123;dist[t],t&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">node t=q.top();q.pop();</span><br><span class="line">int i=t.id;</span><br><span class="line"><span class="keyword">if</span>(viss[i]) continue;</span><br><span class="line">viss[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(int p=first[i];p;p=e[p].<span class="keyword">next</span>)&#123;</span><br><span class="line">int j=e[p].to,c=e[p].len;</span><br><span class="line"><span class="keyword">if</span>(belong[j]!=belong[i]) continue;</span><br><span class="line"><span class="keyword">if</span>(dist[j]&gt;dist[i]+c)&#123;</span><br><span class="line">dist[j]=dist[i]+c;</span><br><span class="line">q.push((node)&#123;dist[j],j&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">queue&lt;int&gt;qq;</span><br><span class="line">void work()&#123;</span><br><span class="line">memset(viss,<span class="number">0</span>,sizeof(viss));</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++) dist[i]=<span class="number">1000000007</span>;</span><br><span class="line">g[belong[s]].push_back(s);</span><br><span class="line">dist[s]=<span class="number">0</span>;</span><br><span class="line">qq.push(belong[s]);</span><br><span class="line"><span class="keyword">while</span>(!qq.empty())&#123;</span><br><span class="line">   int i=qq.front();qq.pop();</span><br><span class="line">   dij(i);</span><br><span class="line">   <span class="keyword">for</span>(int j=<span class="number">0</span>;j&lt;b[i].size();j++)&#123;</span><br><span class="line">   noded tt=b[i][j];</span><br><span class="line">   int t1=tt.from,t2=tt.to,c=tt.len;</span><br><span class="line">   dist[t2]=min(dist[t2],dist[t1]+c);</span><br><span class="line">   g[belong[t2]].push_back(t2);</span><br><span class="line">   rd[belong[t2]]--;</span><br><span class="line">   <span class="keyword">if</span>(rd[belong[t2]]==<span class="number">0</span>) qq.push(belong[t2]);</span><br><span class="line">   &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dist[i]==<span class="number">1000000007</span>) printf(<span class="string">"NO PATH\n"</span>);</span><br><span class="line"><span class="keyword">else</span> printf(<span class="string">"%d\n"</span>,dist[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">void run()&#123;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[i]) continue;</span><br><span class="line"><span class="keyword">for</span>(int p=first[i];p;p=e[p].<span class="keyword">next</span>)&#123;</span><br><span class="line">int j=e[p].to;</span><br><span class="line"><span class="keyword">if</span>(belong[j]!=belong[i])&#123;</span><br><span class="line">/<span class="regexp">/g[belong[i]].push_back(belong[j]);</span></span><br><span class="line"><span class="regexp">b[belong[i]].push_back((noded)&#123;i,j,e[p].len&#125;);</span></span><br><span class="line"><span class="regexp">rd[belong[j]]++;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">work();</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">void init()&#123;</span></span><br><span class="line"><span class="regexp">scanf("%d%d%d%d",&amp;n,&amp;r,&amp;p,&amp;s);</span></span><br><span class="line"><span class="regexp">for(int i=1;i&lt;=r;i++)&#123;</span></span><br><span class="line"><span class="regexp">scanf("%d%d%d",&amp;x,&amp;y,&amp;z);</span></span><br><span class="line"><span class="regexp">add(x,y,z);</span></span><br><span class="line"><span class="regexp">add(y,x,z);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">for(int i=1;i&lt;=p;i++)&#123;</span></span><br><span class="line"><span class="regexp">scanf("%d%d%d",&amp;x,&amp;y,&amp;z);</span></span><br><span class="line"><span class="regexp">add(x,y,z);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">dfs(s,0);</span></span><br><span class="line"><span class="regexp">run();</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">int main()&#123;</span></span><br><span class="line"><span class="regexp">init();</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">return 0;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><h2 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h2><p>小 Y 同学手上有两类线段，分别为 A 线段和 B 线段。<br>A 线段的有n种，第i种有$s_i$条，其左端点和右端点为$a_i$和$b_i$，他们都是109<br>范围内的正整数，且一定有$a_i$ ≤ $b_i$。 B 线段的有m种，第i种有$k_i$条，其左端<br>点和右端点为$l_i$和$r_i$，他们也是109范围内的正整数，且一定有$l_i$ ≤$r_i$。 小 Y<br>还规定，如果一条 A 线段($a_i$, $b_i$)能匹配一条 B 线段($l_i$, $r_i$)，当且仅当$l_i$ ≤ $a_i$≤<br>$b_i$ ≤ $r_i$。<br>现在小 Y 需要你判断能否为所有的 A 线段都指定一条与之匹配的 B 线段。<br>注意，无论是 A 线段还是 B 线段，每条都只能匹配一次，且仅能匹配一次。</p><h2 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h2><p>输入文件名为 machine.in<br>输入的第 1 行是一个整数T，表示数据组数。每组数据的第 1 行有两个<br>整数n, m，分别表 A 类线段和 B 类线段的种类数。接下来n行，每行 3 个整<br>数ai、 bi、 si，描述一种 A 类线段。接下来 m 行，每行三个整数li、 ri、 ki，<br>描述一种 B 类线段。</p><h2 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h2><p>输入文件名为 machine.out<br>仅输出共T行，每行一个字符串，若可以实现则输出 Yes，否则输出<br>No。</p><h2 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>3<br>2 2<br>1 4 2<br>3 5 1<br>1 4 2<br>2 5 1<br>3 2<br>1 3 1<br>2 4 1<br>3 5 1<br>1 3 2<br>2 5 1<br>2 2<br>1 2 2<br>1 2 1<br>1 2 1<br>1 2 2</p><h2 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>Yes<br>No<br>Yes</p><h2 id="Hint-2"><a href="#Hint-2" class="headerlink" title="Hint"></a>Hint</h2><p>对于所有数据保证有：<br>1 ≤ $s_i$, $k_i$ ≤ 109，<br>1 ≤ t≤ 50，<br>1 ≤ n, m ≤ 50000。<br>一个测试点中，所有n的和不超过 4000000，所有m的和也不超过 4000000。</p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><p>还是一道套路题a，用set维护直接nlognA了啊（没办法蒟蒻太蒻了）。稍微注意线段维护的细节，按照左端点排序，相同排右端点。然后用两个指针维护，对于每个i，将l小于等于它的加入到multiset里面（以右端点为关键字）然后每次lower_bound找一下就欧克了啊qwq.<br>(勉哥说对于每个被删掉的指针要查询它的下一个必须要预先处理好)</p><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>线段类的有很多问题可以总结a….上一次居然被那个线段贪心给卡了qwq(处理不重叠的最多线段)就是右端点排个序，左端点大的就可以加进去，贪贪贪</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define maxn 50005</span></span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">int l,r,w;</span><br><span class="line">friend bool operator &lt;(node a,node b)&#123;</span><br><span class="line"><span class="keyword">if</span>(a.l!=b.l)<span class="keyword">return</span> a.l&lt;b.l;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> a.r&lt;b.r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;nda[maxn],ndb[maxn];</span><br><span class="line">struct noded&#123;</span><br><span class="line">int r,w;</span><br><span class="line">friend bool operator &lt;(noded a,noded b)&#123;</span><br><span class="line"><span class="keyword">return</span> a.r&lt;b.r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">multiset&lt;noded&gt;s;</span><br><span class="line">multiset&lt;noded&gt;<span class="symbol">:</span><span class="symbol">:iterator</span> it,itt;</span><br><span class="line">int t,n,m;</span><br><span class="line">void init()&#123;</span><br><span class="line">scanf(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++) scanf(<span class="string">"%d%d%d"</span>,&amp;nda[i].l,&amp;nda[i].r,&amp;nda[i].w);</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=m;i++) scanf(<span class="string">"%d%d%d"</span>,&amp;ndb[i].l,&amp;ndb[i].r,&amp;ndb[i].w);</span><br><span class="line">sort(nda+<span class="number">1</span>,nda+n+<span class="number">1</span>);</span><br><span class="line">sort(ndb+<span class="number">1</span>,ndb+m+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">s.clear();</span><br><span class="line">int j=<span class="number">1</span>;<span class="regexp">//b</span>的序号 </span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="regexp">//a</span>的序号 </span><br><span class="line"><span class="keyword">while</span>(j&lt;=m&amp;&amp;ndb[j].l&lt;=nda[i].l) s.insert((noded)&#123;ndb[j].r,ndb[j].w&#125;),j++; </span><br><span class="line">noded tt=(noded)&#123;nda[i].r,<span class="number">0</span>&#125;;</span><br><span class="line">    it=s.lower_bound(tt);</span><br><span class="line"><span class="keyword">if</span>(it==s.<span class="keyword">end</span>()) &#123;printf(<span class="string">"No\n"</span>);<span class="keyword">return</span>;&#125; </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">noded t=*it; s.erase(it);</span><br><span class="line"><span class="keyword">if</span>(t.w&gt;=nda[i].w)&#123;t.w-=nda[i].w,nda[i].w=<span class="number">0</span>,s.insert((noded)&#123;t.r,t.w&#125;);<span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">else</span> nda[i].w-=t.w;</span><br><span class="line">it=s.lower_bound(tt);</span><br><span class="line"><span class="keyword">if</span>(it==s.<span class="keyword">end</span>())  &#123;printf(<span class="string">"No\n"</span>);<span class="keyword">return</span>;&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(<span class="string">"Yes\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">scanf(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> noip模拟赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> dijsktra </tag>
            
            <tag> spfa </tag>
            
            <tag> slf优化 </tag>
            
            <tag> 缩点 </tag>
            
            <tag> 拓扑 </tag>
            
            <tag> DAG图 </tag>
            
            <tag> set </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>noip模拟赛1</title>
      <link href="/2018/10/17/12/"/>
      <url>/2018/10/17/12/</url>
      
        <content type="html"><![CDATA[<h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>每天中午，美丽的重庆一中都会上演一场华丽的千人大竞走。<br>大量人流短时间涌进第二食堂， 食堂班长小 H 表示不淡定了，他必须合<br>理安排饭堂饭菜的价格，来让同学们有愉快的心情就餐。<br>已知第一饭堂饭菜的价格是有 N 位数字的整数，如果一个价格有不小于<br>K（1≤K≤N） 个数位完全相同，那么这个价格就被认为是漂亮的，否则这<br>个价格被认为是不漂亮的。 小 H 想改变其中一个饭菜价格，改变价格中的<br>一位数字需要花费一些钱， 钱数等于改前和改后的数字之差的绝对值。<br>小 H 希望你能把这个价格改地漂亮，求出最小花费，同时给出字典序最<br>小的修改方案。</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>输入文件名为 canteen.in。<br>输入的第一行两个空格隔开的数字 N 和 K(1≤K≤N)。 第二行是一个长<br>度为 N 位的数字， 表示原来的价格。</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>输出文件名为 canteen.out。<br>输出包含两行，第一行一个整数， 表示最小费用。 第二行是字典序最<br>小的方案。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><p>6 5<br>889696</p><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><p>4<br>888688</p><h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><p>对于 30%的数据： N≤10<br>对于 100%的数据： N≤100 000</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>比较水的一道贪心a，只是要注意细节，维护两个东西：最小费用和最小字典序。<br>显然最小费用优先级更大。我们枚举相同的k个数字从0到9，对于每一个确定的st,<br>用i=0~9依次考虑变的数字，注意先执行st+i，再执行st-i以保证字典序最优。<br>然后对于小于st的从后往前改，大于st的从前往后改来保证字典序。</p><h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4><p>（想好细节,think twice,code once）<br>上代码：</p><h2 id="The-Code"><a href="#The-Code" class="headerlink" title="The Code"></a>The Code</h2><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include&lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cmath&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cctype&gt;</span></span><br><span class="line"><span class="comment">#include&lt;vector&gt;</span></span><br><span class="line"><span class="comment">#include&lt;queue&gt;</span></span><br><span class="line"><span class="comment">#include&lt;map&gt;</span></span><br><span class="line"><span class="comment">#include&lt;set&gt; </span></span><br><span class="line"><span class="comment">#define maxn 100005</span></span><br><span class="line">using namespace std;</span><br><span class="line">int n,k;</span><br><span class="line">char s[maxn];</span><br><span class="line">char ss[maxn];</span><br><span class="line">char tt[maxn];</span><br><span class="line">int cnt[<span class="number">10</span>];</span><br><span class="line">int minn=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">int yb[<span class="number">10</span>];</span><br><span class="line">int calc[<span class="number">10</span>];</span><br><span class="line">bool cmp()&#123;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(tt[i]&lt;ss[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(tt[i]&gt;ss[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">scanf(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">scanf(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++) cnt[s[i]-<span class="string">'0'</span>]++,ss[i]=<span class="string">'9'</span>;<span class="regexp">//</span>最大化 </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(int st=<span class="number">0</span>;st&lt;=<span class="number">9</span>;st++)&#123;</span><br><span class="line">int t=k;<span class="regexp">//</span>要变的个数 </span><br><span class="line">int ans=<span class="number">0</span>;<span class="regexp">//</span>要花的钱 </span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt[st]&gt;=t) <span class="keyword">break</span>;</span><br><span class="line">t-=cnt[st];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">int t1=st+i,t2=st-i;</span><br><span class="line"><span class="keyword">if</span>(t1&lt;=<span class="number">9</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt[t1]&gt;=t)&#123;ans+=t*i;<span class="keyword">break</span>;&#125;</span><br><span class="line">t-=cnt[t1];ans+=cnt[t1]*i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t2&gt;=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt[t2]&gt;=t)&#123;ans+=t*i;<span class="keyword">break</span>;&#125;</span><br><span class="line">t-=cnt[t2];ans+=cnt[t2]*i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">minn=min(minn,ans);</span><br><span class="line">    calc[st]=ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(int st=<span class="number">0</span>;st&lt;=<span class="number">9</span>;st++)&#123;</span><br><span class="line"><span class="keyword">if</span>(calc[st]==minn)&#123;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++) tt[i]=s[i];</span><br><span class="line">memset(yb,<span class="number">0</span>,sizeof(yb));</span><br><span class="line">int t=k;<span class="regexp">//</span>要变的个数 </span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt[st]&gt;=t) <span class="keyword">break</span>;</span><br><span class="line">t-=cnt[st];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">int t1=st+i,t2=st-i;</span><br><span class="line"><span class="keyword">if</span>(t1&lt;=<span class="number">9</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt[t1]&gt;=t)&#123;yb[t1]=t;<span class="keyword">break</span>;&#125;</span><br><span class="line">t-=cnt[t1];yb[t1]=cnt[t1];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t2&gt;=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt[t2]&gt;=t)&#123;yb[t2]=t;<span class="keyword">break</span>;&#125;</span><br><span class="line">t-=cnt[t2];yb[t2]=cnt[t2];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(yb[i])&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;st)&#123;</span><br><span class="line"><span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=n;j++) <span class="keyword">if</span>(s[j]==(i+<span class="string">'0'</span>)) <span class="keyword">if</span>(yb[i])tt[j]=st+<span class="string">'0'</span>,yb[i]--; <span class="keyword">else</span>&#123;<span class="keyword">break</span>;&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(int j=n;j&gt;=<span class="number">1</span>;j--) <span class="keyword">if</span>(s[j]==(i+<span class="string">'0'</span>)) <span class="keyword">if</span>(yb[i])tt[j]=st+<span class="string">'0'</span>,yb[i]--; <span class="keyword">else</span>&#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cmp()) <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++) ss[i]=tt[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(<span class="string">"%d\n"</span>,minn);</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++) printf(<span class="string">"%c"</span>,ss[i]);</span><br><span class="line">    /*memset(dp,<span class="number">0x3f</span>,sizeof(dp));</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++) dp[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=min(i,k);j++)</span><br><span class="line">    <span class="keyword">for</span>(int kk=<span class="number">1</span>;kk&lt;=<span class="number">9</span>;kk++)&#123;</span><br><span class="line">    dp[j][kk]=min(dp[j][kk],dp[j-<span class="number">1</span>][kk]+abs(s[i]-<span class="string">'0'</span>-kk)); </span><br><span class="line">    &#125;</span><br><span class="line">    int minn=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++) minn=min(minn,dp[k][i]);</span><br><span class="line">    printf(<span class="string">"%d"</span>,minn);*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">int main()&#123;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/freopen("canteen.in","r",stdin);</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/freopen("canteen.out","w",stdout);</span></span><br><span class="line"><span class="regexp">init();</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">return 0;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p>小 M 新设计了一款战略游戏。<br>游戏的地图包含有 N 个阵地（用 1..N 编号），用 N-1 条战略交通线把它<br>们连接起来， 地图中任意两个阵地都能直接或间接地相互到达。 小 M 为每<br>条交通线设定一个名为“战略重要性”的参数，它是一个正整数，且这个<br>数值越大，说明这条交通线的战略重要性越大。 小 M 还设计了一个阵地间<br>的“战略相关性”的度量标准， 那就是两个阵地间路径上“战略重要性”<br>最小的交通线。<br>小 M 已经完成了游戏大多数模块的代码， 还有一个在线查询模块没有完<br>成，即对于用户查询： k， v，表示查询与阵地 v“战略相关性” 不小于 k 的<br>阵地的数目。<br>由于小 M 还要负责游戏的推广， 所以这个查询模块的代码就交给你了。</p><h2 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h2><p>输入文件名为 strategy.in。<br>第一行输入包含 N 和 Q。 接下来的 N-1 行描述地图中的交通线。 每行<br>包括三个整数 pi,qi 和 ri ( 1≤pi,qi≤N， ri&lt;=1000000000 )，表示阵地 pi 和 qi<br>的战略重要性为 ri 。接下来的 Q 行描述了 Q 次查询。 每行包含两个整数，<br>k 和 v (1≤k≤1,000,000,000, 1≤v≤N )，表示一次查询。</p><h2 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h2><p>输出文件名为 strategy.out。<br>输出 Q 行。在第 i 行输出第 i 次查询的的答案。</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h3><p>4 3<br>1 2 3<br>2 3 2<br>2 4 4<br>1 2<br>4 1<br>3 1</p><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h3><p>3<br>0<br>2</p><h2 id="Hint-1"><a href="#Hint-1" class="headerlink" title="Hint"></a>Hint</h2><p>对于 20%的数据： N,Q≤3 00<br>对于 50%的数据： N,Q≤5 000<br>对于 100%的数据： N,Q≤100 000</p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><p>首先会想到离线处理，再根据单调性，想到用并查集维护，将大于等于k的边所连接的点加入并查集，<br>这样对于每个联通块，其中任意两点都是符合“战略相关性”大于等于k的，所以对于每个询问，答案<br>就是v所在联通块点个数减1即可。</p><p>上代码：</p><h2 id="The-Code-1"><a href="#The-Code-1" class="headerlink" title="The Code"></a>The Code</h2><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">#define maxn 100005</span></span><br><span class="line">struct eage&#123;</span><br><span class="line">int u,v,len;</span><br><span class="line">friend bool operator &lt;(eage a,eage b)&#123;</span><br><span class="line"><span class="keyword">return</span> a.len&gt;b.len;</span><br><span class="line">&#125;</span><br><span class="line">&#125;e[maxn];</span><br><span class="line">int np=<span class="number">0</span>;</span><br><span class="line">int n,q,x,y,z,fa[maxn],sz[maxn];</span><br><span class="line">struct node&#123;</span><br><span class="line">int id,k,v,ans;</span><br><span class="line">friend bool operator&lt;(node a,node b)&#123;</span><br><span class="line"><span class="keyword">return</span> a.k&gt;b.k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;nd[maxn];</span><br><span class="line">bool cmp(node a,node b)&#123;</span><br><span class="line"><span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">&#125;</span><br><span class="line">int find(int i)&#123;</span><br><span class="line"><span class="keyword">if</span>(fa[i]==i) <span class="keyword">return</span> i;</span><br><span class="line">int root=find(fa[i]);</span><br><span class="line">fa[i]=root;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">void link(int x,int y)&#123;</span><br><span class="line">int fx=find(x),fy=find(y);</span><br><span class="line"><span class="keyword">if</span>(fx!=fy)&#123;</span><br><span class="line">fa[fx]=fy;</span><br><span class="line">sz[fy]+=sz[fx];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bool check(int x,int y)&#123;</span><br><span class="line">int fx=find(x),fy=find(y);</span><br><span class="line"><span class="keyword">if</span>(fx!=fy) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">scanf(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i,sz[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">scanf(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">e[++np]=(eage)&#123;x,y,z&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">scanf(<span class="string">"%d%d"</span>,&amp;nd[i].k,&amp;nd[i].v);nd[i].id=i;</span><br><span class="line">&#125;</span><br><span class="line">sort(e+<span class="number">1</span>,e+np+<span class="number">1</span>);sort(nd+<span class="number">1</span>,nd+q+<span class="number">1</span>);</span><br><span class="line">int j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j&lt;=np&amp;&amp;e[j].len&gt;=nd[i].k)&#123;</span><br><span class="line">link(e[j].u,e[j].v);</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">nd[i].ans=sz[find(nd[i].v)]-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">sort(nd+<span class="number">1</span>,nd+q+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=q;i++) printf(<span class="string">"%d\n"</span>,nd[i].ans);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><h2 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h2><p>小 Y 正用图章和颜料在草稿纸上乱涂颜色。对于数学敏感的他，突然发<br>现这是一个有意思的数学问题：<br>给出有 N 个格子的纸、宽度为 K 个格子的图章和 M 种不同的颜色，每<br>次用图章把纸上连续的 K 个格子上染任意一种颜色，最后把纸涂满，那么<br>小 Y 想知道最后纸上的颜色序列有多少种不同的情况？</p><h2 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h2><p>输入文件名为 paint.in<br>输入数据仅一行，包含三个整数 N,M,K，他们中间用一个空格分开，分<br>别表示纸张的长度，颜色数目和图章的宽度。</p><h2 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h2><p>输入文件名为 paint.out<br>输出文件仅一行，一个非负整数，表示答案。这个数可能很大，请模<br>1000000007 后输出。</p><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input"></a>Sample Input</h3><p>3 2 2</p><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output"></a>Sample Output</h3><p>6</p><h2 id="Hint-2"><a href="#Hint-2" class="headerlink" title="Hint"></a>Hint</h2><p>对于 20%的数据 N,M,K≤5<br>对于 50%的数据 N,K≤1 000<br>对于 100%的数据 N,M,K≤10 000 000</p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><p>真的是数学问题吗？？？首先要明白一点，合法的是要求至少有一个长度为K的相同颜色的块。（这个都没有想出来我好蒻A qwq）<br>然后正难则反，我们只要求出不合法的总个数，然后用总的方法数减去不合法的即为合法的方案数，那么这里用dp,设f[i]为前i个<br>不合法的方案数，那么就不会出现连续k个，所以：<br>$f[i]=f[i-1] \ast m （i&lt;k）​$</p><p>$f[i]=(f[i-1]+f[i-2]+…+f[i-k+1]) \ast (m-1) (i&gt;=k)$  第i个和第i-k个必须不一样<br>再简单加个滑动窗口就可以O(n)过了233333</p><h3 id="tips-1"><a href="#tips-1" class="headerlink" title="tips"></a>tips</h3><p>题目中有mod的话，一般不是dp就是数学（套路！！！）<br>上代码：</p><h2 id="The-Code-2"><a href="#The-Code-2" class="headerlink" title="The Code"></a>The Code</h2><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define maxn 10000005</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll mod=<span class="number">1000000007</span>;</span><br><span class="line">int n,m,k;</span><br><span class="line">ll dp[maxn];</span><br><span class="line">ll qkpow(ll t,int pos)&#123;</span><br><span class="line"><span class="keyword">if</span>(pos==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(pos==<span class="number">1</span>) <span class="keyword">return</span> t%mod;</span><br><span class="line">ll tt=qkpow(t,pos/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(pos&amp;<span class="number">1</span>) <span class="keyword">return</span> tt*tt%mod*t%mod;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> tt*tt%mod;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">scanf(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">ll all=qkpow(m,n);</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">ll sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;k;i++) dp[i]=dp[i-<span class="number">1</span>]*m%mod,sum=(sum+dp[i])%mod;</span><br><span class="line"><span class="keyword">for</span>(int i=k;i&lt;=n;i++)&#123;</span><br><span class="line">dp[i]=(sum)*(m-<span class="number">1</span>)%mod;</span><br><span class="line">sum=(sum+dp[i]-dp[i-k+<span class="number">1</span>]+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line">ll ans=(all-dp[n]+mod)%mod;</span><br><span class="line">printf(<span class="string">"%lld"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结：总结套路a鸽子，多想想那些大佬是怎么思考的。（think-twice-code-once）"><a href="#小结：总结套路a鸽子，多想想那些大佬是怎么思考的。（think-twice-code-once）" class="headerlink" title="小结：总结套路a鸽子，多想想那些大佬是怎么思考的。（think twice,code once）"></a>小结：总结套路a鸽子，多想想那些大佬是怎么思考的。（think twice,code once）</h3>]]></content>
      
      
      <categories>
          
          <category> noip模拟赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 离线 </tag>
            
            <tag> 数学 </tag>
            
            <tag> dp </tag>
            
            <tag> 正难则反 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>祎隋</title>
      <link href="/2018/10/16/11/"/>
      <url>/2018/10/16/11/</url>
      
        <content type="html"><![CDATA[<p><font size="6" color="pink">童话，被同化前做过的梦</font><br>《祎隋》</p><p>我们因多少人孤单</p><p>又有多少人为我们不安</p><p>等待是漫长的表演</p><p>相安是莫大的荒诞</p><p>为搏那一瞬笑颜 熹光几点</p><p>我们敢于冒险 心怀本愿</p><p>却屡次三番 无法实现</p><p>使得停滞不前 初心淡暗</p><p>何时起相顾无言 仿佛就从昨天</p><p>再忆那春风不及的笑脸 已是许久以前</p><p>颔首 低眉 轻笑 每个瞬间</p><p>浅唱 微吟 翩舞 总拨心弦</p><p>可我没有华丽诗篇 没有道貌伟岸</p><p>只有痴心一片 闲心几点</p><p>忽而悄然自言 你可曾是我心中的四月天？</p><p>回神漠然 青春已半</p><p>不如数月以前 我们未曾相见</p><p>窗沿 雨 雷电 深夜未眠</p><p>愿初心不变 心境自然</p><p>虽喜忧掺半 往前仍是少年</p><p><img src="http://i4.bvimg.com/665863/e6f981282aa49dcf.jpg" alt="小鞠1"></p>]]></content>
      
      
      <categories>
          
          <category> 杂诗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂诗 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CF350E Wrong Floyd</title>
      <link href="/2018/10/16/10/"/>
      <url>/2018/10/16/10/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定n个点,m条边以及k个标记点，要求进行Floyd时只以标记的点为中间点进行松弛操作（每条边边权为1）要求你造出m条边的数据来hack掉这种程序。</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>3&lt;=n&lt;=300 , 2&lt;=k&lt;=n2&lt;=k&lt;=n , n-1&lt;=m&lt;=n*(n-1)/2;</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>我们只需要任意一点只和非标记点连边就可以了（这样就无法正确更新它到其他点的距离）</p><p>具体一下几个细节：</p><p>1.判k==n或m&gt;最多可以构出的边maxm；</p><p>maxm=(n-1)*(n-2)/2+num;（num:非标记点的数量）</p><p>2.将随便一个标记点与所以非标记点连边；</p><p>3.再随便一个非标记点与未加入图中的点连边来保证图的联通；</p><p>4.最后随便加未加的边使边数凑够m即可；</p><h1 id="The-Code"><a href="#The-Code" class="headerlink" title="The Code"></a>The Code</h1><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define maxn 310</span></span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,k,x,num;</span><br><span class="line">bool vis[maxn],iss[maxn][maxn],viss[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">    scanf(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++) iss[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=k;i++) scanf(<span class="string">"%d"</span>,&amp;x),vis[x]=<span class="number">1</span>;</span><br><span class="line">    num=n-k;</span><br><span class="line">    int maxx=(n-<span class="number">1</span>)*(n-<span class="number">2</span>)/<span class="number">2</span>+num;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;maxx<span class="params">||</span>k==n)&#123;</span><br><span class="line">        printf(<span class="string">"-1"</span>);<span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    int t,tt=<span class="number">1</span>;int calc=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!vis[tt]) tt++; </span><br><span class="line">    viss[tt]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            t=i;</span><br><span class="line">            viss[t]=<span class="number">1</span>;</span><br><span class="line">            printf(<span class="string">"%d %d\n"</span>,t,tt);</span><br><span class="line">            iss[t][tt]=iss[tt][t]=<span class="number">1</span>;</span><br><span class="line">            calc++; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /<span class="regexp">/保证联通 </span></span><br><span class="line"><span class="regexp">    for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="regexp">        if(viss[i]) continue;</span></span><br><span class="line"><span class="regexp">        printf("%d %d\n",i,t); </span></span><br><span class="line"><span class="regexp">        iss[i][t]=iss[t][i]=1;</span></span><br><span class="line"><span class="regexp">        calc++;</span></span><br><span class="line"><span class="regexp">        if(calc==m) break;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">    for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="regexp">        if(calc==m) break;</span></span><br><span class="line"><span class="regexp">        if(i==tt) continue;</span></span><br><span class="line"><span class="regexp">        for(int j=1;j&lt;=n;j++)&#123;</span></span><br><span class="line"><span class="regexp">            if(j==tt) continue;</span></span><br><span class="line"><span class="regexp">            if(iss[i][j]) continue;</span></span><br><span class="line"><span class="regexp">            printf("%d %d\n",i,j);</span></span><br><span class="line"><span class="regexp">            calc++;</span></span><br><span class="line"><span class="regexp">            iss[i][j]=iss[j][i]=1;</span></span><br><span class="line"><span class="regexp">            if(calc==m) break;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">int main()&#123;</span></span><br><span class="line"><span class="regexp">    init();</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">    return 0;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>32.Sort</title>
      <link href="/2018/10/16/9/"/>
      <url>/2018/10/16/9/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>众所周知，排序方法有许多种。例如：简单易懂的冒泡排序，平均复杂度较优的快速排序，以及不基于比较的基数排序等等。<br><a id="more"></a></p><p>现在，小 DD 得到了一个自然数序列 {a1,a2,⋯,an}{a1,a2,⋯,an}。他想要对其按照从小到大的顺序进行排序（即使得每个元素均严格不大于他的后继元素）。但由于基于比较的排序算法复杂度下界已经被证明为 Θ(nlog2n)Θ(nlog2⁡n)，所以小 DD 决定尝试一种全新的排序算法：翻转排序。</p><p>在翻转排序中，小 DD 在每次操作中，可以选择一个区间 [l,r][l,r] (1≤l≤r≤n)(1≤l≤r≤n)，并翻转 al,al+1,⋯,aral,al+1,⋯,ar。即，在该次操作完后，序列将会变为 a1,a2,⋯,al−1,ar,ar−1,⋯,al+1,al,ar+1,ar+2,⋯,ana1,a2,⋯,al−1,ar,ar−1,⋯,al+1,al,ar+1,ar+2,⋯,an。</p><p>例如，对于序列 [1,6,2,4,3,5][1,6,2,4,3,5]，若选择区间 [2,4][2,4] 进行翻转，则将会得到 [1,4,2,6,3,5][1,4,2,6,3,5]。</p><p>定义一次操作的代价为 r−l+1r−l+1，即翻转的区间长度。定义一个操作序列的代价为每次操作的代价之和。现在，请你帮助小 DD 求出一个代价足够小的操作序列（你并不一定要求出代价最小的操作序列）。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行一个正整数 nn，表示序列长度。</p><p>第二行 nn 个空格隔开的非负整数，表示小 DD 得到的自然数序列 a1,a2,⋯,ana1,a2,⋯,an。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>输出若干行，每行两个空格隔开的正整数 l,rl,r (1≤l≤r≤n)(1≤l≤r≤n)，表示一次翻转区间 [l,r][l,r] 的操作。</p><p>最后输出一行 -1 -1，标志着操作序列的结束。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>4 1 3 2 4</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>2 3 -1 -1</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>1.下发文件中提供了 checker.cpp，该程序将对于其所在目录下的 sort.in，判断其所在目录下的 sort.out 是否为一个正确的操作序列。若正确，将给出该操作序列的代价。若不正确，将给出错误信息。选手可以借助该程序来更好地检查自己的程序是否正确。</p><p>运行时，必须保证 sort.in 为一个合法的输入，且需保证 sort.out 符合题目中描述的输出格式，否则出现任何结果均有可能。</p><p>2.对于所有测试数据，保证 1≤n≤500001≤n≤50000，且 0≤ai≤1090≤ai≤109。</p><p>（附checker.cpp）<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstdio&gt;</span></span><br><span class="line">int arr[<span class="number">50005</span>];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fin = fopen(<span class="string">"sort.in"</span>, <span class="string">"r"</span>), *fout = fopen(<span class="string">"sort.out"</span>, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fin)</span><br><span class="line">    &#123;</span><br><span class="line">        puts(<span class="string">"INVALID : File sort.in not found."</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!fout)</span><br><span class="line">    &#123;</span><br><span class="line">        puts(<span class="string">"INVALID : File sort.out not found."</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    int n;</span><br><span class="line">    fscanf(fin, <span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        fscanf(fin, <span class="string">"%d"</span>, arr + i);</span><br><span class="line">    int l, r, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (~fscanf(fout, <span class="string">"%d%d"</span>, &amp;l, &amp;r))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == -<span class="number">1</span> &amp;&amp; r == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        sum += r - l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= <span class="number">0</span> <span class="params">||</span> l &gt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(<span class="string">"INVALID : l = %d is not in range [1, %d].\n"</span>, l, n);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &lt;= <span class="number">0</span> <span class="params">||</span> r &gt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(<span class="string">"INVALID : r = %d is not in range [1, %d].\n"</span>, r, n);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(<span class="string">"INVALID : %d = l &gt; r = %d.\n"</span>, l, r);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; <span class="number">20000000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            puts(<span class="string">"INVALID : Too much cost."</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::reverse(arr + --l, arr + r);</span><br><span class="line">    &#125;</span><br><span class="line">    bool f = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        f &amp;= arr[i] &gt;= arr[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (!f)</span><br><span class="line">    &#123;</span><br><span class="line">        puts(<span class="string">"INVALID : Not sorted."</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"VALID : Total cost is %d.\n"</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checker</span><br></pre></td></tr></table></figure></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>本题算是一个比较新颖的题目，实际上是用这种翻转来模拟实现归并排序:</p><p>先将给定数列进行离散化，每次选定一个中间的数，将小于等于它的排在左边，大于它的排在右边，再依次递归两边就可以了；</p><p>主要是复杂度（进行操作的次数）证明a….    排一遍要n，由于其非01性，所以进行log2n次的n排，故排一遍将l到r以stdd为标准换为左边小于等于stdd，右边大于等于stdd的操作数为Θ(nlog2n) ；</p><p>T(n) = 2T(n/2) + Θ(nlog2n),可以解得 T(n) = Θ(nlog22n) ； tql%%%<br>上代码。<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define maxn 50005</span></span><br><span class="line">using namespace std;</span><br><span class="line">int n,pos[maxn];</span><br><span class="line">struct node&#123;</span><br><span class="line">    int v,id;</span><br><span class="line">    friend bool operator&lt;(node a,node b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.v&lt;b.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;nd[maxn];</span><br><span class="line">int stdd;</span><br><span class="line">void run(int l,int r)&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    int mid=l+r<span class="meta">&gt;&gt;</span><span class="number">1</span>;</span><br><span class="line">    run(l,mid);run(mid+<span class="number">1</span>,r);</span><br><span class="line">    </span><br><span class="line">    int L,R;<span class="regexp">//</span>要翻转的区间 </span><br><span class="line">    L=R=mid;<span class="regexp">//</span>L和R的初值 </span><br><span class="line">    int i=mid,j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=l&amp;&amp;pos[i]&gt;stdd) L=i--;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r&amp;&amp;pos[j]&lt;=stdd) R=j++;</span><br><span class="line">    <span class="keyword">if</span>(L!=R)&#123;</span><br><span class="line">        printf(<span class="string">"%d %d\n"</span>,L,R);</span><br><span class="line">        reverse(pos+L,pos+R+<span class="number">1</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">void msort(int l,int r)&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    int mid=stdd=(l+r)<span class="meta">&gt;&gt;</span><span class="number">1</span>;</span><br><span class="line">    run(l,r);<span class="regexp">//</span>将l到r以stdd为标准换为左边小于等于stdd，右边大于等于stdd</span><br><span class="line"> </span><br><span class="line">    msort(l,mid);msort(mid+<span class="number">1</span>,r);    </span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    scanf(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(<span class="string">"%d"</span>,&amp;nd[i].v);nd[i].id=i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(nd+<span class="number">1</span>,nd+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++) pos[nd[i].id]=i;<span class="regexp">//</span>离散化位置确定 </span><br><span class="line">    </span><br><span class="line">    msort(<span class="number">1</span>,n);</span><br><span class="line">    printf(<span class="string">"-1 -1\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    /<span class="regexp">/freopen("sort.in","r",stdin);</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/freopen("sort.out","w",stdout);</span></span><br><span class="line"><span class="regexp">    init();</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">    return 0;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Noi.ac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
            <tag> 离散化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数对子</title>
      <link href="/2018/10/16/8/"/>
      <url>/2018/10/16/8/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>我们定义一个数对 (x,y) 是好的，当且仅当 x≤y，且 x xor y的二进制表示下有奇数个 1</p><p>现在给定 nn 个区间 [li,ri]，你需要对于每个 i∈[1,n]，输出有几对好的数 (x,y)满足 x 和 y 都在 [l1,r1]∪[l2,r2]…∪[li,ri]，即两个数都在前 i 个区间的并里<br><a id="more"></a></p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行一个正整数 n</p><p>接下来 n 行每行两个整数 [li,ri]，表示第 i个区间，保证 li≤ri</p><h1 id="Ouput"><a href="#Ouput" class="headerlink" title="Ouput"></a>Ouput</h1><p>输出 n 行，第 i行一个整数表示有几对好的数 (x,y) 满足 x,y 都在前 i 个区间的并里</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>3</p><p>1 7</p><p>3 10</p><p>9 20</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>12</p><p>25</p><p>100</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>对于 30%30% 的数据，有 1≤n≤1001≤n≤100，1≤li≤ri≤1001≤li≤ri≤100</p><p>对于 50%50% 的数据，有 1≤n≤10001≤n≤1000，1≤li≤ri≤232−11≤li≤ri≤232−1</p><p>对于 100%100% 的数据，有 1≤n≤1051≤n≤105, 1≤li≤ri≤232−11≤li≤ri≤232−1</p><p>时间限制：2s</p><p>空间限制：512MB</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>先补充几个小知识点（快速求出一个数的二进制中有多少个1）:</p><p>x=x&amp;(x-1)（递归求法，适用于单个数）</p><p>表达式的意思就是:把x的二进制表示 从低位开始，将遇到的第一个为1的 二进制位 置0。</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">int calc=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x) x=x&amp;(x-<span class="number">1</span>),calc++;</span><br><span class="line">calc即为所求值</span><br></pre></td></tr></table></figure><p>求0到x中有多少二进制含1个数为奇数的：</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">long long calc(long long x)</span><br><span class="line">&#123;</span><br><span class="line">    long long tmp=x,tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp&amp;<span class="number">1</span>)tot++;</span><br><span class="line">        tmp<span class="meta">&gt;&gt;=</span><span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (x<span class="meta">&gt;&gt;</span><span class="number">1</span>)+((x&amp;<span class="number">1</span>) <span class="params">||</span> (tot&amp;<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">证明：<span class="number">00</span> <span class="number">01</span> <span class="number">10</span> <span class="number">11</span> <span class="number">100</span> <span class="number">101</span> <span class="number">110</span> <span class="number">111</span>....继续下去可以发现规律是偶奇奇偶奇偶偶奇....</span><br><span class="line">所以x<span class="meta">&gt;&gt;</span><span class="number">1</span>之前一半的，如果x为奇数（会少算一个）或其本身有奇数个<span class="number">1</span>得加上</span><br></pre></td></tr></table></figure><p>所以说探究性质a老哥(这个性质也可以记住)</p><p>p.s.当线段树叶子节点有n个时，应开总共2^(log2n+1)个点，即2*n个点</p><h2 id="正经题解开始："><a href="#正经题解开始：" class="headerlink" title="正经题解开始："></a>正经题解开始：</h2><p>首先，对于每个数对（x,y）, 若要x xor y的二进制表示下有奇数个 1，则必定一者含奇数个1，一者含偶数个。</p><p>证明：若两个都为奇数，1.则奇减奇等于偶（重叠个数为奇个）2.奇减偶先为奇（重叠个数为偶数个），奇加奇等于偶</p><p>​           若两个都为偶数，则可同上证明</p><p>​           一奇一偶，1.奇减奇等于偶，偶减奇等于奇，奇加偶等于奇2.奇减偶等于奇，偶减偶等于偶，偶加奇等于奇</p><p>所以我们采取线段树来维护区间含奇数个1和含偶数个1的个数，对于区间l,r，则用上述中所介绍的calc函数，来calc(r)-calc(l-1)得到奇数个1个数以及r-l+1-（calc(r)-calc(l-1)）得到偶数个1个数</p><p>每次输入一个区间加进去统计一个区间，然后输出总的相乘即可。p.s.线段树很好的解决了区间相交的问题，在以及统计过的区间标记vis[now]=1;</p><p>上代码：</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define maxn 100005</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll num[maxn&lt;&lt;<span class="number">4</span>][<span class="number">2</span>];</span><br><span class="line">int lc[maxn&lt;&lt;<span class="number">4</span>],rc[maxn&lt;&lt;<span class="number">4</span>],rt=<span class="number">0</span>,np=<span class="number">0</span>;</span><br><span class="line">int n;</span><br><span class="line">bool vis[maxn&lt;&lt;<span class="number">4</span>];</span><br><span class="line">void upload(int now)&#123;</span><br><span class="line">    num[now][<span class="number">0</span>]=num[lc[now]][<span class="number">0</span>]+num[rc[now]][<span class="number">0</span>];</span><br><span class="line">    num[now][<span class="number">1</span>]=num[lc[now]][<span class="number">1</span>]+num[rc[now]][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">ll calc(ll x)</span><br><span class="line">&#123;</span><br><span class="line">    ll t=x,tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t&amp;<span class="number">1</span>)tot++;</span><br><span class="line">        t<span class="meta">&gt;&gt;=</span><span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (x<span class="meta">&gt;&gt;</span><span class="number">1</span>)+((x&amp;<span class="number">1</span>) <span class="params">||</span> (tot&amp;<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">void update(int &amp;now,ll l,ll r,ll x,ll y)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!now) now=++np;</span><br><span class="line">    <span class="keyword">if</span>(vis[now]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=x&amp;&amp;r&lt;=y)&#123;</span><br><span class="line">        num[now][<span class="number">1</span>]=calc(r)-calc(l-<span class="number">1</span>);</span><br><span class="line">        num[now][<span class="number">0</span>]=r-l+<span class="number">1</span>-num[now][<span class="number">1</span>];</span><br><span class="line">        vis[now]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll m=(l+r)<span class="meta">&gt;&gt;</span><span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(y&lt;=m)update(lc[now],l,m,x,y);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;m)update(rc[now],m+<span class="number">1</span>,r,x,y);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        update(lc[now],l,m,x,y);</span><br><span class="line">        update(rc[now],m+<span class="number">1</span>,r,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    upload(now);</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    scanf(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    ll L,R,mx=<span class="number">1</span>ll&lt;&lt;<span class="number">32</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(<span class="string">"%lld%lld"</span>,&amp;L,&amp;R);</span><br><span class="line">        update(rt,<span class="number">1</span>,mx,L,R);</span><br><span class="line">        printf(<span class="string">"%lld\n"</span>,num[<span class="number">1</span>][<span class="number">0</span>]*num[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    init();    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二进制 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>祎隋</title>
      <link href="/2018/10/16/7/"/>
      <url>/2018/10/16/7/</url>
      
        <content type="html"><![CDATA[<font size="6" color="pink">愿你像个孩子，愿你心生双翼</font><p>《祎隋》</p><p>青涩</p><p>带着年少初识的忐忑</p><p>我们相遇了</p><p>传奇</p><p>三年来我们所追寻的词字</p><p>一段故事 从这里轻启</p><p>回忆</p><p>忘不却从前往事</p><p>追不上白驹过隙</p><p>再聚</p><p>仿佛多年往复 传奇已铸</p><p>但我们的故事未完待续</p><p>我们的航船才起征途</p><p>愿</p><p>愿相框里的我们永远闪闪发光</p><p>愿你仍是原般模样 </p><p><img src="http://i4.bvimg.com/665863/28b62a261417ef45.jpg" alt="小鞠"></p>]]></content>
      
      
      <categories>
          
          <category> 杂诗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂诗 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CF351B Jeff and Furik</title>
      <link href="/2018/10/16/6/"/>
      <url>/2018/10/16/6/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给一个1~n的排列p[i]，Jeff先手可以交换任意两个相邻元素，而Furik会有0.5的几率把任意满足p[i] &lt; p[i+1]的p[i]和p[i+1]交换，有0.5的几率把任意满足p[i] &gt; p[i+1]的p[i]和p[i+1]交换，问将整个序列变成升序所需的最小期望步数<br><a id="more"></a></p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行一整数n表示序列长度，之后一个1~n的排列p[i] (1&lt;=n&lt;=3000) </p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>输出把整个序列变成升序所需的最小期望步数 </p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>5<br>3 5 2 4 1</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>13.000000 </p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>考虑E[i]（i为逆序对个数）的最小期望步数，则E[0]=0,E[1]=1;那么每一次Jeff肯定是交换使逆序对减少一个而Furik则有50%减少一个50%增加一个，故$E[i]=1/2<em>(E[i-2]+1)+1/2</em>(E[i-1+1]+1)$;化简得$E[i]=E[i-2]+4$;</p><p>故模拟归并排序求一次逆序对个数便可实现。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define maxn 3005</span></span><br><span class="line">using namespace std;</span><br><span class="line">int n,a[maxn],t[maxn];</span><br><span class="line">int msort(int l,int r)&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    int m=l+r<span class="meta">&gt;&gt;</span><span class="number">1</span>;</span><br><span class="line">    int t1=msort(l,m);</span><br><span class="line">    int t2=msort(m+<span class="number">1</span>,r);</span><br><span class="line">    </span><br><span class="line">    int t3=<span class="number">0</span>;</span><br><span class="line">    int i=l,j=m+<span class="number">1</span>,k=l;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=m&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;a[j])&#123;</span><br><span class="line">            t3+=m-i+<span class="number">1</span>;</span><br><span class="line">            t[k++]=a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            t[k++]=a[i++];<span class="regexp">//</span>本来就应该小于 </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=m) t[k++]=a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r) t[k++]=a[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(int p=l;p&lt;=r;p++) a[p]=t[p];<span class="regexp">//</span>调整</span><br><span class="line">    <span class="keyword">return</span> t1+t2+t3; </span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    scanf(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++) scanf(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    int nd=msort(<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">if</span>(nd&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        printf(<span class="string">"%lf"</span>,(double)(<span class="number">2</span>*nd-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> printf(<span class="string">"%lf"</span>,(double)<span class="number">2</span>*nd);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率期望 </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>卡常数</title>
      <link href="/2018/10/16/5/"/>
      <url>/2018/10/16/5/</url>
      
        <content type="html"><![CDATA[<h1 id="Decription"><a href="#Decription" class="headerlink" title="Decription"></a>Decription</h1><p>（在十进制下）定义 mn(i) 表示把 i 的各位数字从小到大排序得到的数，mx(i) 表示从大到小得到的数。这里的数是允许有前导零的，比如mn(10000)=00001=1 ， mx(132)=321 等。定义 f(i)=mx(i)−mn(i) 。当然，这里 mx(i) 的定义是要在某个整数 k 位十进制数下的。</p><p>卡常数指印度数学家Kaprekar发现的常数 6174 。他发现，任取一个各位数字不全相同的四位数 x，不断地使 x=f(x) ，最终总能得到 6174 。<br><a id="more"></a></p><p>现在Fizzydavid学习了高级的卡常数技巧，他想知道对于五位数的情况。他每次会给你一个带前导零的五位数x，要让你求出操作 x=f(x) 进行 c 次之后的结果。他每次给你的 c 都是一样的。此时 f 定义中的 k=5。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行两个整数 T,c 。T 表示询问次数，c 的含义如题面。</p><p>接下来 T 行每行一个五位数 x ，不足五位会加前导零补到五位。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>对于每个询问输出一行表示答案。不足五位需要补到五位。</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>1≤T≤105,1≤c≤109,0≤x&lt;105 。</p><p>20%的数据保证 c≤10 。</p><p>另外20%的数据保证 T≤10 。</p><p>另外30%的数据保证 c≥105 。</p><p>时间限制： 2s</p><p>空间限制： 512MB</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>woc这道题思路很Nice啊。<br>首先会想到肯定每个数进行一定次数之后会循环(不然就没法做了a)。<br>然后这里应该要想到我们对当前的数求循环的时候，我们事实上已经对所有经过的数求出来<br>了，这样稍微处理一下就可以保证每个数只被访问一次。<br>但这样还是会T a。。。<br>于是探究性质：发现对于一个x进行a+b次操作等于先将x进行a次操作，再进行b次操作，或者反过来，再进一步想到可以倍增预处理(Nice啊).这样就欧克了a(注意倍增不要写错a在刷状态的时候QAQ)</p><h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4><p>1.以后遇到这种性质都可以考虑倍增(LCA也有这种性质嘛)<br>2.补充一下姿势（雾<br>%nd 输出的整型宽度至少为n位，右对齐，%5d即宽度至少为5位，位数大于5则输出实际位数<br>%0nd 用得比较多，表示输出的整型宽度至少为n位，不足n位用0填充<br>printf（”%05d”,1）输出：00001<br>printf（”%5d”,1）输出：<em>**</em>1（$*$为空格）</p><h1 id="The-Code"><a href="#The-Code" class="headerlink" title="The Code"></a>The Code</h1><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define maxn 100005</span></span><br><span class="line">using namespace std;</span><br><span class="line">int n,x,c;</span><br><span class="line">int g[<span class="number">100005</span>][<span class="number">31</span>],mx,mn,a[<span class="number">7</span>];</span><br><span class="line">int cmp(int x,int y)&#123;</span><br><span class="line"><span class="keyword">return</span> x&gt;y;</span><br><span class="line">&#125;</span><br><span class="line">int f(int x)&#123;</span><br><span class="line">    memset(a,<span class="number">0</span>,sizeof(a));</span><br><span class="line">    int pos=<span class="number">6</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">    a[--pos]=x%<span class="number">10</span>;x/=<span class="number">10</span>;</span><br><span class="line">&#125; </span><br><span class="line">sort(a+<span class="number">1</span>,a+<span class="number">6</span>);mn=a[<span class="number">1</span>]*<span class="number">10000</span>+a[<span class="number">2</span>]*<span class="number">1000</span>+a[<span class="number">3</span>]*<span class="number">100</span>+a[<span class="number">4</span>]*<span class="number">10</span>+a[<span class="number">5</span>];</span><br><span class="line">sort(a+<span class="number">1</span>,a+<span class="number">6</span>,cmp);mx=a[<span class="number">1</span>]*<span class="number">10000</span>+a[<span class="number">2</span>]*<span class="number">1000</span>+a[<span class="number">3</span>]*<span class="number">100</span>+a[<span class="number">4</span>]*<span class="number">10</span>+a[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">return</span> mx-mn;</span><br><span class="line">&#125;</span><br><span class="line">void pre()&#123;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;=<span class="number">99999</span>;i++) g[i][<span class="number">0</span>]=f(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=<span class="number">30</span>;j++)</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;=<span class="number">99999</span>;i++) g[i][j]=g[g[i][j-<span class="number">1</span>]][j-<span class="number">1</span>]; </span><br><span class="line">&#125;</span><br><span class="line">bool vis[<span class="number">31</span>];</span><br><span class="line">void init()&#123;</span><br><span class="line">scanf(<span class="string">"%d%d"</span>,&amp;n,&amp;c);</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;=<span class="number">30</span>;i++) <span class="keyword">if</span>(c&amp;(<span class="number">1</span>&lt;&lt;i)) vis[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">scanf(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line"><span class="keyword">for</span>(int j=<span class="number">0</span>;j&lt;=<span class="number">30</span>;j++) <span class="keyword">if</span>(vis[j]) x=g[x][j];</span><br><span class="line">printf(<span class="string">"%05d\n"</span>,x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">pre();</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 倍增 </tag>
            
            <tag> 预处理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>树</title>
      <link href="/2018/10/16/4/"/>
      <url>/2018/10/16/4/</url>
      
        <content type="html"><![CDATA[<h1 id="The-Solution"><a href="#The-Solution" class="headerlink" title="The Solution"></a>The Solution</h1><p>emmmmmmmm，这道题题意读错了a，有点难受…很考细节的一道题，同时告诉我们细节题要对拍。<br>首先我们要维护的是最大的剩余空间，但实质上是最大的最近距离，比如区间所剩为5和4，实际上它们的最近距离都为2。在设定友好函数时要注意。<br><a id="more"></a><br>在处理好一般操作之后是特判，主要就是对于两端的处理，因为它们是独立成段的(图中红色部分)，所以只要红色长度大于最近距离即更优。<br><img src="http://i4.bvimg.com/665863/ad91feda1b5ed443.jpg" alt="233"><br>最后要注意标号尽可能小的细节。</p><h1 id="The-Code"><a href="#The-Code" class="headerlink" title="The Code"></a>The Code</h1><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define maxn 200005</span></span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">int l,r;</span><br><span class="line">friend bool operator &lt;(node a,node b)&#123;</span><br><span class="line"><span class="keyword">if</span>((a.r-a.l)/<span class="number">2</span>!=(b.r-b.l)/<span class="number">2</span>)<span class="keyword">return</span> (a.r-a.l)/<span class="number">2</span>&gt;(b.r-b.l)/<span class="number">2</span>;</span><br><span class="line">  /<span class="regexp">/排得是这个最近距离aQAQ 并且不能将2免去，因为奇偶 </span></span><br><span class="line"><span class="regexp">else return a.l&lt;b.l;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">set&lt;node&gt;s;</span></span><br><span class="line"><span class="regexp">set&lt;node&gt;::iterator it;</span></span><br><span class="line"><span class="regexp">int n,m,x,y;</span></span><br><span class="line"><span class="regexp">map&lt;int,int&gt;mp;</span></span><br><span class="line"><span class="regexp">int pre[maxn],next[maxn],st[maxn],rk[maxn];</span></span><br><span class="line"><span class="regexp">int np=0; </span></span><br><span class="line"><span class="regexp">void init()&#123;</span></span><br><span class="line"><span class="regexp">scanf("%d%d",&amp;n,&amp;m);</span></span><br><span class="line"><span class="regexp">s.insert((node)&#123;0,n+1&#125;);</span></span><br><span class="line"><span class="regexp">pre[0]=0;next[0]=n+1;pre[n+1]=0;next[n+1]=n+1;</span></span><br><span class="line"><span class="regexp">for(int i=1;i&lt;=m;i++)&#123;</span></span><br><span class="line"><span class="regexp">scanf("%d%d",&amp;x,&amp;y);</span></span><br><span class="line"><span class="regexp">/</span>*<span class="keyword">if</span>(x==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(t.l==<span class="number">0</span>&amp;&amp;t.r==n+<span class="number">1</span>)&#123;</span><br><span class="line">st[np]=<span class="number">1</span>;</span><br><span class="line">rk[<span class="number">1</span>]=np;</span><br><span class="line"><span class="keyword">next</span>[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">next</span>[<span class="number">1</span>]=n+<span class="number">1</span>;</span><br><span class="line">pre[n+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">s.erase((node)&#123;<span class="number">0</span>,n+<span class="number">1</span>&#125;);</span><br><span class="line">s.insert((node)&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);s.insert((node)&#123;<span class="number">1</span>,n+<span class="number">1</span>&#125;);</span><br><span class="line">printf(<span class="string">"1\n"</span>);continue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t.l==<span class="number">1</span>&amp;&amp;t.r==n+<span class="number">1</span>)&#123;</span><br><span class="line">st[np]=n;</span><br><span class="line">rk[n]=np;</span><br><span class="line">pre[n]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">next</span>[n]=n+<span class="number">1</span>;</span><br><span class="line">pre[n+<span class="number">1</span>]=n;</span><br><span class="line"><span class="keyword">next</span>[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">s.erase((node)&#123;<span class="number">1</span>,n+<span class="number">1</span>&#125;);</span><br><span class="line">s.insert((node)&#123;<span class="number">1</span>,n&#125;);s.insert((node)&#123;n,n+<span class="number">1</span>&#125;);</span><br><span class="line">printf(<span class="string">"%d\n"</span>,n);continue;</span><br><span class="line">&#125;*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">if(x==1)&#123;</span></span><br><span class="line"><span class="regexp">mp[y]=++np;</span></span><br><span class="line"><span class="regexp">it=s.begin();</span></span><br><span class="line"><span class="regexp">node t=*it;</span></span><br><span class="line"><span class="regexp">int len=(t.r-t.l)/</span><span class="number">2</span>;</span><br><span class="line">bool ok1=<span class="literal">false</span>,ok2=<span class="literal">false</span>;</span><br><span class="line">int len1=<span class="number">0</span>,len2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!rk[<span class="number">1</span>]) len1=<span class="keyword">next</span>[<span class="number">0</span>]-<span class="number">1</span>;<span class="keyword">if</span>(!rk[n]) len2=n-pre[n+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(len2&gt;len1) ok2=<span class="literal">true</span>;<span class="keyword">else</span> ok1=<span class="literal">true</span>;<span class="regexp">//</span>标号 </span><br><span class="line"><span class="keyword">if</span>(!rk[<span class="number">1</span>]&amp;&amp;ok1)&#123;<span class="regexp">//</span>要考虑两端点的问题</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">next</span>[<span class="number">0</span>]-<span class="number">1</span>&gt;=len)&#123;<span class="regexp">//</span>标号优先 </span><br><span class="line">st[np]=<span class="number">1</span>;</span><br><span class="line">    rk[<span class="number">1</span>]=np;</span><br><span class="line">    <span class="keyword">next</span>[<span class="number">1</span>]=<span class="keyword">next</span>[<span class="number">0</span>];pre[<span class="keyword">next</span>[<span class="number">0</span>]]=<span class="number">1</span>;<span class="keyword">next</span>[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    s.erase((node)&#123;<span class="number">0</span>,<span class="keyword">next</span>[<span class="number">1</span>]&#125;);</span><br><span class="line">    s.insert((node)&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    s.insert((node)&#123;<span class="number">1</span>,<span class="keyword">next</span>[<span class="number">1</span>]&#125;);</span><br><span class="line">    printf(<span class="string">"1\n"</span>);continue;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!rk[n]&amp;&amp;ok2)&#123;</span><br><span class="line"><span class="keyword">if</span>(n-pre[n+<span class="number">1</span>]&gt;len)&#123;</span><br><span class="line">st[np]=n;</span><br><span class="line">    rk[n]=np;</span><br><span class="line">    pre[n]=pre[n+<span class="number">1</span>];<span class="keyword">next</span>[pre[n+<span class="number">1</span>]]=n;pre[n+<span class="number">1</span>]=n;</span><br><span class="line">    s.erase((node)&#123;pre[n],n+<span class="number">1</span>&#125;);</span><br><span class="line">    s.insert((node)&#123;n,n+<span class="number">1</span>&#125;);</span><br><span class="line">    s.insert((node)&#123;pre[n],n&#125;);</span><br><span class="line">    printf(<span class="string">"%d\n"</span>,n);continue;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">int position=t.l+len;rk[position]=np;st[np]=position;</span><br><span class="line">    pre[position]=t.l;<span class="keyword">next</span>[position]=t.r;pre[t.r]=position;</span><br><span class="line">  <span class="keyword">next</span>[t.l]=position;</span><br><span class="line">printf(<span class="string">"%d\n"</span>,position);</span><br><span class="line">s.erase((node)&#123;pre[position],<span class="keyword">next</span>[position]&#125;); </span><br><span class="line">s.insert((node)&#123;pre[position],position&#125;);</span><br><span class="line">    s.insert((node)&#123;position,<span class="keyword">next</span>[position]&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">int t=st[mp[y]];</span><br><span class="line">s.erase((node)&#123;pre[t],t&#125;);</span><br><span class="line">s.erase((node)&#123;t,<span class="keyword">next</span>[t]&#125;);</span><br><span class="line">s.insert((node)&#123;pre[t],<span class="keyword">next</span>[t]&#125;);</span><br><span class="line">rk[t]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">next</span>[pre[t]]=<span class="keyword">next</span>[t];</span><br><span class="line">pre[<span class="keyword">next</span>[t]]=pre[t];</span><br><span class="line">pre[t]=<span class="keyword">next</span>[t]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> set </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>减肥计划</title>
      <link href="/2018/10/15/3/"/>
      <url>/2018/10/15/3/</url>
      
        <content type="html"><![CDATA[<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>哇，这道题还是太急了，探究出个性质就直接溜了。<br>首先当$\sum{a_i}$一定时，$\sum{b_i}$越大肯定越优，那么可以dp[i]表示$\sum{a_i}$为i时最大的$\sum{b_i}$之值。<br>由于a的和为$n \ast max({a_i})$，所以总的复杂度会是$n^2 \ast max({a_i})$。显然会超时。<br><a id="more"></a><br>所以我们来探求性质，发现当答案为$\frac{\sum{a_i}}{\sum{b_i}}$，若此时有$\frac{a_i}{b_i}$大于它时，那么加入一定会增大，反之加入小于的会减小，所以我们对于一个答案，不断删去小于它的$\frac{a_i}{b_i}$，直到$\sum{a_i}$&lt;m后停下来，那么过程中不会减小，此时再加入大于的即可，所以最多只用dp到$max({a_i})+m$，因此时间复杂度也降为$n \ast (m+max({a_i}))$ ，即可通过此题。</p><p>上代码：</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cmath&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cctype&gt;</span></span><br><span class="line"><span class="comment">#include&lt;set&gt;</span></span><br><span class="line"><span class="comment">#include&lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include&lt;map&gt;</span></span><br><span class="line"><span class="comment">#include&lt;queue&gt;</span></span><br><span class="line"><span class="comment">#define maxn 10000005</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int n,m;</span><br><span class="line">ll dp[maxn&lt;&lt;<span class="number">1</span>],a[maxn],b[maxn];</span><br><span class="line">ll gcd(ll x,ll y)&#123;</span><br><span class="line"><span class="keyword">if</span>(y==<span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> gcd(y,x%y);</span><br><span class="line">&#125;</span><br><span class="line">ll maxx=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">void init()&#123;</span><br><span class="line">    scanf(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++) scanf(<span class="string">"%d%d"</span>,&amp;a[i],&amp;b[i]),maxx=max(maxx,a[i]),sum+=a[i];</span><br><span class="line"><span class="keyword">if</span>(sum&lt;m)&#123;printf(<span class="string">"-1"</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=m+maxx;i++) dp[i]=-<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(int j=maxx+m;j&gt;=a[i];j--) dp[j]=max(dp[j],dp[j-a[i]]+b[i]);</span><br><span class="line"></span><br><span class="line">ll fz=-<span class="number">1</span>,fm=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(int i=m;i&lt;=maxx+m;i++) <span class="keyword">if</span>(fz*i&lt;dp[i]*fm) fz=dp[i],fm=i;</span><br><span class="line">ll g=gcd(fz,fm);</span><br><span class="line">fz/=g;fm/=g;</span><br><span class="line">printf(<span class="string">"%d/%d"</span>,fz,fm); </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> dp </tag>
            
            <tag> 正睿 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>正睿普转提9.16</title>
      <link href="/2018/10/15/14/"/>
      <url>/2018/10/15/14/</url>
      
        <content type="html"><![CDATA[<h2 id="代码记录…"><a href="#代码记录…" class="headerlink" title="代码记录…"></a>代码记录…</h2><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define maxn 100005</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int n,fa[maxn],ch[maxn][<span class="number">2</span>],x;</span><br><span class="line">ll st[maxn],a[maxn];</span><br><span class="line">int top=<span class="number">0</span>;</span><br><span class="line">void dfs(int i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ch[i][<span class="number">0</span>]) dfs(ch[i][<span class="number">0</span>]);</span><br><span class="line">    st[++top]=a[i];</span><br><span class="line">    <span class="keyword">if</span>(ch[i][<span class="number">1</span>]) dfs(ch[i][<span class="number">1</span>]);</span><br><span class="line">&#125; </span><br><span class="line">ll q[maxn];</span><br><span class="line">int rear=<span class="number">0</span>;</span><br><span class="line">void run(ll x)&#123;</span><br><span class="line">    /*<span class="keyword">if</span>(x&gt;=q[rear])&#123;</span><br><span class="line">        q[++rear]=x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    int l=<span class="number">1</span>,r=rear,mid;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        mid=(l+r)<span class="meta">&gt;&gt;</span><span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(q[mid-<span class="number">1</span>]&lt;=x&amp;&amp;x&lt;q[mid])&#123;q[mid]=x;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;q[mid-<span class="number">1</span>]) r=mid-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>; </span><br><span class="line">    &#125;*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">    int t=upper_bound(q+1,q+rear+1,x)-q;</span></span><br><span class="line"><span class="regexp">    if(t==rear+1) q[++rear]=x;</span></span><br><span class="line"><span class="regexp">    else q[t]=x;/</span><span class="regexp">/将刚好大于它的代替，这里是运用了贪心思想a</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">void init()&#123;</span></span><br><span class="line"><span class="regexp">    scanf("%d",&amp;n);</span></span><br><span class="line"><span class="regexp">    for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]);</span></span><br><span class="line"><span class="regexp">    for(int i=2;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="regexp">        scanf("%d%d",&amp;fa[i],&amp;x);</span></span><br><span class="line"><span class="regexp">        ch[fa[i]][x]=i;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    dfs(1);</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">    for(ll i=1;i&lt;=top;i++) st[i]=st[i]-i;</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">    q[0]=-10000000000;</span></span><br><span class="line"><span class="regexp">    for(int i=1;i&lt;=top;i++) run(st[i]);</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">    int ans=n-rear;</span></span><br><span class="line"><span class="regexp">    printf("%d",ans);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">int main()&#123;</span></span><br><span class="line"><span class="regexp">    init();</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">    return 0;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define maxn 500005</span></span><br><span class="line">using namespace std;</span><br><span class="line">int n,a[maxn],np=<span class="number">0</span>,rt=<span class="number">0</span>;</span><br><span class="line">int gcd(int x,int y)&#123;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(y,x%y);</span><br><span class="line">&#125;</span><br><span class="line">int minv[maxn][<span class="number">20</span>],gcdd[maxn][<span class="number">20</span>],logg[maxn],w[<span class="number">25</span>];</span><br><span class="line">void ready()&#123;</span><br><span class="line">    w[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    logg[<span class="number">0</span>]=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;i++) w[i]=w[i-<span class="number">1</span>]*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=maxn-<span class="number">5</span>;i++) logg[i]=logg[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        minv[i][<span class="number">0</span>]=gcdd[i][<span class="number">0</span>]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=logg[n];i++)/<span class="regexp">/加个1保个险 </span></span><br><span class="line"><span class="regexp">    for(int j=1;j&lt;=n;j++)</span></span><br><span class="line"><span class="regexp">    if(j+w[i]-1&lt;=n)&#123;</span></span><br><span class="line"><span class="regexp">        minv[j][i]=min(minv[j][i-1],minv[j+w[i-1]][i-1]);/</span><span class="regexp">/本来是j+(1&lt;&lt;(i-1))-1+1</span></span><br><span class="line"><span class="regexp">        gcdd[j][i]=gcd(gcdd[j][i-1],gcdd[j+w[i-1]][i-1]);</span></span><br><span class="line"><span class="regexp">    &#125; </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">int cd1(int i,int j)&#123;</span></span><br><span class="line"><span class="regexp">    int len=j-i+1;</span></span><br><span class="line"><span class="regexp">    int t=logg[len];</span></span><br><span class="line"><span class="regexp">    return min(minv[i][t],minv[j-w[t]+1][t]);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">int cd2(int i,int j)&#123;</span></span><br><span class="line"><span class="regexp">    int len=j-i+1;</span></span><br><span class="line"><span class="regexp">    int t=logg[len];</span></span><br><span class="line"><span class="regexp">    return gcd(gcdd[i][t],gcdd[j-w[t]+1][t]);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">int st[maxn],top=0,yb[maxn],topp=0;</span></span><br><span class="line"><span class="regexp">bool check(int mid)&#123;</span></span><br><span class="line"><span class="regexp">    topp=0;</span></span><br><span class="line"><span class="regexp">    bool ok=false;</span></span><br><span class="line"><span class="regexp">    for(int i=1;i&lt;=n-mid+1;i++)&#123;</span></span><br><span class="line"><span class="regexp">        int j=i+mid-1;</span></span><br><span class="line"><span class="regexp">        if(cd1(i,j)==cd2(i,j))&#123;</span></span><br><span class="line"><span class="regexp">            ok=true;</span></span><br><span class="line"><span class="regexp">            yb[++topp]=i;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    if(ok)&#123;</span></span><br><span class="line"><span class="regexp">        top=0;</span></span><br><span class="line"><span class="regexp">        for(int i=1;i&lt;=topp;i++) st[++top]=yb[i];</span></span><br><span class="line"><span class="regexp">        return true;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    return false;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">void run()&#123;</span></span><br><span class="line"><span class="regexp">    int A=1,B=n,mid,ans;</span></span><br><span class="line"><span class="regexp">    while(A&lt;=B)&#123;</span></span><br><span class="line"><span class="regexp">        mid=A+B&gt;&gt;1;</span></span><br><span class="line"><span class="regexp">        if(check(mid))</span></span><br><span class="line"><span class="regexp">        ans=mid,A=mid+1;</span></span><br><span class="line"><span class="regexp">        else B=mid-1;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    printf("%d %d\n",top,ans-1);/</span><span class="regexp">/L-R</span></span><br><span class="line"><span class="regexp">    for(int i=1;i&lt;=top;i++) printf("%d ",st[i]);</span></span><br><span class="line"><span class="regexp">&#125; </span></span><br><span class="line"><span class="regexp">void init()&#123;</span></span><br><span class="line"><span class="regexp">    scanf("%d",&amp;n);</span></span><br><span class="line"><span class="regexp">    for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]);</span></span><br><span class="line"><span class="regexp">    ready(); </span></span><br><span class="line"><span class="regexp">    run(); </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">int main()&#123;</span></span><br><span class="line"><span class="regexp">    init();</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">    return 0;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define maxn 55</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll mod=<span class="number">1</span>e9+<span class="number">7</span>;</span><br><span class="line">ll c[maxn][maxn],dp[maxn][maxn];</span><br><span class="line">int p[maxn],n;</span><br><span class="line">void ready()&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;=<span class="number">50</span>;i++)&#123;</span><br><span class="line">        c[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">        c[i][j]=(c[i-<span class="number">1</span>][j-<span class="number">1</span>]+c[i-<span class="number">1</span>][j])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll dfs(int len,int now)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[len][now]!=-<span class="number">1</span>) <span class="keyword">return</span> dp[len][now];</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">1</span>) <span class="keyword">return</span> dp[len][now]=<span class="number">1</span>;</span><br><span class="line">    ll ans=<span class="number">0</span>;int j,k,pos=<span class="number">0</span>,t[maxn];<span class="regexp">//pos</span>和t只有内定了给，不然要重 函数递归时会改变 </span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(p[i]&gt;=now&amp;&amp;p[i]&lt;now+len) t[++pos]=p[i];<span class="regexp">//pos</span>==len</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;pos;i++)&#123;</span><br><span class="line">        swap(t[i],t[i+<span class="number">1</span>]);<span class="regexp">//</span>枚举交换的位置</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=i;j++)/<span class="regexp">/判断是否满足</span></span><br><span class="line"><span class="regexp">        if(t[j]&gt;=now+i) break;/</span><span class="regexp">/最多为now+i-1;</span></span><br><span class="line"><span class="regexp">        for(k=i+1;k&lt;=pos;k++)</span></span><br><span class="line"><span class="regexp">        if(t[k]&lt;now+i)  break;/</span><span class="regexp">/最小为now+i; </span></span><br><span class="line"><span class="regexp">        if(j&gt;i&amp;&amp;k&gt;pos)&#123;</span></span><br><span class="line"><span class="regexp">            ll t1=dfs(i,now);</span></span><br><span class="line"><span class="regexp">            ll t2=dfs(pos-i,now+i);</span></span><br><span class="line"><span class="regexp">            ans=(ans+t1*t2%mod*c[pos-2][i-1]%mod)%mod;/</span><span class="regexp">/第一个:now~now+i-1 第二个now+i~now+len-1; </span></span><br><span class="line"><span class="regexp">                                    /</span><span class="regexp">/在这之前进行n-2次交换,前i-1次选择前面来处理前面的i个 </span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        swap(t[i],t[i+1]);</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    return dp[len][now]=ans; </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">void init()&#123;</span></span><br><span class="line"><span class="regexp">    scanf("%d",&amp;n);</span></span><br><span class="line"><span class="regexp">    for(int i=1;i&lt;=n;i++) scanf("%d",&amp;p[i]);</span></span><br><span class="line"><span class="regexp">    memset(dp,-1,sizeof(dp));</span></span><br><span class="line"><span class="regexp">    dfs(n,0);</span></span><br><span class="line"><span class="regexp">    if(dp[n][0]==-1) printf("%d",0);</span></span><br><span class="line"><span class="regexp">    else printf("%lld",dp[n][0]);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">int main()&#123;</span></span><br><span class="line"><span class="regexp">    ready();</span></span><br><span class="line"><span class="regexp">    init();</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">    return 0;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define maxn 305</span></span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,k;</span><br><span class="line">double a[maxn],b[maxn*maxn];<span class="regexp">//b</span><span class="symbol">:</span>(k-x,m-x)/(k,m) 而x最多为n^<span class="number">2</span></span><br><span class="line">void ready()&#123;</span><br><span class="line">    a[<span class="number">0</span>]=<span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++) a[i]=a[i-<span class="number">1</span>]*(n-i+<span class="number">1</span>)*<span class="number">1.0</span>/i;</span><br><span class="line">    b[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n*n;i++) b[i]=b[i-<span class="number">1</span>]*(k-i+<span class="number">1</span>)*<span class="number">1.0</span>/(m-i+<span class="number">1</span>); </span><br><span class="line">&#125; </span><br><span class="line">void outt()&#123;</span><br><span class="line">    printf(<span class="string">"1"</span>);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=<span class="number">99</span>;i++) printf(<span class="string">"0"</span>);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    ready();</span><br><span class="line">    double ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(int j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">        int x=(i+j)*n-i*j;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;k) <span class="keyword">break</span>;<span class="regexp">//</span>再加只会更多 </span><br><span class="line">        ans+=a[i]*a[j]*b[x];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(ans&gt;<span class="number">1</span>e99) outt();</span><br><span class="line">    <span class="keyword">else</span> printf(<span class="string">"%lf"</span>,ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率期望 </tag>
            
            <tag> 数学 </tag>
            
            <tag> dp </tag>
            
            <tag> LIS </tag>
            
            <tag> ST表 </tag>
            
            <tag> 二分答案 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最小瓶颈生成树</title>
      <link href="/2018/10/15/2/"/>
      <url>/2018/10/15/2/</url>
      
        <content type="html"><![CDATA[<h1 id="所谓最小瓶颈生成树…-就是使得生成树树上最大边权值最小。"><a href="#所谓最小瓶颈生成树…-就是使得生成树树上最大边权值最小。" class="headerlink" title="所谓最小瓶颈生成树….就是使得生成树树上最大边权值最小。"></a>所谓最小瓶颈生成树….就是使得生成树树上最大边权值最小。</h1><p>这里主要介绍一种期望O（M）（线性）的求法，其实主要就是二分，具体思路如下：</p><p>类比找第k大值的方法，首先随机一个边权w。</p><p>然后将不超过这个边权的边加入，遍历这张图。</p><p>如果图连通，那么瓶颈不超过w，于是只需考虑边权不超过w的边。</p><a id="more"></a><p>否则将这些连通点缩起来，考虑边权大于w的边。</p><p>每次将问题的规模缩小至一半。</p><p>期望时间复杂度O(m)。</p><h2 id="相关例题有两道："><a href="#相关例题有两道：" class="headerlink" title="相关例题有两道："></a>相关例题有两道：</h2><p>A.Hangar Hurdles (CERC 16)</p><p>有一个n*n的网格图，上面有些格子可行，有些格子是障碍。 有Q个询问，想把一个正方形箱子从(r1,c1)推到(r2,c2)，问箱子最大的大小。（起点终点是正方形箱子的中点） N&lt;=1000 Q&lt;=300000</p><p>B.洪蛤吨有一个宽度为L的管道，我们可以视其为一条y=L的直线与X轴所夹的部分。</p><p>（所以这根管道的长度可以视为正无穷）</p><p>这个管道中有个N个障碍点，第i个障碍点的坐标为(Xi,Yi)。</p><p>已知有一个球体，能在不碰到障碍点的前提下，从管道的最左端走到最右端。（即从管道内横坐标负无穷的地方走到横坐标正无穷的地方）。</p><p>求这个球体的直径最大是多少。为了避免精度误差，请输出答案保留三位小数的结果。</p><h3 id="两题有异曲同工之妙a…（-滑稽，思路差不多…）都可以用最小瓶颈树实现复杂度最小"><a href="#两题有异曲同工之妙a…（-滑稽，思路差不多…）都可以用最小瓶颈树实现复杂度最小" class="headerlink" title="两题有异曲同工之妙a…（/滑稽，思路差不多…）都可以用最小瓶颈树实现复杂度最小"></a>两题有异曲同工之妙a…（/滑稽，思路差不多…）都可以用最小瓶颈树实现复杂度最小</h3><p>下面上一下t2的代码：（没有用最小瓶颈树优化，逃）</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cmath&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cctype&gt;</span></span><br><span class="line"><span class="comment">#include&lt;set&gt;</span></span><br><span class="line"><span class="comment">#include&lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include&lt;map&gt;</span></span><br><span class="line"><span class="comment">#include&lt;queue&gt;</span></span><br><span class="line"><span class="comment">#define maxn 505</span></span><br><span class="line">using namespace std;</span><br><span class="line">struct eage&#123;</span><br><span class="line">    int u,v;</span><br><span class="line">    double dist;</span><br><span class="line">&#125;e[maxn*maxn/<span class="number">2</span>+maxn*<span class="number">2</span>];</span><br><span class="line">bool cmp(eage a,eage b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a.dist&lt;b.dist;</span><br><span class="line">&#125;</span><br><span class="line">double dis(int x1,int y1,int x2,int y2)&#123;</span><br><span class="line">    <span class="keyword">return</span> sqrt(<span class="number">1.0</span>*(x1-x2)*(x1-x2)+<span class="number">1.0</span>*(y1-y2)*(y1-y2)); </span><br><span class="line">&#125;</span><br><span class="line">int fa[maxn];</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">    int root=find(fa[x]);</span><br><span class="line">    fa[x]=root;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">void link(int x,int y)&#123;</span><br><span class="line">    int fx=find(x),fy=find(y);</span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)&#123;</span><br><span class="line">        fa[fx]=fy;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">bool check(int x,int y)&#123;</span><br><span class="line">    int fx=find(x),fy=find(y);</span><br><span class="line">    <span class="keyword">if</span>(fx!=fy) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">int l,n;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int x,y;</span><br><span class="line">&#125;nd[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">    int pos=<span class="number">0</span>;</span><br><span class="line">    scanf(<span class="string">"%d%d"</span>,&amp;n,&amp;l);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n+<span class="number">2</span>;i++) fa[i]=i;<span class="regexp">//n</span>+<span class="number">1</span>是上，n+<span class="number">2</span>是下 </span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(<span class="string">"%d%d"</span>,&amp;nd[i].x,&amp;nd[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        e[++pos]=(eage)&#123;i,n+<span class="number">1</span>,l-nd[i].y&#125;;</span><br><span class="line">        e[++pos]=(eage)&#123;i,n+<span class="number">2</span>,nd[i].y&#125;;</span><br><span class="line">    <span class="keyword">for</span>(int j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">        e[++pos]=(eage)&#123;i,j,dis(nd[i].x,nd[i].y,nd[j].x,nd[j].y)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int cnt=<span class="number">0</span>;</span><br><span class="line">    sort(e+<span class="number">1</span>,e+pos+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=pos;i++)&#123;</span><br><span class="line">        int u=e[i].u,v=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(check(u,v)) continue;</span><br><span class="line">        link(u,v);</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span>(find(n+<span class="number">1</span>)==find(n+<span class="number">2</span>))&#123;<span class="regexp">//</span>只要上底和下底连接了就行 这样才能保证极大值可以通过，如果后面更大，那这里是过不了的 </span><br><span class="line">            printf(<span class="string">"%.3f"</span>,e[i].dist);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小瓶颈生成树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>UpdateAfterEvent</title>
      <link href="/2018/10/15/1/"/>
      <url>/2018/10/15/1/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>​       小松鼠打了10个小时的游戏，一脸满足。却发现周围再次围满了游客，逃！</p><p>　　她发现整个西湖内的松鼠都以相同的速度在树之间跳跃。每跳跃一次花费一个单位的时间。我们可以把西湖抽象为一张n个点的无向图，初始时每个点上都有若干只松鼠，它们每单位时间都可以沿着一条无向边进行跳跃。</p><a id="more"></a><p>　　对于一只当前在点i的松鼠，它在接下来的一个单位时间内等概率向相邻的点跳跃。更具体地讲，我们称与点i通过一条无向边直接相连的点为与i相邻的点，假设这样的点有p个，那么对于每一个与i相邻的点，在下一时刻都有1/p的概率跳到它。</p><p>　　超萌小松鼠已知初始时刻（0时刻）每棵树上的松鼠分布情况，她想知道在T时刻，在同一棵树上的松鼠对数的期望。关于“松鼠对数”的解释：假设有4只松鼠在同一棵树上，那么我们称有6对在同一棵树上的松鼠。为了避免精度误差，我们将答案模10^9 + 7输出。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>​          第一行三个数n，T。意义如题面中所述。接下来一行n个数，第i个数ai表示第i个点初始时刻有ai只松鼠。接下来n行，每行n个数，第i行第j个数如果为1表示点i与点j间有无向边相连，为0则表示没有。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>​            输出一行一个数，表示T时刻在同一棵树上的松鼠对数的期望在模10^9 +7意义下的答案。</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>这道题考察了许多知识点，考察综合能力。</p><p>首先，题目总体是考察概率期望，但切忌陷入思路死角，去求每棵树上的最终期望松鼠对数。实际上，我们对于每只松鼠，去求它到某点的概率p,那么每两只松鼠在某点的期望便是p1<em>p2</em>1（还有很多可转化为概率来做的期望题）由于要除法取模，要预先递推求出逆元，复习一下公式：inv[1]=1;inv[i]=(mod-mod/i)*inv[mod%i]%mod. </p><p>那么对于松鼠到某点的概率求取，我们先O(N^2)求出最开始互相连点之间的概率，然后每一时刻，枚举中间点，进行概率传递，由于t比较大，可以用矩阵快速幂思想来将其优化到log2n级别。</p><p>最后，由于我们计算期望是O（n^3）的，无法过n&lt;=1000的点，发现如下式子：</p><p>设p(i,j)为i到j点的概率。假设计算终点在1，则ans=p(1,1)<em>p(2,1)+p(1,1)</em>p(3,1)<em>…..+p(1,1)</em>p(n,1)+p(2,1)<em>p(3,1)+p(2,1)</em>p(4,1)+…….发现可以转化为p(1,1)<em>(p(2,1)+p(3,1)+p(4,1)+….+p(n,1))+p(2,1)</em>(p(3,1)+p(4,1)+…..+p(n,1)).由此发现是可以前缀和优化的，由此只用枚举一点和终点，从而变成O(N^2).当然可以每个统计一次，然后最后除以2.貌似更方便哈…..</p><h1 id="The-Code"><a href="#The-Code" class="headerlink" title="The Code"></a>The Code</h1><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define maxn 1005</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll mod=<span class="number">1</span>e9+<span class="number">7</span>;</span><br><span class="line">struct matrix&#123;</span><br><span class="line">    ll a[maxn][maxn];</span><br><span class="line">&#125;nd,ans;</span><br><span class="line">int n,t,e[maxn][maxn];</span><br><span class="line">matrix operator *(matrix &amp;x,matrix &amp;y)&#123;</span><br><span class="line">    matrix c;</span><br><span class="line">    memset(c.a,<span class="number">0</span>,sizeof(c.a));</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    <span class="keyword">for</span>(int k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        c.a[i][j]=(c.a[i][j]+(x.a[i][k]*y.a[k][j])%mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">void pow(int t)&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++) ans.a[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t&amp;<span class="number">1</span>) ans=ans*nd;<span class="regexp">//</span>最后为<span class="number">1</span> </span><br><span class="line">        nd=nd*nd;</span><br><span class="line">        t/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll p[maxn][maxn],inv[maxn],v[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">    scanf(<span class="string">"%d%d"</span>,&amp;n,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++) scanf(<span class="string">"%lld"</span>,&amp;v[i]);</span><br><span class="line">    inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">2</span>;i&lt;=<span class="number">1000</span>;i++) inv[i]=(mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=n;j++) scanf(<span class="string">"%d"</span>,&amp;e[i][j]);</span><br><span class="line">    memset(nd.a,<span class="number">0</span>,sizeof(nd.a));</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        int res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=n;j++)  res+=e[i][j];</span><br><span class="line">        <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=n;j++)  nd.a[i][j]=inv[res]*e[i][j];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(t&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        pow(t);</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=n;j++) p[i][j]=ans.a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=n;j++) p[i][j]=nd.a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ll calc=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ll t1=<span class="number">0</span>,t2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            ll tt=(p[j][i]*v[j])%mod;</span><br><span class="line">            t1=(t1+tt)%mod;</span><br><span class="line">            t2=(t2+tt*p[j][i])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        calc=(calc+(t1*t1%mod-t2+mod)%mod*inv[<span class="number">2</span>]%mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"%lld"</span>,calc);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> noip模拟赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率期望 </tag>
            
            <tag> 前缀和优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>祎隋</title>
      <link href="/2018/10/14/kk/"/>
      <url>/2018/10/14/kk/</url>
      
        <content type="html"><![CDATA[<h2 id="祎隋如你，春风十里不及你"><a href="#祎隋如你，春风十里不及你" class="headerlink" title="祎隋如你，春风十里不及你"></a>祎隋如你，春风十里不及你</h2><p>《祎隋》</p><p>无需仰首，我已知晓</p><p>那阳光濡缕，和风轻挠</p><a id="more"></a><p>不用回头，我已知晓</p><p>那鲜艳裙摆 ，恬然一笑</p><p>……</p><p>因你自嘲，为你歌声倾倒</p><font size="5" color="pink" face="微软雅黑">附上小鞠美图一张</font><p><img src="http://i4.bvimg.com/665863/f3aae70b9599b2b0.png" alt="小鞠"></p>]]></content>
      
      
      <categories>
          
          <category> 杂诗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂诗 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>文章分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
  
</search>
