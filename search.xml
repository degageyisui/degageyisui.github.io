<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>noip模拟赛1</title>
      <link href="/2018/10/17/12/"/>
      <url>/2018/10/17/12/</url>
      
        <content type="html"><![CDATA[<h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>每天中午，美丽的重庆一中都会上演一场华丽的千人大竞走。<br>大量人流短时间涌进第二食堂， 食堂班长小 H 表示不淡定了，他必须合<br>理安排饭堂饭菜的价格，来让同学们有愉快的心情就餐。<br>已知第一饭堂饭菜的价格是有 N 位数字的整数，如果一个价格有不小于<br>K（1≤K≤N） 个数位完全相同，那么这个价格就被认为是漂亮的，否则这<br>个价格被认为是不漂亮的。 小 H 想改变其中一个饭菜价格，改变价格中的<br>一位数字需要花费一些钱， 钱数等于改前和改后的数字之差的绝对值。<br>小 H 希望你能把这个价格改地漂亮，求出最小花费，同时给出字典序最<br>小的修改方案。</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>输入文件名为 canteen.in。<br>输入的第一行两个空格隔开的数字 N 和 K(1≤K≤N)。 第二行是一个长<br>度为 N 位的数字， 表示原来的价格。</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>输出文件名为 canteen.out。<br>输出包含两行，第一行一个整数， 表示最小费用。 第二行是字典序最<br>小的方案。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><p>6 5<br>889696</p><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><p>4<br>888688</p><h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><p>对于 30%的数据： N≤10<br>对于 100%的数据： N≤100 000</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>比较水的一道贪心a，只是要注意细节，维护两个东西：最小费用和最小字典序。<br>显然最小费用优先级更大。我们枚举相同的k个数字从0到9，对于每一个确定的st,<br>用i=0~9依次考虑变的数字，注意先执行st+i，再执行st-i以保证字典序最优。<br>然后对于小于st的从后往前改，大于st的从前往后改来保证字典序。</p><h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4><p>（想好细节,think twice,code once）<br>上代码：</p><h2 id="The-Code"><a href="#The-Code" class="headerlink" title="The Code"></a>The Code</h2><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include&lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cmath&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cctype&gt;</span></span><br><span class="line"><span class="comment">#include&lt;vector&gt;</span></span><br><span class="line"><span class="comment">#include&lt;queue&gt;</span></span><br><span class="line"><span class="comment">#include&lt;map&gt;</span></span><br><span class="line"><span class="comment">#include&lt;set&gt; </span></span><br><span class="line"><span class="comment">#define maxn 100005</span></span><br><span class="line">using namespace std;</span><br><span class="line">int n,k;</span><br><span class="line">char s[maxn];</span><br><span class="line">char ss[maxn];</span><br><span class="line">char tt[maxn];</span><br><span class="line">int cnt[<span class="number">10</span>];</span><br><span class="line">int minn=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">int yb[<span class="number">10</span>];</span><br><span class="line">int calc[<span class="number">10</span>];</span><br><span class="line">bool cmp()&#123;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(tt[i]&lt;ss[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(tt[i]&gt;ss[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">scanf(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">scanf(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++) cnt[s[i]-<span class="string">'0'</span>]++,ss[i]=<span class="string">'9'</span>;<span class="regexp">//</span>最大化 </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(int st=<span class="number">0</span>;st&lt;=<span class="number">9</span>;st++)&#123;</span><br><span class="line">int t=k;<span class="regexp">//</span>要变的个数 </span><br><span class="line">int ans=<span class="number">0</span>;<span class="regexp">//</span>要花的钱 </span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt[st]&gt;=t) <span class="keyword">break</span>;</span><br><span class="line">t-=cnt[st];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">int t1=st+i,t2=st-i;</span><br><span class="line"><span class="keyword">if</span>(t1&lt;=<span class="number">9</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt[t1]&gt;=t)&#123;ans+=t*i;<span class="keyword">break</span>;&#125;</span><br><span class="line">t-=cnt[t1];ans+=cnt[t1]*i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t2&gt;=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt[t2]&gt;=t)&#123;ans+=t*i;<span class="keyword">break</span>;&#125;</span><br><span class="line">t-=cnt[t2];ans+=cnt[t2]*i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">minn=min(minn,ans);</span><br><span class="line">    calc[st]=ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(int st=<span class="number">0</span>;st&lt;=<span class="number">9</span>;st++)&#123;</span><br><span class="line"><span class="keyword">if</span>(calc[st]==minn)&#123;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++) tt[i]=s[i];</span><br><span class="line">memset(yb,<span class="number">0</span>,sizeof(yb));</span><br><span class="line">int t=k;<span class="regexp">//</span>要变的个数 </span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt[st]&gt;=t) <span class="keyword">break</span>;</span><br><span class="line">t-=cnt[st];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">int t1=st+i,t2=st-i;</span><br><span class="line"><span class="keyword">if</span>(t1&lt;=<span class="number">9</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt[t1]&gt;=t)&#123;yb[t1]=t;<span class="keyword">break</span>;&#125;</span><br><span class="line">t-=cnt[t1];yb[t1]=cnt[t1];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t2&gt;=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt[t2]&gt;=t)&#123;yb[t2]=t;<span class="keyword">break</span>;&#125;</span><br><span class="line">t-=cnt[t2];yb[t2]=cnt[t2];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(yb[i])&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;st)&#123;</span><br><span class="line"><span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=n;j++) <span class="keyword">if</span>(s[j]==(i+<span class="string">'0'</span>)) <span class="keyword">if</span>(yb[i])tt[j]=st+<span class="string">'0'</span>,yb[i]--; <span class="keyword">else</span>&#123;<span class="keyword">break</span>;&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(int j=n;j&gt;=<span class="number">1</span>;j--) <span class="keyword">if</span>(s[j]==(i+<span class="string">'0'</span>)) <span class="keyword">if</span>(yb[i])tt[j]=st+<span class="string">'0'</span>,yb[i]--; <span class="keyword">else</span>&#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cmp()) <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++) ss[i]=tt[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(<span class="string">"%d\n"</span>,minn);</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++) printf(<span class="string">"%c"</span>,ss[i]);</span><br><span class="line">    /*memset(dp,<span class="number">0x3f</span>,sizeof(dp));</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++) dp[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=min(i,k);j++)</span><br><span class="line">    <span class="keyword">for</span>(int kk=<span class="number">1</span>;kk&lt;=<span class="number">9</span>;kk++)&#123;</span><br><span class="line">    dp[j][kk]=min(dp[j][kk],dp[j-<span class="number">1</span>][kk]+abs(s[i]-<span class="string">'0'</span>-kk)); </span><br><span class="line">    &#125;</span><br><span class="line">    int minn=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++) minn=min(minn,dp[k][i]);</span><br><span class="line">    printf(<span class="string">"%d"</span>,minn);*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">int main()&#123;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/freopen("canteen.in","r",stdin);</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/freopen("canteen.out","w",stdout);</span></span><br><span class="line"><span class="regexp">init();</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">return 0;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p>小 M 新设计了一款战略游戏。<br>游戏的地图包含有 N 个阵地（用 1..N 编号），用 N-1 条战略交通线把它<br>们连接起来， 地图中任意两个阵地都能直接或间接地相互到达。 小 M 为每<br>条交通线设定一个名为“战略重要性”的参数，它是一个正整数，且这个<br>数值越大，说明这条交通线的战略重要性越大。 小 M 还设计了一个阵地间<br>的“战略相关性”的度量标准， 那就是两个阵地间路径上“战略重要性”<br>最小的交通线。<br>小 M 已经完成了游戏大多数模块的代码， 还有一个在线查询模块没有完<br>成，即对于用户查询： k， v，表示查询与阵地 v“战略相关性” 不小于 k 的<br>阵地的数目。<br>由于小 M 还要负责游戏的推广， 所以这个查询模块的代码就交给你了。</p><h2 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h2><p>输入文件名为 strategy.in。<br>第一行输入包含 N 和 Q。 接下来的 N-1 行描述地图中的交通线。 每行<br>包括三个整数 pi,qi 和 ri ( 1≤pi,qi≤N， ri&lt;=1000000000 )，表示阵地 pi 和 qi<br>的战略重要性为 ri 。接下来的 Q 行描述了 Q 次查询。 每行包含两个整数，<br>k 和 v (1≤k≤1,000,000,000, 1≤v≤N )，表示一次查询。</p><h2 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h2><p>输出文件名为 strategy.out。<br>输出 Q 行。在第 i 行输出第 i 次查询的的答案。</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h3><p>4 3<br>1 2 3<br>2 3 2<br>2 4 4<br>1 2<br>4 1<br>3 1</p><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h3><p>3<br>0<br>2</p><h2 id="Hint-1"><a href="#Hint-1" class="headerlink" title="Hint"></a>Hint</h2><p>对于 20%的数据： N,Q≤3 00<br>对于 50%的数据： N,Q≤5 000<br>对于 100%的数据： N,Q≤100 000</p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><p>首先会想到离线处理，再根据单调性，想到用并查集维护，将大于等于k的边所连接的点加入并查集，<br>这样对于每个联通块，其中任意两点都是符合“战略相关性”大于等于k的，所以对于每个询问，答案<br>就是v所在联通块点个数减1即可。</p><p>上代码：</p><h2 id="The-Code-1"><a href="#The-Code-1" class="headerlink" title="The Code"></a>The Code</h2><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">#define maxn 100005</span></span><br><span class="line">struct eage&#123;</span><br><span class="line">int u,v,len;</span><br><span class="line">friend bool operator &lt;(eage a,eage b)&#123;</span><br><span class="line"><span class="keyword">return</span> a.len&gt;b.len;</span><br><span class="line">&#125;</span><br><span class="line">&#125;e[maxn];</span><br><span class="line">int np=<span class="number">0</span>;</span><br><span class="line">int n,q,x,y,z,fa[maxn],sz[maxn];</span><br><span class="line">struct node&#123;</span><br><span class="line">int id,k,v,ans;</span><br><span class="line">friend bool operator&lt;(node a,node b)&#123;</span><br><span class="line"><span class="keyword">return</span> a.k&gt;b.k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;nd[maxn];</span><br><span class="line">bool cmp(node a,node b)&#123;</span><br><span class="line"><span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">&#125;</span><br><span class="line">int find(int i)&#123;</span><br><span class="line"><span class="keyword">if</span>(fa[i]==i) <span class="keyword">return</span> i;</span><br><span class="line">int root=find(fa[i]);</span><br><span class="line">fa[i]=root;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">void link(int x,int y)&#123;</span><br><span class="line">int fx=find(x),fy=find(y);</span><br><span class="line"><span class="keyword">if</span>(fx!=fy)&#123;</span><br><span class="line">fa[fx]=fy;</span><br><span class="line">sz[fy]+=sz[fx];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bool check(int x,int y)&#123;</span><br><span class="line">int fx=find(x),fy=find(y);</span><br><span class="line"><span class="keyword">if</span>(fx!=fy) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">scanf(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i,sz[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">scanf(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">e[++np]=(eage)&#123;x,y,z&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">scanf(<span class="string">"%d%d"</span>,&amp;nd[i].k,&amp;nd[i].v);nd[i].id=i;</span><br><span class="line">&#125;</span><br><span class="line">sort(e+<span class="number">1</span>,e+np+<span class="number">1</span>);sort(nd+<span class="number">1</span>,nd+q+<span class="number">1</span>);</span><br><span class="line">int j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j&lt;=np&amp;&amp;e[j].len&gt;=nd[i].k)&#123;</span><br><span class="line">link(e[j].u,e[j].v);</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">nd[i].ans=sz[find(nd[i].v)]-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">sort(nd+<span class="number">1</span>,nd+q+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=q;i++) printf(<span class="string">"%d\n"</span>,nd[i].ans);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><h2 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h2><p>小 Y 正用图章和颜料在草稿纸上乱涂颜色。对于数学敏感的他，突然发<br>现这是一个有意思的数学问题：<br>给出有 N 个格子的纸、宽度为 K 个格子的图章和 M 种不同的颜色，每<br>次用图章把纸上连续的 K 个格子上染任意一种颜色，最后把纸涂满，那么<br>小 Y 想知道最后纸上的颜色序列有多少种不同的情况？</p><h2 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h2><p>输入文件名为 paint.in<br>输入数据仅一行，包含三个整数 N,M,K，他们中间用一个空格分开，分<br>别表示纸张的长度，颜色数目和图章的宽度。</p><h2 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h2><p>输入文件名为 paint.out<br>输出文件仅一行，一个非负整数，表示答案。这个数可能很大，请模<br>1000000007 后输出。</p><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input"></a>Sample Input</h3><p>3 2 2</p><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output"></a>Sample Output</h3><p>6</p><h2 id="Hint-2"><a href="#Hint-2" class="headerlink" title="Hint"></a>Hint</h2><p>对于 20%的数据 N,M,K≤5<br>对于 50%的数据 N,K≤1 000<br>对于 100%的数据 N,M,K≤10 000 000</p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><p>真的是数学问题吗？？？首先要明白一点，合法的是要求至少有一个长度为K的相同颜色的块。（这个都没有想出来我好蒻A qwq）<br>然后正难则反，我们只要求出不合法的总个数，然后用总的方法数减去不合法的即为合法的方案数，那么这里用dp,设f[i]为前i个<br>不合法的方案数，那么就不会出现连续k个，所以：<br>$f[i]=f[i-1]*m （i&lt;k）​$</p><p>$f[i]=(f[i-1]+f[i-2]+…+f[i-k+1])*(m-1) (i&gt;=k)$  第i个和第i-k个必须不一样<br>再简单加个滑动窗口就可以O(n)过了233333</p><h3 id="tips-1"><a href="#tips-1" class="headerlink" title="tips"></a>tips</h3><p>题目中有mod的话，一般不是dp就是数学（套路！！！）<br>上代码：</p><h2 id="The-Code-2"><a href="#The-Code-2" class="headerlink" title="The Code"></a>The Code</h2><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define maxn 10000005</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll mod=<span class="number">1000000007</span>;</span><br><span class="line">int n,m,k;</span><br><span class="line">ll dp[maxn];</span><br><span class="line">ll qkpow(ll t,int pos)&#123;</span><br><span class="line"><span class="keyword">if</span>(pos==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(pos==<span class="number">1</span>) <span class="keyword">return</span> t%mod;</span><br><span class="line">ll tt=qkpow(t,pos/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(pos&amp;<span class="number">1</span>) <span class="keyword">return</span> tt*tt%mod*t%mod;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> tt*tt%mod;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">scanf(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">ll all=qkpow(m,n);</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">ll sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;k;i++) dp[i]=dp[i-<span class="number">1</span>]*m%mod,sum=(sum+dp[i])%mod;</span><br><span class="line"><span class="keyword">for</span>(int i=k;i&lt;=n;i++)&#123;</span><br><span class="line">dp[i]=(sum)*(m-<span class="number">1</span>)%mod;</span><br><span class="line">sum=(sum+dp[i]-dp[i-k+<span class="number">1</span>]+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line">ll ans=(all-dp[n]+mod)%mod;</span><br><span class="line">printf(<span class="string">"%lld"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结：总结套路a鸽子，多想想那些大佬是怎么思考的。（think-twice-code-once）"><a href="#小结：总结套路a鸽子，多想想那些大佬是怎么思考的。（think-twice-code-once）" class="headerlink" title="小结：总结套路a鸽子，多想想那些大佬是怎么思考的。（think twice,code once）"></a>小结：总结套路a鸽子，多想想那些大佬是怎么思考的。（think twice,code once）</h3>]]></content>
      
      
      <categories>
          
          <category> noip模拟赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 离线 </tag>
            
            <tag> 数学 </tag>
            
            <tag> dp </tag>
            
            <tag> 正难则反 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>祎隋</title>
      <link href="/2018/10/16/11/"/>
      <url>/2018/10/16/11/</url>
      
        <content type="html"><![CDATA[<p><font size="6" color="pink">童话，被同化前做过的梦</font><br>《祎隋》</p><p>我们因多少人孤单</p><p>又有多少人为我们不安</p><p>等待是漫长的表演</p><p>相安是莫大的荒诞</p><p>为搏那一瞬笑颜 熹光几点</p><p>我们敢于冒险 心怀本愿</p><p>却屡次三番 无法实现</p><p>使得停滞不前 初心淡暗</p><p>何时起相顾无言 仿佛就从昨天</p><p>再忆那春风不及的笑脸 已是许久以前</p><p>颔首 低眉 轻笑 每个瞬间</p><p>浅唱 微吟 翩舞 总拨心弦</p><p>可我没有华丽诗篇 没有道貌伟岸</p><p>只有痴心一片 闲心几点</p><p>忽而悄然自言 你可曾是我心中的四月天？</p><p>回神漠然 青春已半</p><p>不如数月以前 我们未曾相见</p><p>窗沿 雨 雷电 深夜未眠</p><p>愿初心不变 心境自然</p><p>虽喜忧掺半 往前仍是少年</p><p><img src="/16/11/小鞠.jpg" alt="小鞠"></p>]]></content>
      
      
      <categories>
          
          <category> 杂诗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂诗 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CF350E Wrong Floyd</title>
      <link href="/2018/10/16/10/"/>
      <url>/2018/10/16/10/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定n个点,m条边以及k个标记点，要求进行Floyd时只以标记的点为中间点进行松弛操作（每条边边权为1）要求你造出m条边的数据来hack掉这种程序。</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>3&lt;=n&lt;=300 , 2&lt;=k&lt;=n2&lt;=k&lt;=n , n-1&lt;=m&lt;=n*(n-1)/2;</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>我们只需要任意一点只和非标记点连边就可以了（这样就无法正确更新它到其他点的距离）</p><p>具体一下几个细节：</p><p>1.判k==n或m&gt;最多可以构出的边maxm；</p><p>maxm=(n-1)*(n-2)/2+num;（num:非标记点的数量）</p><p>2.将随便一个标记点与所以非标记点连边；</p><p>3.再随便一个非标记点与未加入图中的点连边来保证图的联通；</p><p>4.最后随便加未加的边使边数凑够m即可；</p><h1 id="The-Code"><a href="#The-Code" class="headerlink" title="The Code"></a>The Code</h1><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define maxn 310</span></span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,k,x,num;</span><br><span class="line">bool vis[maxn],iss[maxn][maxn],viss[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">    scanf(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++) iss[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=k;i++) scanf(<span class="string">"%d"</span>,&amp;x),vis[x]=<span class="number">1</span>;</span><br><span class="line">    num=n-k;</span><br><span class="line">    int maxx=(n-<span class="number">1</span>)*(n-<span class="number">2</span>)/<span class="number">2</span>+num;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;maxx<span class="params">||</span>k==n)&#123;</span><br><span class="line">        printf(<span class="string">"-1"</span>);<span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    int t,tt=<span class="number">1</span>;int calc=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!vis[tt]) tt++; </span><br><span class="line">    viss[tt]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            t=i;</span><br><span class="line">            viss[t]=<span class="number">1</span>;</span><br><span class="line">            printf(<span class="string">"%d %d\n"</span>,t,tt);</span><br><span class="line">            iss[t][tt]=iss[tt][t]=<span class="number">1</span>;</span><br><span class="line">            calc++; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /<span class="regexp">/保证联通 </span></span><br><span class="line"><span class="regexp">    for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="regexp">        if(viss[i]) continue;</span></span><br><span class="line"><span class="regexp">        printf("%d %d\n",i,t); </span></span><br><span class="line"><span class="regexp">        iss[i][t]=iss[t][i]=1;</span></span><br><span class="line"><span class="regexp">        calc++;</span></span><br><span class="line"><span class="regexp">        if(calc==m) break;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">    for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="regexp">        if(calc==m) break;</span></span><br><span class="line"><span class="regexp">        if(i==tt) continue;</span></span><br><span class="line"><span class="regexp">        for(int j=1;j&lt;=n;j++)&#123;</span></span><br><span class="line"><span class="regexp">            if(j==tt) continue;</span></span><br><span class="line"><span class="regexp">            if(iss[i][j]) continue;</span></span><br><span class="line"><span class="regexp">            printf("%d %d\n",i,j);</span></span><br><span class="line"><span class="regexp">            calc++;</span></span><br><span class="line"><span class="regexp">            iss[i][j]=iss[j][i]=1;</span></span><br><span class="line"><span class="regexp">            if(calc==m) break;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">int main()&#123;</span></span><br><span class="line"><span class="regexp">    init();</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">    return 0;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>32.Sort</title>
      <link href="/2018/10/16/9/"/>
      <url>/2018/10/16/9/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>众所周知，排序方法有许多种。例如：简单易懂的冒泡排序，平均复杂度较优的快速排序，以及不基于比较的基数排序等等。<br><a id="more"></a></p><p>现在，小 DD 得到了一个自然数序列 {a1,a2,⋯,an}{a1,a2,⋯,an}。他想要对其按照从小到大的顺序进行排序（即使得每个元素均严格不大于他的后继元素）。但由于基于比较的排序算法复杂度下界已经被证明为 Θ(nlog2n)Θ(nlog2⁡n)，所以小 DD 决定尝试一种全新的排序算法：翻转排序。</p><p>在翻转排序中，小 DD 在每次操作中，可以选择一个区间 [l,r][l,r] (1≤l≤r≤n)(1≤l≤r≤n)，并翻转 al,al+1,⋯,aral,al+1,⋯,ar。即，在该次操作完后，序列将会变为 a1,a2,⋯,al−1,ar,ar−1,⋯,al+1,al,ar+1,ar+2,⋯,ana1,a2,⋯,al−1,ar,ar−1,⋯,al+1,al,ar+1,ar+2,⋯,an。</p><p>例如，对于序列 [1,6,2,4,3,5][1,6,2,4,3,5]，若选择区间 [2,4][2,4] 进行翻转，则将会得到 [1,4,2,6,3,5][1,4,2,6,3,5]。</p><p>定义一次操作的代价为 r−l+1r−l+1，即翻转的区间长度。定义一个操作序列的代价为每次操作的代价之和。现在，请你帮助小 DD 求出一个代价足够小的操作序列（你并不一定要求出代价最小的操作序列）。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行一个正整数 nn，表示序列长度。</p><p>第二行 nn 个空格隔开的非负整数，表示小 DD 得到的自然数序列 a1,a2,⋯,ana1,a2,⋯,an。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>输出若干行，每行两个空格隔开的正整数 l,rl,r (1≤l≤r≤n)(1≤l≤r≤n)，表示一次翻转区间 [l,r][l,r] 的操作。</p><p>最后输出一行 -1 -1，标志着操作序列的结束。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>4 1 3 2 4</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>2 3 -1 -1</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>1.下发文件中提供了 checker.cpp，该程序将对于其所在目录下的 sort.in，判断其所在目录下的 sort.out 是否为一个正确的操作序列。若正确，将给出该操作序列的代价。若不正确，将给出错误信息。选手可以借助该程序来更好地检查自己的程序是否正确。</p><p>运行时，必须保证 sort.in 为一个合法的输入，且需保证 sort.out 符合题目中描述的输出格式，否则出现任何结果均有可能。</p><p>2.对于所有测试数据，保证 1≤n≤500001≤n≤50000，且 0≤ai≤1090≤ai≤109。</p><p>（附checker.cpp）<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstdio&gt;</span></span><br><span class="line">int arr[<span class="number">50005</span>];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fin = fopen(<span class="string">"sort.in"</span>, <span class="string">"r"</span>), *fout = fopen(<span class="string">"sort.out"</span>, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fin)</span><br><span class="line">    &#123;</span><br><span class="line">        puts(<span class="string">"INVALID : File sort.in not found."</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!fout)</span><br><span class="line">    &#123;</span><br><span class="line">        puts(<span class="string">"INVALID : File sort.out not found."</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    int n;</span><br><span class="line">    fscanf(fin, <span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        fscanf(fin, <span class="string">"%d"</span>, arr + i);</span><br><span class="line">    int l, r, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (~fscanf(fout, <span class="string">"%d%d"</span>, &amp;l, &amp;r))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == -<span class="number">1</span> &amp;&amp; r == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        sum += r - l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= <span class="number">0</span> <span class="params">||</span> l &gt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(<span class="string">"INVALID : l = %d is not in range [1, %d].\n"</span>, l, n);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &lt;= <span class="number">0</span> <span class="params">||</span> r &gt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(<span class="string">"INVALID : r = %d is not in range [1, %d].\n"</span>, r, n);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(<span class="string">"INVALID : %d = l &gt; r = %d.\n"</span>, l, r);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; <span class="number">20000000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            puts(<span class="string">"INVALID : Too much cost."</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::reverse(arr + --l, arr + r);</span><br><span class="line">    &#125;</span><br><span class="line">    bool f = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        f &amp;= arr[i] &gt;= arr[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (!f)</span><br><span class="line">    &#123;</span><br><span class="line">        puts(<span class="string">"INVALID : Not sorted."</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"VALID : Total cost is %d.\n"</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checker</span><br></pre></td></tr></table></figure></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>本题算是一个比较新颖的题目，实际上是用这种翻转来模拟实现归并排序:</p><p>先将给定数列进行离散化，每次选定一个中间的数，将小于等于它的排在左边，大于它的排在右边，再依次递归两边就可以了；</p><p>主要是复杂度（进行操作的次数）证明a….    排一遍要n，由于其非01性，所以进行log2n次的n排，故排一遍将l到r以stdd为标准换为左边小于等于stdd，右边大于等于stdd的操作数为Θ(nlog2n) ；</p><p>T(n) = 2T(n/2) + Θ(nlog2n),可以解得 T(n) = Θ(nlog22n) ； tql%%%<br>上代码。<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define maxn 50005</span></span><br><span class="line">using namespace std;</span><br><span class="line">int n,pos[maxn];</span><br><span class="line">struct node&#123;</span><br><span class="line">    int v,id;</span><br><span class="line">    friend bool operator&lt;(node a,node b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.v&lt;b.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;nd[maxn];</span><br><span class="line">int stdd;</span><br><span class="line">void run(int l,int r)&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    int mid=l+r<span class="meta">&gt;&gt;</span><span class="number">1</span>;</span><br><span class="line">    run(l,mid);run(mid+<span class="number">1</span>,r);</span><br><span class="line">    </span><br><span class="line">    int L,R;<span class="regexp">//</span>要翻转的区间 </span><br><span class="line">    L=R=mid;<span class="regexp">//</span>L和R的初值 </span><br><span class="line">    int i=mid,j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=l&amp;&amp;pos[i]&gt;stdd) L=i--;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r&amp;&amp;pos[j]&lt;=stdd) R=j++;</span><br><span class="line">    <span class="keyword">if</span>(L!=R)&#123;</span><br><span class="line">        printf(<span class="string">"%d %d\n"</span>,L,R);</span><br><span class="line">        reverse(pos+L,pos+R+<span class="number">1</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">void msort(int l,int r)&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    int mid=stdd=(l+r)<span class="meta">&gt;&gt;</span><span class="number">1</span>;</span><br><span class="line">    run(l,r);<span class="regexp">//</span>将l到r以stdd为标准换为左边小于等于stdd，右边大于等于stdd</span><br><span class="line"> </span><br><span class="line">    msort(l,mid);msort(mid+<span class="number">1</span>,r);    </span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    scanf(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(<span class="string">"%d"</span>,&amp;nd[i].v);nd[i].id=i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(nd+<span class="number">1</span>,nd+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++) pos[nd[i].id]=i;<span class="regexp">//</span>离散化位置确定 </span><br><span class="line">    </span><br><span class="line">    msort(<span class="number">1</span>,n);</span><br><span class="line">    printf(<span class="string">"-1 -1\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    /<span class="regexp">/freopen("sort.in","r",stdin);</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/freopen("sort.out","w",stdout);</span></span><br><span class="line"><span class="regexp">    init();</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">    return 0;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Noi.ac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
            <tag> 离散化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数对子</title>
      <link href="/2018/10/16/8/"/>
      <url>/2018/10/16/8/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>我们定义一个数对 (x,y) 是好的，当且仅当 x≤y，且 x xor y的二进制表示下有奇数个 1</p><p>现在给定 nn 个区间 [li,ri]，你需要对于每个 i∈[1,n]，输出有几对好的数 (x,y)满足 x 和 y 都在 [l1,r1]∪[l2,r2]…∪[li,ri]，即两个数都在前 i 个区间的并里<br><a id="more"></a></p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行一个正整数 n</p><p>接下来 n 行每行两个整数 [li,ri]，表示第 i个区间，保证 li≤ri</p><h1 id="Ouput"><a href="#Ouput" class="headerlink" title="Ouput"></a>Ouput</h1><p>输出 n 行，第 i行一个整数表示有几对好的数 (x,y) 满足 x,y 都在前 i 个区间的并里</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>3</p><p>1 7</p><p>3 10</p><p>9 20</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>12</p><p>25</p><p>100</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>对于 30%30% 的数据，有 1≤n≤1001≤n≤100，1≤li≤ri≤1001≤li≤ri≤100</p><p>对于 50%50% 的数据，有 1≤n≤10001≤n≤1000，1≤li≤ri≤232−11≤li≤ri≤232−1</p><p>对于 100%100% 的数据，有 1≤n≤1051≤n≤105, 1≤li≤ri≤232−11≤li≤ri≤232−1</p><p>时间限制：2s</p><p>空间限制：512MB</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>先补充几个小知识点（快速求出一个数的二进制中有多少个1）:</p><p>x=x&amp;(x-1)（递归求法，适用于单个数）</p><p>表达式的意思就是:把x的二进制表示 从低位开始，将遇到的第一个为1的 二进制位 置0。</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">int calc=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x) x=x&amp;(x-<span class="number">1</span>),calc++;</span><br><span class="line">calc即为所求值</span><br></pre></td></tr></table></figure><p>求0到x中有多少二进制含1个数为奇数的：</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">long long calc(long long x)</span><br><span class="line">&#123;</span><br><span class="line">    long long tmp=x,tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp&amp;<span class="number">1</span>)tot++;</span><br><span class="line">        tmp<span class="meta">&gt;&gt;=</span><span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (x<span class="meta">&gt;&gt;</span><span class="number">1</span>)+((x&amp;<span class="number">1</span>) <span class="params">||</span> (tot&amp;<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">证明：<span class="number">00</span> <span class="number">01</span> <span class="number">10</span> <span class="number">11</span> <span class="number">100</span> <span class="number">101</span> <span class="number">110</span> <span class="number">111</span>....继续下去可以发现规律是偶奇奇偶奇偶偶奇....</span><br><span class="line">所以x<span class="meta">&gt;&gt;</span><span class="number">1</span>之前一半的，如果x为奇数（会少算一个）或其本身有奇数个<span class="number">1</span>得加上</span><br></pre></td></tr></table></figure><p>所以说探究性质a老哥(这个性质也可以记住)</p><p>p.s.当线段树叶子节点有n个时，应开总共2^(log2n+1)个点，即2*n个点</p><h2 id="正经题解开始："><a href="#正经题解开始：" class="headerlink" title="正经题解开始："></a>正经题解开始：</h2><p>首先，对于每个数对（x,y）, 若要x xor y的二进制表示下有奇数个 1，则必定一者含奇数个1，一者含偶数个。</p><p>证明：若两个都为奇数，1.则奇减奇等于偶（重叠个数为奇个）2.奇减偶先为奇（重叠个数为偶数个），奇加奇等于偶</p><p>​           若两个都为偶数，则可同上证明</p><p>​           一奇一偶，1.奇减奇等于偶，偶减奇等于奇，奇加偶等于奇2.奇减偶等于奇，偶减偶等于偶，偶加奇等于奇</p><p>所以我们采取线段树来维护区间含奇数个1和含偶数个1的个数，对于区间l,r，则用上述中所介绍的calc函数，来calc(r)-calc(l-1)得到奇数个1个数以及r-l+1-（calc(r)-calc(l-1)）得到偶数个1个数</p><p>每次输入一个区间加进去统计一个区间，然后输出总的相乘即可。p.s.线段树很好的解决了区间相交的问题，在以及统计过的区间标记vis[now]=1;</p><p>上代码：</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define maxn 100005</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">ll num[maxn&lt;&lt;<span class="number">4</span>][<span class="number">2</span>];</span><br><span class="line">int lc[maxn&lt;&lt;<span class="number">4</span>],rc[maxn&lt;&lt;<span class="number">4</span>],rt=<span class="number">0</span>,np=<span class="number">0</span>;</span><br><span class="line">int n;</span><br><span class="line">bool vis[maxn&lt;&lt;<span class="number">4</span>];</span><br><span class="line">void upload(int now)&#123;</span><br><span class="line">    num[now][<span class="number">0</span>]=num[lc[now]][<span class="number">0</span>]+num[rc[now]][<span class="number">0</span>];</span><br><span class="line">    num[now][<span class="number">1</span>]=num[lc[now]][<span class="number">1</span>]+num[rc[now]][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">ll calc(ll x)</span><br><span class="line">&#123;</span><br><span class="line">    ll t=x,tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t&amp;<span class="number">1</span>)tot++;</span><br><span class="line">        t<span class="meta">&gt;&gt;=</span><span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (x<span class="meta">&gt;&gt;</span><span class="number">1</span>)+((x&amp;<span class="number">1</span>) <span class="params">||</span> (tot&amp;<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">void update(int &amp;now,ll l,ll r,ll x,ll y)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!now) now=++np;</span><br><span class="line">    <span class="keyword">if</span>(vis[now]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=x&amp;&amp;r&lt;=y)&#123;</span><br><span class="line">        num[now][<span class="number">1</span>]=calc(r)-calc(l-<span class="number">1</span>);</span><br><span class="line">        num[now][<span class="number">0</span>]=r-l+<span class="number">1</span>-num[now][<span class="number">1</span>];</span><br><span class="line">        vis[now]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll m=(l+r)<span class="meta">&gt;&gt;</span><span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(y&lt;=m)update(lc[now],l,m,x,y);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;m)update(rc[now],m+<span class="number">1</span>,r,x,y);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        update(lc[now],l,m,x,y);</span><br><span class="line">        update(rc[now],m+<span class="number">1</span>,r,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    upload(now);</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    scanf(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    ll L,R,mx=<span class="number">1</span>ll&lt;&lt;<span class="number">32</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(<span class="string">"%lld%lld"</span>,&amp;L,&amp;R);</span><br><span class="line">        update(rt,<span class="number">1</span>,mx,L,R);</span><br><span class="line">        printf(<span class="string">"%lld\n"</span>,num[<span class="number">1</span>][<span class="number">0</span>]*num[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    init();    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二进制 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>祎隋</title>
      <link href="/2018/10/16/7/"/>
      <url>/2018/10/16/7/</url>
      
        <content type="html"><![CDATA[<font size="6" color="pink">愿你像个孩子，愿你心生双翼</font><p>《祎隋》</p><p>青涩</p><p>带着年少初识的忐忑</p><p>我们相遇了</p><p>传奇</p><p>三年来我们所追寻的词字</p><p>一段故事 从这里轻启</p><p>回忆</p><p>忘不却从前往事</p><p>追不上白驹过隙</p><p>再聚</p><p>仿佛多年往复 传奇已铸</p><p>但我们的故事未完待续</p><p>我们的航船才起征途</p><p>愿</p><p>愿相框里的我们永远闪闪发光</p><p>愿你仍是原般模样 </p><p><img src="/16/7/小鞠.jpg" alt="小鞠"></p>]]></content>
      
      
      <categories>
          
          <category> 杂诗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂诗 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CF351B Jeff and Furik</title>
      <link href="/2018/10/16/6/"/>
      <url>/2018/10/16/6/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给一个1~n的排列p[i]，Jeff先手可以交换任意两个相邻元素，而Furik会有0.5的几率把任意满足p[i] &lt; p[i+1]的p[i]和p[i+1]交换，有0.5的几率把任意满足p[i] &gt; p[i+1]的p[i]和p[i+1]交换，问将整个序列变成升序所需的最小期望步数<br><a id="more"></a></p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行一整数n表示序列长度，之后一个1~n的排列p[i] (1&lt;=n&lt;=3000) </p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>输出把整个序列变成升序所需的最小期望步数 </p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>5<br>3 5 2 4 1</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>13.000000 </p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>考虑E[i]（i为逆序对个数）的最小期望步数，则E[0]=0,E[1]=1;那么每一次Jeff肯定是交换使逆序对减少一个而Furik则有50%减少一个50%增加一个，故$E[i]=1/2<em>(E[i-2]+1)+1/2</em>(E[i-1+1]+1)$;化简得$E[i]=E[i-2]+4$;</p><p>故模拟归并排序求一次逆序对个数便可实现。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define maxn 3005</span></span><br><span class="line">using namespace std;</span><br><span class="line">int n,a[maxn],t[maxn];</span><br><span class="line">int msort(int l,int r)&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    int m=l+r<span class="meta">&gt;&gt;</span><span class="number">1</span>;</span><br><span class="line">    int t1=msort(l,m);</span><br><span class="line">    int t2=msort(m+<span class="number">1</span>,r);</span><br><span class="line">    </span><br><span class="line">    int t3=<span class="number">0</span>;</span><br><span class="line">    int i=l,j=m+<span class="number">1</span>,k=l;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=m&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;a[j])&#123;</span><br><span class="line">            t3+=m-i+<span class="number">1</span>;</span><br><span class="line">            t[k++]=a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            t[k++]=a[i++];<span class="regexp">//</span>本来就应该小于 </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=m) t[k++]=a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r) t[k++]=a[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(int p=l;p&lt;=r;p++) a[p]=t[p];<span class="regexp">//</span>调整</span><br><span class="line">    <span class="keyword">return</span> t1+t2+t3; </span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    scanf(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++) scanf(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    int nd=msort(<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">if</span>(nd&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        printf(<span class="string">"%lf"</span>,(double)(<span class="number">2</span>*nd-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> printf(<span class="string">"%lf"</span>,(double)<span class="number">2</span>*nd);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率期望 </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>卡常数</title>
      <link href="/2018/10/16/5/"/>
      <url>/2018/10/16/5/</url>
      
        <content type="html"><![CDATA[<h1 id="Decription"><a href="#Decription" class="headerlink" title="Decription"></a>Decription</h1><p>（在十进制下）定义 mn(i) 表示把 i 的各位数字从小到大排序得到的数，mx(i) 表示从大到小得到的数。这里的数是允许有前导零的，比如mn(10000)=00001=1 ， mx(132)=321 等。定义 f(i)=mx(i)−mn(i) 。当然，这里 mx(i) 的定义是要在某个整数 k 位十进制数下的。</p><p>卡常数指印度数学家Kaprekar发现的常数 6174 。他发现，任取一个各位数字不全相同的四位数 x，不断地使 x=f(x) ，最终总能得到 6174 。<br><a id="more"></a></p><p>现在Fizzydavid学习了高级的卡常数技巧，他想知道对于五位数的情况。他每次会给你一个带前导零的五位数x，要让你求出操作 x=f(x) 进行 c 次之后的结果。他每次给你的 c 都是一样的。此时 f 定义中的 k=5。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行两个整数 T,c 。T 表示询问次数，c 的含义如题面。</p><p>接下来 T 行每行一个五位数 x ，不足五位会加前导零补到五位。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>对于每个询问输出一行表示答案。不足五位需要补到五位。</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>1≤T≤105,1≤c≤109,0≤x&lt;105 。</p><p>20%的数据保证 c≤10 。</p><p>另外20%的数据保证 T≤10 。</p><p>另外30%的数据保证 c≥105 。</p><p>时间限制： 2s</p><p>空间限制： 512MB</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>woc这道题思路很Nice啊。<br>首先会想到肯定每个数进行一定次数之后会循环(不然就没法做了a)。<br>然后这里应该要想到我们对当前的数求循环的时候，我们事实上已经对所有经过的数求出来<br>了，这样稍微处理一下就可以保证每个数只被访问一次。<br>但这样还是会T a。。。<br>于是探究性质：发现对于一个x进行a+b次操作等于先将x进行a次操作，再进行b次操作，或者反过来，再进一步想到可以倍增预处理(Nice啊).这样就欧克了a(注意倍增不要写错a在刷状态的时候QAQ)</p><h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4><p>1.以后遇到这种性质都可以考虑倍增(LCA也有这种性质嘛)<br>2.补充一下姿势（雾<br>%nd 输出的整型宽度至少为n位，右对齐，%5d即宽度至少为5位，位数大于5则输出实际位数<br>%0nd 用得比较多，表示输出的整型宽度至少为n位，不足n位用0填充<br>printf（”%05d”,1）输出：00001<br>printf（”%5d”,1）输出：<em>**</em>1（$*$为空格）</p><h1 id="The-Code"><a href="#The-Code" class="headerlink" title="The Code"></a>The Code</h1><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define maxn 100005</span></span><br><span class="line">using namespace std;</span><br><span class="line">int n,x,c;</span><br><span class="line">int g[<span class="number">100005</span>][<span class="number">31</span>],mx,mn,a[<span class="number">7</span>];</span><br><span class="line">int cmp(int x,int y)&#123;</span><br><span class="line"><span class="keyword">return</span> x&gt;y;</span><br><span class="line">&#125;</span><br><span class="line">int f(int x)&#123;</span><br><span class="line">    memset(a,<span class="number">0</span>,sizeof(a));</span><br><span class="line">    int pos=<span class="number">6</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">    a[--pos]=x%<span class="number">10</span>;x/=<span class="number">10</span>;</span><br><span class="line">&#125; </span><br><span class="line">sort(a+<span class="number">1</span>,a+<span class="number">6</span>);mn=a[<span class="number">1</span>]*<span class="number">10000</span>+a[<span class="number">2</span>]*<span class="number">1000</span>+a[<span class="number">3</span>]*<span class="number">100</span>+a[<span class="number">4</span>]*<span class="number">10</span>+a[<span class="number">5</span>];</span><br><span class="line">sort(a+<span class="number">1</span>,a+<span class="number">6</span>,cmp);mx=a[<span class="number">1</span>]*<span class="number">10000</span>+a[<span class="number">2</span>]*<span class="number">1000</span>+a[<span class="number">3</span>]*<span class="number">100</span>+a[<span class="number">4</span>]*<span class="number">10</span>+a[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">return</span> mx-mn;</span><br><span class="line">&#125;</span><br><span class="line">void pre()&#123;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;=<span class="number">99999</span>;i++) g[i][<span class="number">0</span>]=f(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=<span class="number">30</span>;j++)</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;=<span class="number">99999</span>;i++) g[i][j]=g[g[i][j-<span class="number">1</span>]][j-<span class="number">1</span>]; </span><br><span class="line">&#125;</span><br><span class="line">bool vis[<span class="number">31</span>];</span><br><span class="line">void init()&#123;</span><br><span class="line">scanf(<span class="string">"%d%d"</span>,&amp;n,&amp;c);</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;=<span class="number">30</span>;i++) <span class="keyword">if</span>(c&amp;(<span class="number">1</span>&lt;&lt;i)) vis[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">scanf(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line"><span class="keyword">for</span>(int j=<span class="number">0</span>;j&lt;=<span class="number">30</span>;j++) <span class="keyword">if</span>(vis[j]) x=g[x][j];</span><br><span class="line">printf(<span class="string">"%05d\n"</span>,x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">pre();</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 倍增 </tag>
            
            <tag> 预处理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>树</title>
      <link href="/2018/10/16/4/"/>
      <url>/2018/10/16/4/</url>
      
        <content type="html"><![CDATA[<h1 id="The-Solution"><a href="#The-Solution" class="headerlink" title="The Solution"></a>The Solution</h1><p>emmmmmmmm，这道题题意读错了a，有点难受…很考细节的一道题，同时告诉我们细节题要对拍。<br>首先我们要维护的是最大的剩余空间，但实质上是最大的最近距离，比如区间所剩为5和4，实际上它们的最近距离都为2。在设定友好函数时要注意。<br><a id="more"></a><br>在处理好一般操作之后是特判，主要就是对于两端的处理，因为它们是独立成段的(图中红色部分)，所以只要红色长度大于最近距离即更优。<br><img src="/16/4/233.jpg" alt="补图"><br>最后要注意标号尽可能小的细节。</p><h1 id="The-Code"><a href="#The-Code" class="headerlink" title="The Code"></a>The Code</h1><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define maxn 200005</span></span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">int l,r;</span><br><span class="line">friend bool operator &lt;(node a,node b)&#123;</span><br><span class="line"><span class="keyword">if</span>((a.r-a.l)/<span class="number">2</span>!=(b.r-b.l)/<span class="number">2</span>)<span class="keyword">return</span> (a.r-a.l)/<span class="number">2</span>&gt;(b.r-b.l)/<span class="number">2</span>;</span><br><span class="line">  /<span class="regexp">/排得是这个最近距离aQAQ 并且不能将2免去，因为奇偶 </span></span><br><span class="line"><span class="regexp">else return a.l&lt;b.l;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">set&lt;node&gt;s;</span></span><br><span class="line"><span class="regexp">set&lt;node&gt;::iterator it;</span></span><br><span class="line"><span class="regexp">int n,m,x,y;</span></span><br><span class="line"><span class="regexp">map&lt;int,int&gt;mp;</span></span><br><span class="line"><span class="regexp">int pre[maxn],next[maxn],st[maxn],rk[maxn];</span></span><br><span class="line"><span class="regexp">int np=0; </span></span><br><span class="line"><span class="regexp">void init()&#123;</span></span><br><span class="line"><span class="regexp">scanf("%d%d",&amp;n,&amp;m);</span></span><br><span class="line"><span class="regexp">s.insert((node)&#123;0,n+1&#125;);</span></span><br><span class="line"><span class="regexp">pre[0]=0;next[0]=n+1;pre[n+1]=0;next[n+1]=n+1;</span></span><br><span class="line"><span class="regexp">for(int i=1;i&lt;=m;i++)&#123;</span></span><br><span class="line"><span class="regexp">scanf("%d%d",&amp;x,&amp;y);</span></span><br><span class="line"><span class="regexp">/</span>*<span class="keyword">if</span>(x==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(t.l==<span class="number">0</span>&amp;&amp;t.r==n+<span class="number">1</span>)&#123;</span><br><span class="line">st[np]=<span class="number">1</span>;</span><br><span class="line">rk[<span class="number">1</span>]=np;</span><br><span class="line"><span class="keyword">next</span>[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">next</span>[<span class="number">1</span>]=n+<span class="number">1</span>;</span><br><span class="line">pre[n+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">s.erase((node)&#123;<span class="number">0</span>,n+<span class="number">1</span>&#125;);</span><br><span class="line">s.insert((node)&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);s.insert((node)&#123;<span class="number">1</span>,n+<span class="number">1</span>&#125;);</span><br><span class="line">printf(<span class="string">"1\n"</span>);continue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t.l==<span class="number">1</span>&amp;&amp;t.r==n+<span class="number">1</span>)&#123;</span><br><span class="line">st[np]=n;</span><br><span class="line">rk[n]=np;</span><br><span class="line">pre[n]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">next</span>[n]=n+<span class="number">1</span>;</span><br><span class="line">pre[n+<span class="number">1</span>]=n;</span><br><span class="line"><span class="keyword">next</span>[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">s.erase((node)&#123;<span class="number">1</span>,n+<span class="number">1</span>&#125;);</span><br><span class="line">s.insert((node)&#123;<span class="number">1</span>,n&#125;);s.insert((node)&#123;n,n+<span class="number">1</span>&#125;);</span><br><span class="line">printf(<span class="string">"%d\n"</span>,n);continue;</span><br><span class="line">&#125;*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">if(x==1)&#123;</span></span><br><span class="line"><span class="regexp">mp[y]=++np;</span></span><br><span class="line"><span class="regexp">it=s.begin();</span></span><br><span class="line"><span class="regexp">node t=*it;</span></span><br><span class="line"><span class="regexp">int len=(t.r-t.l)/</span><span class="number">2</span>;</span><br><span class="line">bool ok1=<span class="literal">false</span>,ok2=<span class="literal">false</span>;</span><br><span class="line">int len1=<span class="number">0</span>,len2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!rk[<span class="number">1</span>]) len1=<span class="keyword">next</span>[<span class="number">0</span>]-<span class="number">1</span>;<span class="keyword">if</span>(!rk[n]) len2=n-pre[n+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(len2&gt;len1) ok2=<span class="literal">true</span>;<span class="keyword">else</span> ok1=<span class="literal">true</span>;<span class="regexp">//</span>标号 </span><br><span class="line"><span class="keyword">if</span>(!rk[<span class="number">1</span>]&amp;&amp;ok1)&#123;<span class="regexp">//</span>要考虑两端点的问题</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">next</span>[<span class="number">0</span>]-<span class="number">1</span>&gt;=len)&#123;<span class="regexp">//</span>标号优先 </span><br><span class="line">st[np]=<span class="number">1</span>;</span><br><span class="line">    rk[<span class="number">1</span>]=np;</span><br><span class="line">    <span class="keyword">next</span>[<span class="number">1</span>]=<span class="keyword">next</span>[<span class="number">0</span>];pre[<span class="keyword">next</span>[<span class="number">0</span>]]=<span class="number">1</span>;<span class="keyword">next</span>[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    s.erase((node)&#123;<span class="number">0</span>,<span class="keyword">next</span>[<span class="number">1</span>]&#125;);</span><br><span class="line">    s.insert((node)&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    s.insert((node)&#123;<span class="number">1</span>,<span class="keyword">next</span>[<span class="number">1</span>]&#125;);</span><br><span class="line">    printf(<span class="string">"1\n"</span>);continue;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!rk[n]&amp;&amp;ok2)&#123;</span><br><span class="line"><span class="keyword">if</span>(n-pre[n+<span class="number">1</span>]&gt;len)&#123;</span><br><span class="line">st[np]=n;</span><br><span class="line">    rk[n]=np;</span><br><span class="line">    pre[n]=pre[n+<span class="number">1</span>];<span class="keyword">next</span>[pre[n+<span class="number">1</span>]]=n;pre[n+<span class="number">1</span>]=n;</span><br><span class="line">    s.erase((node)&#123;pre[n],n+<span class="number">1</span>&#125;);</span><br><span class="line">    s.insert((node)&#123;n,n+<span class="number">1</span>&#125;);</span><br><span class="line">    s.insert((node)&#123;pre[n],n&#125;);</span><br><span class="line">    printf(<span class="string">"%d\n"</span>,n);continue;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">int position=t.l+len;rk[position]=np;st[np]=position;</span><br><span class="line">    pre[position]=t.l;<span class="keyword">next</span>[position]=t.r;pre[t.r]=position;</span><br><span class="line">  <span class="keyword">next</span>[t.l]=position;</span><br><span class="line">printf(<span class="string">"%d\n"</span>,position);</span><br><span class="line">s.erase((node)&#123;pre[position],<span class="keyword">next</span>[position]&#125;); </span><br><span class="line">s.insert((node)&#123;pre[position],position&#125;);</span><br><span class="line">    s.insert((node)&#123;position,<span class="keyword">next</span>[position]&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">int t=st[mp[y]];</span><br><span class="line">s.erase((node)&#123;pre[t],t&#125;);</span><br><span class="line">s.erase((node)&#123;t,<span class="keyword">next</span>[t]&#125;);</span><br><span class="line">s.insert((node)&#123;pre[t],<span class="keyword">next</span>[t]&#125;);</span><br><span class="line">rk[t]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">next</span>[pre[t]]=<span class="keyword">next</span>[t];</span><br><span class="line">pre[<span class="keyword">next</span>[t]]=pre[t];</span><br><span class="line">pre[t]=<span class="keyword">next</span>[t]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> set </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>减肥计划</title>
      <link href="/2018/10/15/3/"/>
      <url>/2018/10/15/3/</url>
      
        <content type="html"><![CDATA[<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>哇，这道题还是太急了，探究出个性质就直接溜了。<br>首先当$\sum{a_i}$一定时，$\sum{b_i}$越大肯定越优，那么可以dp[i]表示$\sum{a_i}$为i时最大的$\sum{b_i}$之值。<br>由于a的和为$n<em>max({a_i})$，所以总的复杂度会是$n^2</em>max({a_i})$。显然会超时。<br><a id="more"></a><br>所以我们来探求性质，发现当答案为$\frac{\sum{a_i}}{\sum{b_i}}$，若此时有$\frac{a_i}{b_i}$大于它时，那么加入一定会增大，反之加入小于的会减小，所以我们对于一个答案，不断删去小于它的$\frac{a_i}{b_i}$，直到$\sum{a_i}$&lt;m后停下来，那么过程中不会减小，此时再加入大于的即可，所以最多只用dp到$max({a_i})+m$，因此时间复杂度也降为$n*(m+max({a_i}))​$ ，即可通过此题。</p><p>上代码：</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cmath&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cctype&gt;</span></span><br><span class="line"><span class="comment">#include&lt;set&gt;</span></span><br><span class="line"><span class="comment">#include&lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include&lt;map&gt;</span></span><br><span class="line"><span class="comment">#include&lt;queue&gt;</span></span><br><span class="line"><span class="comment">#define maxn 10000005</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int n,m;</span><br><span class="line">ll dp[maxn&lt;&lt;<span class="number">1</span>],a[maxn],b[maxn];</span><br><span class="line">ll gcd(ll x,ll y)&#123;</span><br><span class="line"><span class="keyword">if</span>(y==<span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> gcd(y,x%y);</span><br><span class="line">&#125;</span><br><span class="line">ll maxx=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">void init()&#123;</span><br><span class="line">    scanf(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++) scanf(<span class="string">"%d%d"</span>,&amp;a[i],&amp;b[i]),maxx=max(maxx,a[i]),sum+=a[i];</span><br><span class="line"><span class="keyword">if</span>(sum&lt;m)&#123;printf(<span class="string">"-1"</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=m+maxx;i++) dp[i]=-<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(int j=maxx+m;j&gt;=a[i];j--) dp[j]=max(dp[j],dp[j-a[i]]+b[i]);</span><br><span class="line"></span><br><span class="line">ll fz=-<span class="number">1</span>,fm=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(int i=m;i&lt;=maxx+m;i++) <span class="keyword">if</span>(fz*i&lt;dp[i]*fm) fz=dp[i],fm=i;</span><br><span class="line">ll g=gcd(fz,fm);</span><br><span class="line">fz/=g;fm/=g;</span><br><span class="line">printf(<span class="string">"%d/%d"</span>,fz,fm); </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> dp </tag>
            
            <tag> 正睿 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最小瓶颈生成树</title>
      <link href="/2018/10/15/2/"/>
      <url>/2018/10/15/2/</url>
      
        <content type="html"><![CDATA[<h1 id="所谓最小瓶颈生成树…-就是使得生成树树上最大边权值最小。"><a href="#所谓最小瓶颈生成树…-就是使得生成树树上最大边权值最小。" class="headerlink" title="所谓最小瓶颈生成树….就是使得生成树树上最大边权值最小。"></a>所谓最小瓶颈生成树….就是使得生成树树上最大边权值最小。</h1><p>这里主要介绍一种期望O（M）（线性）的求法，其实主要就是二分，具体思路如下：</p><p>类比找第k大值的方法，首先随机一个边权w。</p><p>然后将不超过这个边权的边加入，遍历这张图。</p><p>如果图连通，那么瓶颈不超过w，于是只需考虑边权不超过w的边。</p><a id="more"></a><p>否则将这些连通点缩起来，考虑边权大于w的边。</p><p>每次将问题的规模缩小至一半。</p><p>期望时间复杂度O(m)。</p><h2 id="相关例题有两道："><a href="#相关例题有两道：" class="headerlink" title="相关例题有两道："></a>相关例题有两道：</h2><p>A.Hangar Hurdles (CERC 16)</p><p>有一个n*n的网格图，上面有些格子可行，有些格子是障碍。 有Q个询问，想把一个正方形箱子从(r1,c1)推到(r2,c2)，问箱子最大的大小。（起点终点是正方形箱子的中点） N&lt;=1000 Q&lt;=300000</p><p>B.洪蛤吨有一个宽度为L的管道，我们可以视其为一条y=L的直线与X轴所夹的部分。</p><p>（所以这根管道的长度可以视为正无穷）</p><p>这个管道中有个N个障碍点，第i个障碍点的坐标为(Xi,Yi)。</p><p>已知有一个球体，能在不碰到障碍点的前提下，从管道的最左端走到最右端。（即从管道内横坐标负无穷的地方走到横坐标正无穷的地方）。</p><p>求这个球体的直径最大是多少。为了避免精度误差，请输出答案保留三位小数的结果。</p><h3 id="两题有异曲同工之妙a…（-滑稽，思路差不多…）都可以用最小瓶颈树实现复杂度最小"><a href="#两题有异曲同工之妙a…（-滑稽，思路差不多…）都可以用最小瓶颈树实现复杂度最小" class="headerlink" title="两题有异曲同工之妙a…（/滑稽，思路差不多…）都可以用最小瓶颈树实现复杂度最小"></a>两题有异曲同工之妙a…（/滑稽，思路差不多…）都可以用最小瓶颈树实现复杂度最小</h3><p>下面上一下t2的代码：（没有用最小瓶颈树优化，逃）</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cmath&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cctype&gt;</span></span><br><span class="line"><span class="comment">#include&lt;set&gt;</span></span><br><span class="line"><span class="comment">#include&lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include&lt;map&gt;</span></span><br><span class="line"><span class="comment">#include&lt;queue&gt;</span></span><br><span class="line"><span class="comment">#define maxn 505</span></span><br><span class="line">using namespace std;</span><br><span class="line">struct eage&#123;</span><br><span class="line">    int u,v;</span><br><span class="line">    double dist;</span><br><span class="line">&#125;e[maxn*maxn/<span class="number">2</span>+maxn*<span class="number">2</span>];</span><br><span class="line">bool cmp(eage a,eage b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a.dist&lt;b.dist;</span><br><span class="line">&#125;</span><br><span class="line">double dis(int x1,int y1,int x2,int y2)&#123;</span><br><span class="line">    <span class="keyword">return</span> sqrt(<span class="number">1.0</span>*(x1-x2)*(x1-x2)+<span class="number">1.0</span>*(y1-y2)*(y1-y2)); </span><br><span class="line">&#125;</span><br><span class="line">int fa[maxn];</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">    int root=find(fa[x]);</span><br><span class="line">    fa[x]=root;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">void link(int x,int y)&#123;</span><br><span class="line">    int fx=find(x),fy=find(y);</span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)&#123;</span><br><span class="line">        fa[fx]=fy;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">bool check(int x,int y)&#123;</span><br><span class="line">    int fx=find(x),fy=find(y);</span><br><span class="line">    <span class="keyword">if</span>(fx!=fy) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">int l,n;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int x,y;</span><br><span class="line">&#125;nd[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">    int pos=<span class="number">0</span>;</span><br><span class="line">    scanf(<span class="string">"%d%d"</span>,&amp;n,&amp;l);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n+<span class="number">2</span>;i++) fa[i]=i;<span class="regexp">//n</span>+<span class="number">1</span>是上，n+<span class="number">2</span>是下 </span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(<span class="string">"%d%d"</span>,&amp;nd[i].x,&amp;nd[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        e[++pos]=(eage)&#123;i,n+<span class="number">1</span>,l-nd[i].y&#125;;</span><br><span class="line">        e[++pos]=(eage)&#123;i,n+<span class="number">2</span>,nd[i].y&#125;;</span><br><span class="line">    <span class="keyword">for</span>(int j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">        e[++pos]=(eage)&#123;i,j,dis(nd[i].x,nd[i].y,nd[j].x,nd[j].y)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int cnt=<span class="number">0</span>;</span><br><span class="line">    sort(e+<span class="number">1</span>,e+pos+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=pos;i++)&#123;</span><br><span class="line">        int u=e[i].u,v=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(check(u,v)) continue;</span><br><span class="line">        link(u,v);</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span>(find(n+<span class="number">1</span>)==find(n+<span class="number">2</span>))&#123;<span class="regexp">//</span>只要上底和下底连接了就行 这样才能保证极大值可以通过，如果后面更大，那这里是过不了的 </span><br><span class="line">            printf(<span class="string">"%.3f"</span>,e[i].dist);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小瓶颈生成树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>UpdateAfterEvent</title>
      <link href="/2018/10/15/1/"/>
      <url>/2018/10/15/1/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>​       小松鼠打了10个小时的游戏，一脸满足。却发现周围再次围满了游客，逃！</p><p>　　她发现整个西湖内的松鼠都以相同的速度在树之间跳跃。每跳跃一次花费一个单位的时间。我们可以把西湖抽象为一张n个点的无向图，初始时每个点上都有若干只松鼠，它们每单位时间都可以沿着一条无向边进行跳跃。</p><a id="more"></a><p>　　对于一只当前在点i的松鼠，它在接下来的一个单位时间内等概率向相邻的点跳跃。更具体地讲，我们称与点i通过一条无向边直接相连的点为与i相邻的点，假设这样的点有p个，那么对于每一个与i相邻的点，在下一时刻都有1/p的概率跳到它。</p><p>　　超萌小松鼠已知初始时刻（0时刻）每棵树上的松鼠分布情况，她想知道在T时刻，在同一棵树上的松鼠对数的期望。关于“松鼠对数”的解释：假设有4只松鼠在同一棵树上，那么我们称有6对在同一棵树上的松鼠。为了避免精度误差，我们将答案模10^9 + 7输出。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>​          第一行三个数n，T。意义如题面中所述。接下来一行n个数，第i个数ai表示第i个点初始时刻有ai只松鼠。接下来n行，每行n个数，第i行第j个数如果为1表示点i与点j间有无向边相连，为0则表示没有。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>​            输出一行一个数，表示T时刻在同一棵树上的松鼠对数的期望在模10^9 +7意义下的答案。</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>这道题考察了许多知识点，考察综合能力。</p><p>首先，题目总体是考察概率期望，但切忌陷入思路死角，去求每棵树上的最终期望松鼠对数。实际上，我们对于每只松鼠，去求它到某点的概率p,那么每两只松鼠在某点的期望便是p1<em>p2</em>1（还有很多可转化为概率来做的期望题）由于要除法取模，要预先递推求出逆元，复习一下公式：inv[1]=1;inv[i]=(mod-mod/i)*inv[mod%i]%mod. </p><p>那么对于松鼠到某点的概率求取，我们先O(N^2)求出最开始互相连点之间的概率，然后每一时刻，枚举中间点，进行概率传递，由于t比较大，可以用矩阵快速幂思想来将其优化到log2n级别。</p><p>最后，由于我们计算期望是O（n^3）的，无法过n&lt;=1000的点，发现如下式子：</p><p>设p(i,j)为i到j点的概率。假设计算终点在1，则ans=p(1,1)<em>p(2,1)+p(1,1)</em>p(3,1)<em>…..+p(1,1)</em>p(n,1)+p(2,1)<em>p(3,1)+p(2,1)</em>p(4,1)+…….发现可以转化为p(1,1)<em>(p(2,1)+p(3,1)+p(4,1)+….+p(n,1))+p(2,1)</em>(p(3,1)+p(4,1)+…..+p(n,1)).由此发现是可以前缀和优化的，由此只用枚举一点和终点，从而变成O(N^2).当然可以每个统计一次，然后最后除以2.貌似更方便哈…..</p><h1 id="The-Code"><a href="#The-Code" class="headerlink" title="The Code"></a>The Code</h1><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define maxn 1005</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll mod=<span class="number">1</span>e9+<span class="number">7</span>;</span><br><span class="line">struct matrix&#123;</span><br><span class="line">    ll a[maxn][maxn];</span><br><span class="line">&#125;nd,ans;</span><br><span class="line">int n,t,e[maxn][maxn];</span><br><span class="line">matrix operator *(matrix &amp;x,matrix &amp;y)&#123;</span><br><span class="line">    matrix c;</span><br><span class="line">    memset(c.a,<span class="number">0</span>,sizeof(c.a));</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    <span class="keyword">for</span>(int k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        c.a[i][j]=(c.a[i][j]+(x.a[i][k]*y.a[k][j])%mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">void pow(int t)&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++) ans.a[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t&amp;<span class="number">1</span>) ans=ans*nd;<span class="regexp">//</span>最后为<span class="number">1</span> </span><br><span class="line">        nd=nd*nd;</span><br><span class="line">        t/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll p[maxn][maxn],inv[maxn],v[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">    scanf(<span class="string">"%d%d"</span>,&amp;n,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++) scanf(<span class="string">"%lld"</span>,&amp;v[i]);</span><br><span class="line">    inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">2</span>;i&lt;=<span class="number">1000</span>;i++) inv[i]=(mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=n;j++) scanf(<span class="string">"%d"</span>,&amp;e[i][j]);</span><br><span class="line">    memset(nd.a,<span class="number">0</span>,sizeof(nd.a));</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        int res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=n;j++)  res+=e[i][j];</span><br><span class="line">        <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=n;j++)  nd.a[i][j]=inv[res]*e[i][j];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(t&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        pow(t);</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=n;j++) p[i][j]=ans.a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=n;j++) p[i][j]=nd.a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ll calc=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ll t1=<span class="number">0</span>,t2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            ll tt=(p[j][i]*v[j])%mod;</span><br><span class="line">            t1=(t1+tt)%mod;</span><br><span class="line">            t2=(t2+tt*p[j][i])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        calc=(calc+(t1*t1%mod-t2+mod)%mod*inv[<span class="number">2</span>]%mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"%lld"</span>,calc);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> noip模拟赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率期望 </tag>
            
            <tag> 前缀和优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>祎隋</title>
      <link href="/2018/10/14/kk/"/>
      <url>/2018/10/14/kk/</url>
      
        <content type="html"><![CDATA[<h2 id="祎隋如你，春风十里不及你"><a href="#祎隋如你，春风十里不及你" class="headerlink" title="祎隋如你，春风十里不及你"></a>祎隋如你，春风十里不及你</h2><p>《祎隋》</p><p>无需仰首，我已知晓</p><p>那阳光濡缕，和风轻挠</p><a id="more"></a><p>不用回头，我已知晓</p><p>那鲜艳裙摆 ，恬然一笑</p><p>……</p><p>因你自嘲，为你歌声倾倒</p><font size="5" color="pink" face="微软雅黑">附上小鞠美图一张</font><p><img src="/14/kk/小鞠.png" alt="小鞠"></p>]]></content>
      
      
      <categories>
          
          <category> 杂诗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂诗 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>文章分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
  
</search>
