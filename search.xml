<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数对子]]></title>
    <url>%2F2018%2F10%2F16%2F8%2F</url>
    <content type="text"><![CDATA[Description我们定义一个数对 (x,y) 是好的，当且仅当 x≤y，且 x xor y的二进制表示下有奇数个 1 现在给定 nn 个区间 [li,ri]，你需要对于每个 i∈[1,n]，输出有几对好的数 (x,y)满足 x 和 y 都在 [l1,r1]∪[l2,r2]…∪[li,ri]，即两个数都在前 i 个区间的并里 Input第一行一个正整数 n 接下来 n 行每行两个整数 [li,ri]，表示第 i个区间，保证 li≤ri Ouput输出 n 行，第 i行一个整数表示有几对好的数 (x,y) 满足 x,y 都在前 i 个区间的并里 Sample Input3 1 7 3 10 9 20 Sample Output12 25 100 Hint对于 30%30% 的数据，有 1≤n≤1001≤n≤100，1≤li≤ri≤1001≤li≤ri≤100 对于 50%50% 的数据，有 1≤n≤10001≤n≤1000，1≤li≤ri≤232−11≤li≤ri≤232−1 对于 100%100% 的数据，有 1≤n≤1051≤n≤105, 1≤li≤ri≤232−11≤li≤ri≤232−1 时间限制：2s 空间限制：512MB Solutiontips先补充几个小知识点（快速求出一个数的二进制中有多少个1）: x=x&amp;(x-1)（递归求法，适用于单个数） 表达式的意思就是:把x的二进制表示 从低位开始，将遇到的第一个为1的 二进制位 置0。 123int calc=0;while(x) x=x&amp;(x-1),calc++;calc即为所求值 求0到x中有多少二进制含1个数为奇数的： 123456789101112long long calc(long long x)&#123; long long tmp=x,tot=0; while(tmp) &#123; if(tmp&amp;1)tot++; tmp&gt;&gt;=1; &#125; return (x&gt;&gt;1)+((x&amp;1) || (tot&amp;1));&#125;证明：00 01 10 11 100 101 110 111....继续下去可以发现规律是偶奇奇偶奇偶偶奇....所以x&gt;&gt;1之前一半的，如果x为奇数（会少算一个）或其本身有奇数个1得加上 所以说探究性质a老哥(这个性质也可以记住) p.s.当线段树叶子节点有n个时，应开总共2^(log2n+1)个点，即2*n个点 正经题解开始：首先，对于每个数对（x,y）, 若要x xor y的二进制表示下有奇数个 1，则必定一者含奇数个1，一者含偶数个。 证明：若两个都为奇数，1.则奇减奇等于偶（重叠个数为奇个）2.奇减偶先为奇（重叠个数为偶数个），奇加奇等于偶 ​ 若两个都为偶数，则可同上证明 ​ 一奇一偶，1.奇减奇等于偶，偶减奇等于奇，奇加偶等于奇2.奇减偶等于奇，偶减偶等于偶，偶加奇等于奇 所以我们采取线段树来维护区间含奇数个1和含偶数个1的个数，对于区间l,r，则用上述中所介绍的calc函数，来calc(r)-calc(l-1)得到奇数个1个数以及r-l+1-（calc(r)-calc(l-1)）得到偶数个1个数 每次输入一个区间加进去统计一个区间，然后输出总的相乘即可。p.s.线段树很好的解决了区间相交的问题，在以及统计过的区间标记vis[now]=1; 上代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;#define maxn 100005using namespace std;typedef long long ll;ll num[maxn&lt;&lt;4][2];int lc[maxn&lt;&lt;4],rc[maxn&lt;&lt;4],rt=0,np=0;int n;bool vis[maxn&lt;&lt;4];void upload(int now)&#123; num[now][0]=num[lc[now]][0]+num[rc[now]][0]; num[now][1]=num[lc[now]][1]+num[rc[now]][1];&#125;ll calc(ll x)&#123; ll t=x,tot=0; while(t) &#123; if(t&amp;1)tot++; t&gt;&gt;=1; &#125; return (x&gt;&gt;1)+((x&amp;1) || (tot&amp;1));&#125;void update(int &amp;now,ll l,ll r,ll x,ll y)&#123; if(!now) now=++np; if(vis[now]) return; if(l&gt;=x&amp;&amp;r&lt;=y)&#123; num[now][1]=calc(r)-calc(l-1); num[now][0]=r-l+1-num[now][1]; vis[now]=1; return; &#125; ll m=(l+r)&gt;&gt;1; if(y&lt;=m)update(lc[now],l,m,x,y); else if(x&gt;m)update(rc[now],m+1,r,x,y); else&#123; update(lc[now],l,m,x,y); update(rc[now],m+1,r,x,y); &#125; upload(now);&#125;void init()&#123; scanf("%d",&amp;n); ll L,R,mx=1ll&lt;&lt;32; for(int i=1;i&lt;=n;i++)&#123; scanf("%lld%lld",&amp;L,&amp;R); update(rt,1,mx,L,R); printf("%lld\n",num[1][0]*num[1][1]); &#125;&#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>二进制</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[祎隋]]></title>
    <url>%2F2018%2F10%2F16%2F7%2F</url>
    <content type="text"><![CDATA[愿你像个孩子，愿你心生双翼 《祎隋》 青涩 带着年少初识的忐忑 我们相遇了 传奇 三年来我们所追寻的词字 一段故事 从这里轻启 回忆 忘不却从前往事 追不上白驹过隙 再聚 仿佛多年往复 传奇已铸 但我们的故事未完待续 我们的航船才起征途 愿 愿相框里的我们永远闪闪发光 愿你仍是原般模样]]></content>
      <categories>
        <category>杂诗</category>
      </categories>
      <tags>
        <tag>杂诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF351B Jeff and Furik]]></title>
    <url>%2F2018%2F10%2F16%2F6%2F</url>
    <content type="text"><![CDATA[Description给一个1~n的排列p[i]，Jeff先手可以交换任意两个相邻元素，而Furik会有0.5的几率把任意满足p[i] &lt; p[i+1]的p[i]和p[i+1]交换，有0.5的几率把任意满足p[i] &gt; p[i+1]的p[i]和p[i+1]交换，问将整个序列变成升序所需的最小期望步数 Input第一行一整数n表示序列长度，之后一个1~n的排列p[i] (1&lt;=n&lt;=3000) Output输出把整个序列变成升序所需的最小期望步数 Sample Input53 5 2 4 1 Sample Output13.000000 Solution考虑E[i]（i为逆序对个数）的最小期望步数，则E[0]=0,E[1]=1;那么每一次Jeff肯定是交换使逆序对减少一个而Furik则有50%减少一个50%增加一个，故$E[i]=1/2(E[i-2]+1)+1/2(E[i-1+1]+1)$;化简得$E[i]=E[i-2]+4$; 故模拟归并排序求一次逆序对个数便可实现。 Code123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;#define maxn 3005using namespace std;int n,a[maxn],t[maxn];int msort(int l,int r)&#123; if(l==r) return 0; int m=l+r&gt;&gt;1; int t1=msort(l,m); int t2=msort(m+1,r); int t3=0; int i=l,j=m+1,k=l; while(i&lt;=m&amp;&amp;j&lt;=r)&#123; if(a[i]&gt;a[j])&#123; t3+=m-i+1; t[k++]=a[j++]; &#125; else&#123; t[k++]=a[i++];//本来就应该小于 &#125; &#125; while(i&lt;=m) t[k++]=a[i++]; while(j&lt;=r) t[k++]=a[j++]; for(int p=l;p&lt;=r;p++) a[p]=t[p];//调整 return t1+t2+t3; &#125;void init()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); int nd=msort(1,n); if(nd&amp;1)&#123; printf("%lf",(double)(2*nd-1)); &#125; else printf("%lf",(double)2*nd);&#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>概率期望</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卡常数]]></title>
    <url>%2F2018%2F10%2F16%2F5%2F</url>
    <content type="text"><![CDATA[Decription（在十进制下）定义 mn(i) 表示把 i 的各位数字从小到大排序得到的数，mx(i) 表示从大到小得到的数。这里的数是允许有前导零的，比如mn(10000)=00001=1 ， mx(132)=321 等。定义 f(i)=mx(i)−mn(i) 。当然，这里 mx(i) 的定义是要在某个整数 k 位十进制数下的。 卡常数指印度数学家Kaprekar发现的常数 6174 。他发现，任取一个各位数字不全相同的四位数 x，不断地使 x=f(x) ，最终总能得到 6174 。 现在Fizzydavid学习了高级的卡常数技巧，他想知道对于五位数的情况。他每次会给你一个带前导零的五位数x，要让你求出操作 x=f(x) 进行 c 次之后的结果。他每次给你的 c 都是一样的。此时 f 定义中的 k=5。 Input第一行两个整数 T,c 。T 表示询问次数，c 的含义如题面。 接下来 T 行每行一个五位数 x ，不足五位会加前导零补到五位。 Output对于每个询问输出一行表示答案。不足五位需要补到五位。 Hint1≤T≤105,1≤c≤109,0≤x&lt;105 。 20%的数据保证 c≤10 。 另外20%的数据保证 T≤10 。 另外30%的数据保证 c≥105 。 时间限制： 2s 空间限制： 512MB Solutionwoc这道题思路很Nice啊。首先会想到肯定每个数进行一定次数之后会循环(不然就没法做了a)。然后这里应该要想到我们对当前的数求循环的时候，我们事实上已经对所有经过的数求出来了，这样稍微处理一下就可以保证每个数只被访问一次。但这样还是会T a。。。于是探究性质：发现对于一个x进行a+b次操作等于先将x进行a次操作，再进行b次操作，或者反过来，再进一步想到可以倍增预处理(Nice啊).这样就欧克了a(注意倍增不要写错a在刷状态的时候QAQ) tips1.以后遇到这种性质都可以考虑倍增(LCA也有这种性质嘛)2.补充一下姿势（雾%nd 输出的整型宽度至少为n位，右对齐，%5d即宽度至少为5位，位数大于5则输出实际位数%0nd 用得比较多，表示输出的整型宽度至少为n位，不足n位用0填充printf（”%05d”,1）输出：00001printf（”%5d”,1）输出：**1（$*$为空格） The Code12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;#define maxn 100005using namespace std;int n,x,c;int g[100005][31],mx,mn,a[7];int cmp(int x,int y)&#123; return x&gt;y;&#125;int f(int x)&#123; memset(a,0,sizeof(a)); int pos=6; while(x)&#123; a[--pos]=x%10;x/=10; &#125; sort(a+1,a+6);mn=a[1]*10000+a[2]*1000+a[3]*100+a[4]*10+a[5]; sort(a+1,a+6,cmp);mx=a[1]*10000+a[2]*1000+a[3]*100+a[4]*10+a[5]; return mx-mn;&#125;void pre()&#123; for(int i=0;i&lt;=99999;i++) g[i][0]=f(i); for(int j=1;j&lt;=30;j++) for(int i=0;i&lt;=99999;i++) g[i][j]=g[g[i][j-1]][j-1]; &#125;bool vis[31];void init()&#123; scanf("%d%d",&amp;n,&amp;c); for(int i=0;i&lt;=30;i++) if(c&amp;(1&lt;&lt;i)) vis[i]=1; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;x); for(int j=0;j&lt;=30;j++) if(vis[j]) x=g[x][j]; printf("%05d\n",x); &#125;&#125;int main()&#123; pre(); init(); return 0;&#125;]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>倍增</tag>
        <tag>预处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树]]></title>
    <url>%2F2018%2F10%2F16%2F4%2F</url>
    <content type="text"><![CDATA[The Solutionemmmmmmmm，这道题题意读错了a，有点难受…很考细节的一道题，同时告诉我们细节题要对拍。首先我们要维护的是最大的剩余空间，但实质上是最大的最近距离，比如区间所剩为5和4，实际上它们的最近距离都为2。在设定友好函数时要注意。在处理好一般操作之后是特判，主要就是对于两端的处理，因为它们是独立成段的(图中红色部分)，所以只要红色长度大于最近距离即更优。最后要注意标号尽可能小的细节。 The Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;bits/stdc++.h&gt;#define maxn 200005using namespace std;struct node&#123; int l,r; friend bool operator &lt;(node a,node b)&#123; if((a.r-a.l)/2!=(b.r-b.l)/2)return (a.r-a.l)/2&gt;(b.r-b.l)/2; //排得是这个最近距离aQAQ 并且不能将2免去，因为奇偶 else return a.l&lt;b.l; &#125;&#125;;set&lt;node&gt;s;set&lt;node&gt;::iterator it;int n,m,x,y;map&lt;int,int&gt;mp;int pre[maxn],next[maxn],st[maxn],rk[maxn];int np=0; void init()&#123; scanf("%d%d",&amp;n,&amp;m); s.insert((node)&#123;0,n+1&#125;); pre[0]=0;next[0]=n+1;pre[n+1]=0;next[n+1]=n+1; for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d",&amp;x,&amp;y); /*if(x==1)&#123; if(t.l==0&amp;&amp;t.r==n+1)&#123; st[np]=1; rk[1]=np; next[0]=1; next[1]=n+1; pre[n+1]=1; s.erase((node)&#123;0,n+1&#125;); s.insert((node)&#123;0,1&#125;);s.insert((node)&#123;1,n+1&#125;); printf("1\n");continue; &#125; if(t.l==1&amp;&amp;t.r==n+1)&#123; st[np]=n; rk[n]=np; pre[n]=1; next[n]=n+1; pre[n+1]=n; next[0]=1; s.erase((node)&#123;1,n+1&#125;); s.insert((node)&#123;1,n&#125;);s.insert((node)&#123;n,n+1&#125;); printf("%d\n",n);continue; &#125;*/ if(x==1)&#123; mp[y]=++np; it=s.begin(); node t=*it; int len=(t.r-t.l)/2; bool ok1=false,ok2=false; int len1=0,len2=0; if(!rk[1]) len1=next[0]-1;if(!rk[n]) len2=n-pre[n+1]; if(len2&gt;len1) ok2=true;else ok1=true;//标号 if(!rk[1]&amp;&amp;ok1)&#123;//要考虑两端点的问题 if(next[0]-1&gt;=len)&#123;//标号优先 st[np]=1; rk[1]=np; next[1]=next[0];pre[next[0]]=1;next[0]=1; s.erase((node)&#123;0,next[1]&#125;); s.insert((node)&#123;0,1&#125;); s.insert((node)&#123;1,next[1]&#125;); printf("1\n");continue; &#125; &#125; if(!rk[n]&amp;&amp;ok2)&#123; if(n-pre[n+1]&gt;len)&#123; st[np]=n; rk[n]=np; pre[n]=pre[n+1];next[pre[n+1]]=n;pre[n+1]=n; s.erase((node)&#123;pre[n],n+1&#125;); s.insert((node)&#123;n,n+1&#125;); s.insert((node)&#123;pre[n],n&#125;); printf("%d\n",n);continue; &#125; &#125; int position=t.l+len;rk[position]=np;st[np]=position; pre[position]=t.l;next[position]=t.r;pre[t.r]=position; next[t.l]=position; printf("%d\n",position); s.erase((node)&#123;pre[position],next[position]&#125;); s.insert((node)&#123;pre[position],position&#125;); s.insert((node)&#123;position,next[position]&#125;); &#125; else&#123; int t=st[mp[y]]; s.erase((node)&#123;pre[t],t&#125;); s.erase((node)&#123;t,next[t]&#125;); s.insert((node)&#123;pre[t],next[t]&#125;); rk[t]=0; next[pre[t]]=next[t]; pre[next[t]]=pre[t]; pre[t]=next[t]=0; &#125; &#125;&#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>set</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[减肥计划]]></title>
    <url>%2F2018%2F10%2F15%2F3%2F</url>
    <content type="text"><![CDATA[Solution哇，这道题还是太急了，探究出个性质就直接溜了。首先当$\sum{a_i}$一定时，$\sum{b_i}$越大肯定越优，那么可以dp[i]表示$\sum{a_i}$为i时最大的$\sum{b_i}$之值。由于a的和为$nmax({a_i})$，所以总的复杂度会是$n^2max({a_i})$。显然会超时。所以我们来探求性质，发现当答案为$\frac{\sum{a_i}}{\sum{b_i}}$，若此时有$\frac{a_i}{b_i}$大于它时，那么加入一定会增大，反之加入小于的会减小，所以我们对于一个答案，不断删去小于它的$\frac{a_i}{b_i}$，直到$\sum{a_i}$&lt;m后停下来，那么过程中不会减小，此时再加入大于的即可，所以最多只用dp到$max({a_i})+m$，因此时间复杂度也降为$n*(m+max({a_i}))​$ ，即可通过此题。 上代码： Code123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;queue&gt;#define maxn 10000005using namespace std;typedef long long ll;int n,m;ll dp[maxn&lt;&lt;1],a[maxn],b[maxn];ll gcd(ll x,ll y)&#123; if(y==0) return x; else return gcd(y,x%y);&#125;ll maxx=0,sum=0;void init()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;a[i],&amp;b[i]),maxx=max(maxx,a[i]),sum+=a[i]; if(sum&lt;m)&#123;printf("-1");return;&#125; for(int i=1;i&lt;=m+maxx;i++) dp[i]=-0x3f3f3f3f; dp[0]=0; for(int i=1;i&lt;=n;i++) for(int j=maxx+m;j&gt;=a[i];j--) dp[j]=max(dp[j],dp[j-a[i]]+b[i]); ll fz=-1,fm=1; for(int i=m;i&lt;=maxx+m;i++) if(fz*i&lt;dp[i]*fm) fz=dp[i],fm=i; ll g=gcd(fz,fm); fz/=g;fm/=g; printf("%d/%d",fz,fm); &#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>正睿</tag>
        <tag>dp</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小瓶颈生成树]]></title>
    <url>%2F2018%2F10%2F15%2F2%2F</url>
    <content type="text"><![CDATA[所谓最小瓶颈生成树….就是使得生成树树上最大边权值最小。这里主要介绍一种期望O（M）（线性）的求法，其实主要就是二分，具体思路如下： 类比找第k大值的方法，首先随机一个边权w。 然后将不超过这个边权的边加入，遍历这张图。 如果图连通，那么瓶颈不超过w，于是只需考虑边权不超过w的边。 否则将这些连通点缩起来，考虑边权大于w的边。 每次将问题的规模缩小至一半。 期望时间复杂度O(m)。 相关例题有两道：A.Hangar Hurdles (CERC 16) 有一个n*n的网格图，上面有些格子可行，有些格子是障碍。 有Q个询问，想把一个正方形箱子从(r1,c1)推到(r2,c2)，问箱子最大的大小。（起点终点是正方形箱子的中点） N&lt;=1000 Q&lt;=300000 B.洪蛤吨有一个宽度为L的管道，我们可以视其为一条y=L的直线与X轴所夹的部分。 （所以这根管道的长度可以视为正无穷） 这个管道中有个N个障碍点，第i个障碍点的坐标为(Xi,Yi)。 已知有一个球体，能在不碰到障碍点的前提下，从管道的最左端走到最右端。（即从管道内横坐标负无穷的地方走到横坐标正无穷的地方）。 求这个球体的直径最大是多少。为了避免精度误差，请输出答案保留三位小数的结果。 两题有异曲同工之妙a…（/滑稽，思路差不多…）都可以用最小瓶颈树实现复杂度最小下面上一下t2的代码：（没有用最小瓶颈树优化，逃） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;queue&gt;#define maxn 505using namespace std;struct eage&#123; int u,v; double dist;&#125;e[maxn*maxn/2+maxn*2];bool cmp(eage a,eage b)&#123; return a.dist&lt;b.dist;&#125;double dis(int x1,int y1,int x2,int y2)&#123; return sqrt(1.0*(x1-x2)*(x1-x2)+1.0*(y1-y2)*(y1-y2)); &#125;int fa[maxn];int find(int x)&#123; if(fa[x]==x) return x; int root=find(fa[x]); fa[x]=root; return root;&#125;void link(int x,int y)&#123; int fx=find(x),fy=find(y); if(fx!=fy)&#123; fa[fx]=fy; &#125; &#125;bool check(int x,int y)&#123; int fx=find(x),fy=find(y); if(fx!=fy) return false; return true;&#125;int l,n;struct node&#123; int x,y;&#125;nd[maxn];void init()&#123; int pos=0; scanf("%d%d",&amp;n,&amp;l); for(int i=1;i&lt;=n+2;i++) fa[i]=i;//n+1是上，n+2是下 for(int i=1;i&lt;=n;i++)&#123; scanf("%d%d",&amp;nd[i].x,&amp;nd[i].y); &#125; for(int i=1;i&lt;=n;i++)&#123; e[++pos]=(eage)&#123;i,n+1,l-nd[i].y&#125;; e[++pos]=(eage)&#123;i,n+2,nd[i].y&#125;; for(int j=i+1;j&lt;=n;j++)&#123; e[++pos]=(eage)&#123;i,j,dis(nd[i].x,nd[i].y,nd[j].x,nd[j].y)&#125;; &#125; &#125; int cnt=0; sort(e+1,e+pos+1,cmp); for(int i=1;i&lt;=pos;i++)&#123; int u=e[i].u,v=e[i].v; if(check(u,v)) continue; link(u,v); cnt++; if(find(n+1)==find(n+2))&#123;//只要上底和下底连接了就行 这样才能保证极大值可以通过，如果后面更大，那这里是过不了的 printf("%.3f",e[i].dist); break; &#125; &#125;&#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>最小瓶颈生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UpdateAfterEvent]]></title>
    <url>%2F2018%2F10%2F15%2F1%2F</url>
    <content type="text"><![CDATA[Description​ 小松鼠打了10个小时的游戏，一脸满足。却发现周围再次围满了游客，逃！ 她发现整个西湖内的松鼠都以相同的速度在树之间跳跃。每跳跃一次花费一个单位的时间。我们可以把西湖抽象为一张n个点的无向图，初始时每个点上都有若干只松鼠，它们每单位时间都可以沿着一条无向边进行跳跃。 对于一只当前在点i的松鼠，它在接下来的一个单位时间内等概率向相邻的点跳跃。更具体地讲，我们称与点i通过一条无向边直接相连的点为与i相邻的点，假设这样的点有p个，那么对于每一个与i相邻的点，在下一时刻都有1/p的概率跳到它。 超萌小松鼠已知初始时刻（0时刻）每棵树上的松鼠分布情况，她想知道在T时刻，在同一棵树上的松鼠对数的期望。关于“松鼠对数”的解释：假设有4只松鼠在同一棵树上，那么我们称有6对在同一棵树上的松鼠。为了避免精度误差，我们将答案模10^9 + 7输出。 Input​ 第一行三个数n，T。意义如题面中所述。接下来一行n个数，第i个数ai表示第i个点初始时刻有ai只松鼠。接下来n行，每行n个数，第i行第j个数如果为1表示点i与点j间有无向边相连，为0则表示没有。 Output​ 输出一行一个数，表示T时刻在同一棵树上的松鼠对数的期望在模10^9 +7意义下的答案。 Solution这道题考察了许多知识点，考察综合能力。 首先，题目总体是考察概率期望，但切忌陷入思路死角，去求每棵树上的最终期望松鼠对数。实际上，我们对于每只松鼠，去求它到某点的概率p,那么每两只松鼠在某点的期望便是p1p21（还有很多可转化为概率来做的期望题）由于要除法取模，要预先递推求出逆元，复习一下公式：inv[1]=1;inv[i]=(mod-mod/i)*inv[mod%i]%mod. 那么对于松鼠到某点的概率求取，我们先O(N^2)求出最开始互相连点之间的概率，然后每一时刻，枚举中间点，进行概率传递，由于t比较大，可以用矩阵快速幂思想来将其优化到log2n级别。 最后，由于我们计算期望是O（n^3）的，无法过n&lt;=1000的点，发现如下式子： 设p(i,j)为i到j点的概率。假设计算终点在1，则ans=p(1,1)p(2,1)+p(1,1)p(3,1)…..+p(1,1)p(n,1)+p(2,1)p(3,1)+p(2,1)p(4,1)+…….发现可以转化为p(1,1)(p(2,1)+p(3,1)+p(4,1)+….+p(n,1))+p(2,1)(p(3,1)+p(4,1)+…..+p(n,1)).由此发现是可以前缀和优化的，由此只用枚举一点和终点，从而变成O(N^2).当然可以每个统计一次，然后最后除以2.貌似更方便哈….. The Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;#define maxn 1005using namespace std;typedef long long ll;const ll mod=1e9+7;struct matrix&#123; ll a[maxn][maxn];&#125;nd,ans;int n,t,e[maxn][maxn];matrix operator *(matrix &amp;x,matrix &amp;y)&#123; matrix c; memset(c.a,0,sizeof(c.a)); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=n;k++)&#123; c.a[i][j]=(c.a[i][j]+(x.a[i][k]*y.a[k][j])%mod)%mod; &#125; return c;&#125;void pow(int t)&#123; for(int i=1;i&lt;=n;i++) ans.a[i][i]=1; while(t)&#123; if(t&amp;1) ans=ans*nd;//最后为1 nd=nd*nd; t/=2; &#125;&#125;ll p[maxn][maxn],inv[maxn],v[maxn];void init()&#123; scanf("%d%d",&amp;n,&amp;t); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;v[i]); inv[1]=1; for(int i=2;i&lt;=1000;i++) inv[i]=(mod-mod/i)*inv[mod%i]%mod; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf("%d",&amp;e[i][j]); memset(nd.a,0,sizeof(nd.a)); for(int i=1;i&lt;=n;i++)&#123; int res=0; for(int j=1;j&lt;=n;j++) res+=e[i][j]; for(int j=1;j&lt;=n;j++) nd.a[i][j]=inv[res]*e[i][j]; &#125; if(t&gt;1)&#123; pow(t); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) p[i][j]=ans.a[i][j]; &#125; else&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) p[i][j]=nd.a[i][j]; &#125; ll calc=0; for(int i=1;i&lt;=n;i++)&#123; ll t1=0,t2=0; for(int j=1;j&lt;=n;j++)&#123; ll tt=(p[j][i]*v[j])%mod; t1=(t1+tt)%mod; t2=(t2+tt*p[j][i])%mod; &#125; calc=(calc+(t1*t1%mod-t2+mod)%mod*inv[2]%mod)%mod; &#125; printf("%lld",calc);&#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>noip模拟赛1</category>
      </categories>
      <tags>
        <tag>概率期望</tag>
        <tag>前缀和优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[祎隋]]></title>
    <url>%2F2018%2F10%2F14%2Fkk%2F</url>
    <content type="text"><![CDATA[祎隋如你，春风十里不及你《祎隋》 无需仰首，我已知晓 那阳光濡缕，和风轻挠 不用回头，我已知晓 那鲜艳裙摆 ，恬然一笑 …… 因你自嘲，为你歌声倾倒 附上小鞠美图一张]]></content>
      <categories>
        <category>杂诗</category>
      </categories>
      <tags>
        <tag>杂诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文章分类]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
