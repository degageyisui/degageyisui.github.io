<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>树</title>
      <link href="/2018/10/16/4/"/>
      <url>/2018/10/16/4/</url>
      
        <content type="html"><![CDATA[<h1 id="The-Solution"><a href="#The-Solution" class="headerlink" title="The Solution"></a>The Solution</h1><p>emmmmmmmm，这道题题意读错了a，有点难受…很考细节的一道题，同时告诉我们细节题要对拍。<br>首先我们要维护的是最大的剩余空间，但实质上是最大的最近距离，比如区间所剩为5和4，实际上它们的最近距离都为2。在设定友好函数时要注意。<br><a id="more"></a><br>在处理好一般操作之后是特判，主要就是对于两端的处理，因为它们是独立成段的(图中红色部分)，所以只要红色长度大于最近距离即更优。<br><img src="/2018/10/16/4/233.jpg" alt="补图"><br>最后要注意标号尽可能小的细节。</p><h1 id="The-Code"><a href="#The-Code" class="headerlink" title="The Code"></a>The Code</h1><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define maxn 200005</span></span><br><span class="line">using namespace std;</span><br><span class="line">struct node&#123;</span><br><span class="line">int l,r;</span><br><span class="line">friend bool operator &lt;(node a,node b)&#123;</span><br><span class="line"><span class="keyword">if</span>((a.r-a.l)/<span class="number">2</span>!=(b.r-b.l)/<span class="number">2</span>)<span class="keyword">return</span> (a.r-a.l)/<span class="number">2</span>&gt;(b.r-b.l)/<span class="number">2</span>;<span class="regexp">//</span>排得是这个最近距离aQAQ 并且不能将<span class="number">2</span>免去，因为奇偶 </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> a.l&lt;b.l;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">set&lt;node&gt;s;</span><br><span class="line">set&lt;node&gt;<span class="symbol">:</span><span class="symbol">:iterator</span> it;</span><br><span class="line">int n,m,x,y;</span><br><span class="line">map&lt;int,int&gt;mp;</span><br><span class="line">int pre[maxn],<span class="keyword">next</span>[maxn],st[maxn],rk[maxn];</span><br><span class="line">int np=<span class="number">0</span>; </span><br><span class="line">void init()&#123;</span><br><span class="line">scanf(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">s.insert((node)&#123;<span class="number">0</span>,n+<span class="number">1</span>&#125;);</span><br><span class="line">pre[<span class="number">0</span>]=<span class="number">0</span>;<span class="keyword">next</span>[<span class="number">0</span>]=n+<span class="number">1</span>;pre[n+<span class="number">1</span>]=<span class="number">0</span>;<span class="keyword">next</span>[n+<span class="number">1</span>]=n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">scanf(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">/*<span class="keyword">if</span>(x==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(t.l==<span class="number">0</span>&amp;&amp;t.r==n+<span class="number">1</span>)&#123;</span><br><span class="line">st[np]=<span class="number">1</span>;</span><br><span class="line">rk[<span class="number">1</span>]=np;</span><br><span class="line"><span class="keyword">next</span>[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">next</span>[<span class="number">1</span>]=n+<span class="number">1</span>;</span><br><span class="line">pre[n+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">s.erase((node)&#123;<span class="number">0</span>,n+<span class="number">1</span>&#125;);</span><br><span class="line">s.insert((node)&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);s.insert((node)&#123;<span class="number">1</span>,n+<span class="number">1</span>&#125;);</span><br><span class="line">printf(<span class="string">"1\n"</span>);continue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t.l==<span class="number">1</span>&amp;&amp;t.r==n+<span class="number">1</span>)&#123;</span><br><span class="line">st[np]=n;</span><br><span class="line">rk[n]=np;</span><br><span class="line">pre[n]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">next</span>[n]=n+<span class="number">1</span>;</span><br><span class="line">pre[n+<span class="number">1</span>]=n;</span><br><span class="line"><span class="keyword">next</span>[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">s.erase((node)&#123;<span class="number">1</span>,n+<span class="number">1</span>&#125;);</span><br><span class="line">s.insert((node)&#123;<span class="number">1</span>,n&#125;);s.insert((node)&#123;n,n+<span class="number">1</span>&#125;);</span><br><span class="line">printf(<span class="string">"%d\n"</span>,n);continue;</span><br><span class="line">&#125;*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">if(x==1)&#123;</span></span><br><span class="line"><span class="regexp">mp[y]=++np;</span></span><br><span class="line"><span class="regexp">it=s.begin();</span></span><br><span class="line"><span class="regexp">node t=*it;</span></span><br><span class="line"><span class="regexp">int len=(t.r-t.l)/</span><span class="number">2</span>;</span><br><span class="line">bool ok1=<span class="literal">false</span>,ok2=<span class="literal">false</span>;</span><br><span class="line">int len1=<span class="number">0</span>,len2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!rk[<span class="number">1</span>]) len1=<span class="keyword">next</span>[<span class="number">0</span>]-<span class="number">1</span>;<span class="keyword">if</span>(!rk[n]) len2=n-pre[n+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(len2&gt;len1) ok2=<span class="literal">true</span>;<span class="keyword">else</span> ok1=<span class="literal">true</span>;<span class="regexp">//</span>标号 </span><br><span class="line"><span class="keyword">if</span>(!rk[<span class="number">1</span>]&amp;&amp;ok1)&#123;<span class="regexp">//</span>要考虑两端点的问题</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">next</span>[<span class="number">0</span>]-<span class="number">1</span>&gt;=len)&#123;<span class="regexp">//</span>标号优先 </span><br><span class="line">st[np]=<span class="number">1</span>;</span><br><span class="line">    rk[<span class="number">1</span>]=np;</span><br><span class="line">    <span class="keyword">next</span>[<span class="number">1</span>]=<span class="keyword">next</span>[<span class="number">0</span>];pre[<span class="keyword">next</span>[<span class="number">0</span>]]=<span class="number">1</span>;<span class="keyword">next</span>[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    s.erase((node)&#123;<span class="number">0</span>,<span class="keyword">next</span>[<span class="number">1</span>]&#125;);</span><br><span class="line">    s.insert((node)&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);s.insert((node)&#123;<span class="number">1</span>,<span class="keyword">next</span>[<span class="number">1</span>]&#125;);</span><br><span class="line">    printf(<span class="string">"1\n"</span>);continue;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!rk[n]&amp;&amp;ok2)&#123;</span><br><span class="line"><span class="keyword">if</span>(n-pre[n+<span class="number">1</span>]&gt;len)&#123;</span><br><span class="line">st[np]=n;</span><br><span class="line">    rk[n]=np;</span><br><span class="line">    pre[n]=pre[n+<span class="number">1</span>];<span class="keyword">next</span>[pre[n+<span class="number">1</span>]]=n;pre[n+<span class="number">1</span>]=n;</span><br><span class="line">    s.erase((node)&#123;pre[n],n+<span class="number">1</span>&#125;);</span><br><span class="line">    s.insert((node)&#123;n,n+<span class="number">1</span>&#125;);s.insert((node)&#123;pre[n],n&#125;);</span><br><span class="line">    printf(<span class="string">"%d\n"</span>,n);continue;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">int position=t.l+len;</span><br><span class="line">rk[position]=np;st[np]=position;pre[position]=t.l;<span class="keyword">next</span>[position]=t.r;pre[t.r]=position;</span><br><span class="line">        <span class="keyword">next</span>[t.l]=position;</span><br><span class="line">printf(<span class="string">"%d\n"</span>,position);</span><br><span class="line">s.erase((node)&#123;pre[position],<span class="keyword">next</span>[position]&#125;); </span><br><span class="line">s.insert((node)&#123;pre[position],position&#125;);s.insert((node)&#123;position,<span class="keyword">next</span>[position]&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">int t=st[mp[y]];</span><br><span class="line">s.erase((node)&#123;pre[t],t&#125;);</span><br><span class="line">s.erase((node)&#123;t,<span class="keyword">next</span>[t]&#125;);</span><br><span class="line">s.insert((node)&#123;pre[t],<span class="keyword">next</span>[t]&#125;);</span><br><span class="line">rk[t]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">next</span>[pre[t]]=<span class="keyword">next</span>[t];</span><br><span class="line">pre[<span class="keyword">next</span>[t]]=pre[t];</span><br><span class="line">pre[t]=<span class="keyword">next</span>[t]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> set </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>减肥计划</title>
      <link href="/2018/10/15/3/"/>
      <url>/2018/10/15/3/</url>
      
        <content type="html"><![CDATA[<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>哇，这道题还是太急了，探究出个性质就直接溜了。<br>首先当$\sum{a_i}$一定时，$\sum{b_i}$越大肯定越优，那么可以dp[i]表示$\sum{a_i}$为i时最大的$\sum{b_i}$之值。<br>由于a的和为$n<em>max({a_i})$，所以总的复杂度会是$n^2</em>max({a_i})$。显然会超时。<br><a id="more"></a><br>所以我们来探求性质，发现当答案为$\frac{\sum{a_i}}{\sum{b_i}}$，若此时有$\frac{a_i}{b_i}$大于它时，那么加入一定会增大，反之加入小于的会减小，所以我们对于一个答案，不断删去小于它的$\frac{a_i}{b_i}$，直到$\sum{a_i}$&lt;m后停下来，那么过程中不会减小，此时再加入大于的即可，所以最多只用dp到$max({a_i})+m$，因此时间复杂度也降为$n*(m+max({a_i}))​$ ，即可通过此题。</p><p>上代码：</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cmath&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cctype&gt;</span></span><br><span class="line"><span class="comment">#include&lt;set&gt;</span></span><br><span class="line"><span class="comment">#include&lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include&lt;map&gt;</span></span><br><span class="line"><span class="comment">#include&lt;queue&gt;</span></span><br><span class="line"><span class="comment">#define maxn 10000005</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int n,m;</span><br><span class="line">ll dp[maxn&lt;&lt;<span class="number">1</span>],a[maxn],b[maxn];</span><br><span class="line">ll gcd(ll x,ll y)&#123;</span><br><span class="line"><span class="keyword">if</span>(y==<span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> gcd(y,x%y);</span><br><span class="line">&#125;</span><br><span class="line">ll maxx=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">void init()&#123;</span><br><span class="line">    scanf(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++) scanf(<span class="string">"%d%d"</span>,&amp;a[i],&amp;b[i]),maxx=max(maxx,a[i]),sum+=a[i];</span><br><span class="line"><span class="keyword">if</span>(sum&lt;m)&#123;printf(<span class="string">"-1"</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=m+maxx;i++) dp[i]=-<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(int j=maxx+m;j&gt;=a[i];j--) dp[j]=max(dp[j],dp[j-a[i]]+b[i]);</span><br><span class="line"></span><br><span class="line">ll fz=-<span class="number">1</span>,fm=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(int i=m;i&lt;=maxx+m;i++) <span class="keyword">if</span>(fz*i&lt;dp[i]*fm) fz=dp[i],fm=i;</span><br><span class="line">ll g=gcd(fz,fm);</span><br><span class="line">fz/=g;fm/=g;</span><br><span class="line">printf(<span class="string">"%d/%d"</span>,fz,fm); </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正睿 </tag>
            
            <tag> dp </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最小瓶颈生成树</title>
      <link href="/2018/10/15/2/"/>
      <url>/2018/10/15/2/</url>
      
        <content type="html"><![CDATA[<h1 id="所谓最小瓶颈生成树…-就是使得生成树树上最大边权值最小。"><a href="#所谓最小瓶颈生成树…-就是使得生成树树上最大边权值最小。" class="headerlink" title="所谓最小瓶颈生成树….就是使得生成树树上最大边权值最小。"></a>所谓最小瓶颈生成树….就是使得生成树树上最大边权值最小。</h1><p>这里主要介绍一种期望O（M）（线性）的求法，其实主要就是二分，具体思路如下：</p><p>类比找第k大值的方法，首先随机一个边权w。</p><p>然后将不超过这个边权的边加入，遍历这张图。</p><p>如果图连通，那么瓶颈不超过w，于是只需考虑边权不超过w的边。</p><a id="more"></a><p>否则将这些连通点缩起来，考虑边权大于w的边。</p><p>每次将问题的规模缩小至一半。</p><p>期望时间复杂度O(m)。</p><h2 id="相关例题有两道："><a href="#相关例题有两道：" class="headerlink" title="相关例题有两道："></a>相关例题有两道：</h2><p>A.Hangar Hurdles (CERC 16)</p><p>有一个n*n的网格图，上面有些格子可行，有些格子是障碍。 有Q个询问，想把一个正方形箱子从(r1,c1)推到(r2,c2)，问箱子最大的大小。（起点终点是正方形箱子的中点） N&lt;=1000 Q&lt;=300000</p><p>B.洪蛤吨有一个宽度为L的管道，我们可以视其为一条y=L的直线与X轴所夹的部分。</p><p>（所以这根管道的长度可以视为正无穷）</p><p>这个管道中有个N个障碍点，第i个障碍点的坐标为(Xi,Yi)。</p><p>已知有一个球体，能在不碰到障碍点的前提下，从管道的最左端走到最右端。（即从管道内横坐标负无穷的地方走到横坐标正无穷的地方）。</p><p>求这个球体的直径最大是多少。为了避免精度误差，请输出答案保留三位小数的结果。</p><h3 id="两题有异曲同工之妙a…（-滑稽，思路差不多…）都可以用最小瓶颈树实现复杂度最小"><a href="#两题有异曲同工之妙a…（-滑稽，思路差不多…）都可以用最小瓶颈树实现复杂度最小" class="headerlink" title="两题有异曲同工之妙a…（/滑稽，思路差不多…）都可以用最小瓶颈树实现复杂度最小"></a>两题有异曲同工之妙a…（/滑稽，思路差不多…）都可以用最小瓶颈树实现复杂度最小</h3><p>下面上一下t2的代码：（没有用最小瓶颈树优化，逃）</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cmath&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cctype&gt;</span></span><br><span class="line"><span class="comment">#include&lt;set&gt;</span></span><br><span class="line"><span class="comment">#include&lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include&lt;map&gt;</span></span><br><span class="line"><span class="comment">#include&lt;queue&gt;</span></span><br><span class="line"><span class="comment">#define maxn 505</span></span><br><span class="line">using namespace std;</span><br><span class="line">struct eage&#123;</span><br><span class="line">    int u,v;</span><br><span class="line">    double dist;</span><br><span class="line">&#125;e[maxn*maxn/<span class="number">2</span>+maxn*<span class="number">2</span>];</span><br><span class="line">bool cmp(eage a,eage b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a.dist&lt;b.dist;</span><br><span class="line">&#125;</span><br><span class="line">double dis(int x1,int y1,int x2,int y2)&#123;</span><br><span class="line">    <span class="keyword">return</span> sqrt(<span class="number">1.0</span>*(x1-x2)*(x1-x2)+<span class="number">1.0</span>*(y1-y2)*(y1-y2)); </span><br><span class="line">&#125;</span><br><span class="line">int fa[maxn];</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">    int root=find(fa[x]);</span><br><span class="line">    fa[x]=root;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">void link(int x,int y)&#123;</span><br><span class="line">    int fx=find(x),fy=find(y);</span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)&#123;</span><br><span class="line">        fa[fx]=fy;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">bool check(int x,int y)&#123;</span><br><span class="line">    int fx=find(x),fy=find(y);</span><br><span class="line">    <span class="keyword">if</span>(fx!=fy) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">int l,n;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int x,y;</span><br><span class="line">&#125;nd[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">    int pos=<span class="number">0</span>;</span><br><span class="line">    scanf(<span class="string">"%d%d"</span>,&amp;n,&amp;l);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n+<span class="number">2</span>;i++) fa[i]=i;<span class="regexp">//n</span>+<span class="number">1</span>是上，n+<span class="number">2</span>是下 </span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(<span class="string">"%d%d"</span>,&amp;nd[i].x,&amp;nd[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        e[++pos]=(eage)&#123;i,n+<span class="number">1</span>,l-nd[i].y&#125;;</span><br><span class="line">        e[++pos]=(eage)&#123;i,n+<span class="number">2</span>,nd[i].y&#125;;</span><br><span class="line">    <span class="keyword">for</span>(int j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">        e[++pos]=(eage)&#123;i,j,dis(nd[i].x,nd[i].y,nd[j].x,nd[j].y)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int cnt=<span class="number">0</span>;</span><br><span class="line">    sort(e+<span class="number">1</span>,e+pos+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=pos;i++)&#123;</span><br><span class="line">        int u=e[i].u,v=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(check(u,v)) continue;</span><br><span class="line">        link(u,v);</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span>(find(n+<span class="number">1</span>)==find(n+<span class="number">2</span>))&#123;<span class="regexp">//</span>只要上底和下底连接了就行 这样才能保证极大值可以通过，如果后面更大，那这里是过不了的 </span><br><span class="line">            printf(<span class="string">"%.3f"</span>,e[i].dist);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小瓶颈生成树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>UpdateAfterEvent</title>
      <link href="/2018/10/15/1/"/>
      <url>/2018/10/15/1/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>​       小松鼠打了10个小时的游戏，一脸满足。却发现周围再次围满了游客，逃！</p><p>　　她发现整个西湖内的松鼠都以相同的速度在树之间跳跃。每跳跃一次花费一个单位的时间。我们可以把西湖抽象为一张n个点的无向图，初始时每个点上都有若干只松鼠，它们每单位时间都可以沿着一条无向边进行跳跃。</p><a id="more"></a><p>　　对于一只当前在点i的松鼠，它在接下来的一个单位时间内等概率向相邻的点跳跃。更具体地讲，我们称与点i通过一条无向边直接相连的点为与i相邻的点，假设这样的点有p个，那么对于每一个与i相邻的点，在下一时刻都有1/p的概率跳到它。</p><p>　　超萌小松鼠已知初始时刻（0时刻）每棵树上的松鼠分布情况，她想知道在T时刻，在同一棵树上的松鼠对数的期望。关于“松鼠对数”的解释：假设有4只松鼠在同一棵树上，那么我们称有6对在同一棵树上的松鼠。为了避免精度误差，我们将答案模10^9 + 7输出。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>​          第一行三个数n，T。意义如题面中所述。接下来一行n个数，第i个数ai表示第i个点初始时刻有ai只松鼠。接下来n行，每行n个数，第i行第j个数如果为1表示点i与点j间有无向边相连，为0则表示没有。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>​            输出一行一个数，表示T时刻在同一棵树上的松鼠对数的期望在模10^9 +7意义下的答案。</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>这道题考察了许多知识点，考察综合能力。</p><p>首先，题目总体是考察概率期望，但切忌陷入思路死角，去求每棵树上的最终期望松鼠对数。实际上，我们对于每只松鼠，去求它到某点的概率p,那么每两只松鼠在某点的期望便是p1<em>p2</em>1（还有很多可转化为概率来做的期望题）由于要除法取模，要预先递推求出逆元，复习一下公式：inv[1]=1;inv[i]=(mod-mod/i)*inv[mod%i]%mod. </p><p>那么对于松鼠到某点的概率求取，我们先O(N^2)求出最开始互相连点之间的概率，然后每一时刻，枚举中间点，进行概率传递，由于t比较大，可以用矩阵快速幂思想来将其优化到log2n级别。</p><p>最后，由于我们计算期望是O（n^3）的，无法过n&lt;=1000的点，发现如下式子：</p><p>设p(i,j)为i到j点的概率。假设计算终点在1，则ans=p(1,1)<em>p(2,1)+p(1,1)</em>p(3,1)<em>…..+p(1,1)</em>p(n,1)+p(2,1)<em>p(3,1)+p(2,1)</em>p(4,1)+…….发现可以转化为p(1,1)<em>(p(2,1)+p(3,1)+p(4,1)+….+p(n,1))+p(2,1)</em>(p(3,1)+p(4,1)+…..+p(n,1)).由此发现是可以前缀和优化的，由此只用枚举一点和终点，从而变成O(N^2).当然可以每个统计一次，然后最后除以2.貌似更方便哈…..</p><h1 id="The-Code"><a href="#The-Code" class="headerlink" title="The Code"></a>The Code</h1><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define maxn 1005</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll mod=<span class="number">1</span>e9+<span class="number">7</span>;</span><br><span class="line">struct matrix&#123;</span><br><span class="line">    ll a[maxn][maxn];</span><br><span class="line">&#125;nd,ans;</span><br><span class="line">int n,t,e[maxn][maxn];</span><br><span class="line">matrix operator *(matrix &amp;x,matrix &amp;y)&#123;</span><br><span class="line">    matrix c;</span><br><span class="line">    memset(c.a,<span class="number">0</span>,sizeof(c.a));</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    <span class="keyword">for</span>(int k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        c.a[i][j]=(c.a[i][j]+(x.a[i][k]*y.a[k][j])%mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">void pow(int t)&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++) ans.a[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t&amp;<span class="number">1</span>) ans=ans*nd;<span class="regexp">//</span>最后为<span class="number">1</span> </span><br><span class="line">        nd=nd*nd;</span><br><span class="line">        t/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll p[maxn][maxn],inv[maxn],v[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line">    scanf(<span class="string">"%d%d"</span>,&amp;n,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++) scanf(<span class="string">"%lld"</span>,&amp;v[i]);</span><br><span class="line">    inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">2</span>;i&lt;=<span class="number">1000</span>;i++) inv[i]=(mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=n;j++) scanf(<span class="string">"%d"</span>,&amp;e[i][j]);</span><br><span class="line">    memset(nd.a,<span class="number">0</span>,sizeof(nd.a));</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        int res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=n;j++)  res+=e[i][j];</span><br><span class="line">        <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=n;j++)  nd.a[i][j]=inv[res]*e[i][j];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(t&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        pow(t);</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=n;j++) p[i][j]=ans.a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=n;j++) p[i][j]=nd.a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ll calc=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ll t1=<span class="number">0</span>,t2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            ll tt=(p[j][i]*v[j])%mod;</span><br><span class="line">            t1=(t1+tt)%mod;</span><br><span class="line">            t2=(t2+tt*p[j][i])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        calc=(calc+(t1*t1%mod-t2+mod)%mod*inv[<span class="number">2</span>]%mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"%lld"</span>,calc);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> noip模拟赛1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率期望 </tag>
            
            <tag> 前缀和优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>祎隋</title>
      <link href="/2018/10/14/kk/"/>
      <url>/2018/10/14/kk/</url>
      
        <content type="html"><![CDATA[<h2 id="祎隋如你，春风十里不及你"><a href="#祎隋如你，春风十里不及你" class="headerlink" title="祎隋如你，春风十里不及你"></a>祎隋如你，春风十里不及你</h2><p>《祎隋》</p><p>无需仰首，我已知晓</p><p>那阳光濡缕，和风轻挠</p><a id="more"></a><p>不用回头，我已知晓</p><p>那鲜艳裙摆 ，恬然一笑</p><p>……</p><p>因你自嘲，为你歌声倾倒</p><font size="5" color="pink" face="微软雅黑">附上小鞠美图一张</font><p><img src="/2018/10/14/kk/小鞠.png" alt="小鞠"></p>]]></content>
      
      
      
    </entry>
    
  
  
    
    <entry>
      <title>文章分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
  
</search>
