<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[小W与面试]]></title>
    <url>%2F2018%2F10%2F23%2F24%2F</url>
    <content type="text"><![CDATA[Desciption小W因为染色的时候算错了一位数，所以自闭了。他决定不再染布了，去找工作。 在面试的时候，面试官问了他这样一个问题： 给定一个长度为 n 的序列 ai，求: $\sum_{ia_j}{a_i\ xor\ a_j}$小W发现他不会做，想求助于你。 Input第一行一个正整数 n。 第二行 n 个整数，表示 $a_i$。 Output一个整数表示答案。 Sample Input22 1 Sample Output3 Hint对于 30% 的数据，满足 n≤5000。 对于 100% 的数据，满足 1≤n≤105,1≤ai≤105。 时间限制：1 s 空间限制：512 MB Solution考虑按位计算贡献，设c[i][j][0/1]表示小于等于i的第j位0/1的个数，用树状数组来维护，从后往前依次加入。 上代码：#include&lt;bits/stdc++.h&gt;#define maxn 100005using namespace std;typedef long long ll;ll c[maxn][20][2],w[20];int n,a[maxn];void ready()&#123; w[0]=1; for(int i=1;i&lt;=17;i++) w[i]=w[i-1]*2;&#125;void update(int x,int d,int f)&#123; while(x&lt;=maxn-5)&#123; c[x][d][f]+=1; x+=(x&amp;-x); &#125;&#125;ll sum(int x,int d,int f)&#123; ll ret=0; while(x&gt;0)&#123; ret+=c[x][d][f]; x-=(x&amp;-x); &#125; return ret*w[d];&#125;void init()&#123; ll ans=0; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=n;i&gt;=1;i--)&#123; for(int j=0;j&lt;=17;j++)&#123; if(a[i]&amp;(1&lt;&lt;j))&#123; ans+=sum(a[i]-1,j,0); update(a[i],j,1); &#125; else&#123; ans+=sum(a[i]-1,j,1); update(a[i],j,0); &#125; &#125; &#125; printf("%lld",ans);&#125; int main()&#123; ready(); init(); return 0;&#125;]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sirni]]></title>
    <url>%2F2018%2F10%2F23%2F23%2F</url>
    <content type="text"><![CDATA[Description有 n 个点，每个点有个权值 p1, p2, . . . , pn。这些点之间两两有边，对于点 i, j，这两个点之间的边权为 min($p_imodp_j,p_jmodp_i$)。问把这些点连通的最小代价和是多少，也就是问这个完全图的最小生成树的边权和。 Input第一行一个正整数 n，接下来 n 行每行一个整数，表示这些点的权值。30% 的数据- n ≤ 103。40% 的数据- pi ≤ 106。100% 的数据- 1 ≤ n ≤ 105, pi ≤ 106。 Output一行表示答案 Sample Input34915 Sample Output4 Hint时间限制：5s空间限制：768MB Solution首先会发现每条边边权为$p_imodp_j (p_i&gt;p_j)$，因为小数模大数为小数，大数模小数小于小数。然后先将点排序离散化去重（相同点权两点之间距离为0），然后从小到大对于每个$p_i$，我们设其值为x，那么会从x-2x,2x-3x……选出一个点连边作为最优值（见图，解释在下）：对于每一段，我们肯定首选第一个大于它的是最小的，如图中x-2x的$p_j$，然后对于$p_k$，我们选择不连边而让$p_j$去连更优，如图中绿色段为$p_j$连$p_k$代价，而蓝色段为x连$p_k$代价，可见前者更优，然后我们一共会连$\sum\lfloor\frac{mx}{p_i}\rfloor$条边，将它放大为调和级数求和$plogp$，所以用kruskal可以$plog^2p$求出…. 然后对于连边直接先预处理每个区间第一个选的，然后O（n）搞好. 上代码： #include&lt;bits/stdc++.h&gt;using namespace std;#define maxn 100005#define maxm 10000005typedef long long ll;int n,a[maxn],nxtt[maxm],pos[maxm],fa[maxn];int find(int x)&#123; if(fa[x]==x) return x; int root=find(fa[x]); fa[x]=root; return root;&#125;bool check(int x,int y)&#123; int fx=find(x),fy=find(y); if(fx!=fy) return false; return true;&#125;void link(int x,int y)&#123; int fx=find(x),fy=find(y); if(fx!=fy)&#123; fa[fx]=fy; &#125;&#125;struct eage&#123; int u,v,len; friend bool operator&lt;(eage a,eage b)&#123; return a.len&lt;b.len; &#125;&#125;e[maxm*4];int np=0;void init()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;i++) fa[i]=i; sort(a+1,a+n+1); int cnt=unique(a+1,a+n+1)-a-1; for(int i=1;i&lt;=cnt;i++) nxtt[a[i]]=a[i],pos[a[i]]=i; for(int i=maxm-2;i&gt;=1;i--) if(!nxtt[i]) nxtt[i]=nxtt[i+1],pos[i]=pos[i+1]; for(int i=1;i&lt;cnt;i++)&#123; e[++np]=(eage)&#123;i,i+1,a[i+1]%a[i]&#125;;//过掉x for(int j=2*a[i];j&lt;maxm;j+=a[i])&#123;//从2x开始找 if(!nxtt[j]) break;//后面没有了 if(nxtt[j]&gt;=j+a[i]) continue; e[++np]=(eage)&#123;i,pos[nxtt[j]],nxtt[j]%a[i]&#125;; &#125; &#125; sort(e+1,e+np+1); int calc=0;ll ans=0; for(int i=1;i&lt;=np;i++)&#123; int u=e[i].u,v=e[i].v;ll c=e[i].len; if(check(u,v)) continue; link(u,v); calc++; ans+=c; if(calc==cnt-1)&#123;printf("%lld",ans);return;&#125; &#125; &#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
        <tag>调和级数</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Poklon]]></title>
    <url>%2F2018%2F10%2F23%2F22%2F</url>
    <content type="text"><![CDATA[Description有一个长度为 n 的序列，每个数的范围在 0 到 $10^9$ 之内。你有 Q 个询问，给出 l, r，问这个序列中区间 l 到 r 中恰好出现了两次的数字的个数。序列的下标从 1 开始。 Input第一行两个整数 n 和 Q，接下来一行 n 个整数，表示这个序列。接下来 Q 行，每行两个整数 l, r 表示询问的区间。40% 的数据- n, Q ≤ 5000。100% 的数据-1 ≤ n, Q ≤ 500000。 OutputQ 行，每行一个整数表示答案 Sample Input5 21 1 2 2 31 11 5 Sample Output02 Hint时间限制：5s空间限制：512MB Solution正解貌似是二维树状数组？？？没听懂orz。。。思想跟以前一道很类似，记录每一个数前面一个相同的和后面一个相同的，当区间包含l[i],i或i,r[i]时就会有贡献,从而以l为横轴,r为竖轴建立坐标系，每次修改就是一块矩形的加1，然后查询就对于(l,r)的点值。 ~~有时间一定要了解下qwq~~ 然后貌似用莫队可以随随便便过，直接开始离散化一下，然后莫队一波就欧克了，O($n\sqrt{n}$)还是能过的。 上代码：#include&lt;bits/stdc++.h&gt;#define maxn 500005using namespace std;int n,q,a[maxn],blog[maxn],t[maxn],c[maxn];int calc=0;struct node&#123; int l,r,id,ans; friend bool operator &lt;(node a,node b)&#123; if(blog[a.l]==blog[b.l]) return a.r&lt;b.r; else return a.l&lt;b.l; &#125;&#125;nd[maxn];bool cmp(node a,node b)&#123; return a.id&lt;b.id;&#125;void update1(int i)&#123; c[a[i]]--; if(c[a[i]]==1) calc--; if(c[a[i]]==2) calc++;&#125;void update2(int i)&#123; c[a[i]]++; if(c[a[i]]==2) calc++; if(c[a[i]]==3) calc--;&#125;void init()&#123; scanf("%d%d",&amp;n,&amp;q); int blo=sqrt(n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]),blog[i]=(i-1)/blo+1,t[i]=a[i]; sort(t+1,t+n+1); int cnt=unique(t+1,t+n+1)-t-1; for(int i=1;i&lt;=n;i++)&#123; a[i]=lower_bound(t+1,t+cnt+1,a[i])-t; &#125; for(int i=1;i&lt;=q;i++) scanf("%d%d",&amp;nd[i].l,&amp;nd[i].r),nd[i].id=i; sort(nd+1,nd+q+1); int l=1,r=0; for(int i=1;i&lt;=q;i++)&#123; while(l&lt;nd[i].l) update1(l),l++; while(r&gt;nd[i].r) update1(r),r--; while(l&gt;nd[i].l) update2(l-1),l--; while(r&lt;nd[i].r) update2(r+1),r++; nd[i].ans=calc; &#125; sort(nd+1,nd+q+1,cmp); for(int i=1;i&lt;=q;i++) printf("%d\n",nd[i].ans); &#125;int main()&#123; init(); return 0; &#125;]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>二维树状数组</tag>
        <tag>莫队</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Igra]]></title>
    <url>%2F2018%2F10%2F23%2F21%2F</url>
    <content type="text"><![CDATA[DescriptionAlice 和 Bob 在玩游戏。 Alice 和 “Bob 各写了一个长度为 n 的由小写字母 abc 构成的串。Alice 想把她的串中的字符打乱，对于任意的 B， Alice 串中的第 i 位和 Bob 串中的对应位置不同。Alice 想要知道字典序最小的这样的串是什么，数据保证有有解. Input第一行包含一个正整数 n。接下来两行每行一个长度为 n 的字符串，表示 Alice 和 Bob 手中的串。40W 的数据- n ≤ 20。100W 的数据- 1 ≤ n ≤ 5000 Output一行一个串，表示 Alice 想要找的串。 Sample Input5baaacabcba Sample Outputbaaac Hint时间限制：2s空间限制：512MB Solution这道题…..要用到hall定理，要求字符串A和B完全匹配，所以我们对于A和B中abc字符的量要求满足：$A_a&lt;=B_b+B_c$$A_b&lt;=B_a+B_c$$A_c&lt;=B_a+B_b$简单想一想就会发现如果大于那么a就必须与一个a匹配，所以时刻应满足这个，然后应用贪心策略，在满足条件情况下选字典序最小的（要注意坑点$A_a,A_b,A_c&gt;=0$） 上代码：#include&lt;bits/stdc++.h&gt;#define maxn 5005using namespace std;int n;char s[maxn],ss[maxn];int a[4],b[4];bool check()&#123; if(a[1]&lt;=b[2]+b[3]&amp;&amp;a[2]&lt;=b[1]+b[3]&amp;&amp;a[3]&lt;=b[1]+b[2]) return true; return false;&#125;void init()&#123; scanf("%d",&amp;n); scanf("%s",s+1); for(int i=1;i&lt;=n;i++) a[s[i]-'a'+1]++; scanf("%s",ss+1); for(int i=1;i&lt;=n;i++) b[ss[i]-'a'+1]++; for(int i=1;i&lt;=n;i++)&#123; if(ss[i]=='a')&#123; a[2]--;b[1]--; bool ok=check(); if(a[2]&lt;0) ok=false; if(ok) printf("b"); else&#123; a[2]++;a[3]--;printf("c"); &#125; &#125; else if(ss[i]=='b')&#123; a[1]--;b[2]--; bool ok=check(); if(a[1]&lt;0) ok=false; if(ok) printf("a"); else&#123; a[1]++;a[3]--;printf("c"); &#125; &#125; else if(ss[i]=='c')&#123; a[1]--;b[3]--; bool ok=check(); if(a[1]&lt;0) ok=false; if(ok) printf("a"); else&#123; a[1]++;a[2]--;printf("b"); &#125; &#125; &#125;&#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>Hall定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小W与卖酒]]></title>
    <url>%2F2018%2F10%2F22%2F20%2F</url>
    <content type="text"><![CDATA[Description小W因为没做出上面那题，没能通过面试。他决定改行卖酒。 他有 n 个容器，每个容器的容积是 ai。他没有其它测量工具，只知道每个容器的容积。 他还有一个大小无限的容器，他想知道他能否在这个容器中倒出 x 体积的酒。他可能有多次询问。 例如他有 2 个容器，大小分别是 3,5，那么他能够倒出 2 体积的酒，因为他可以先把第二个容器填满，然后用第二个容器的酒往第一个容器里倒，直到把第一个容器倒满，那么第二个容器剩下的体积就是 2。最后再把这些酒倒进那个大小无限的容器，就倒出了 2 体积的酒。 Input第一行两个正整数 n, q。 第二行 n 个整数，表示 ai。 接下来 q 行，每行一个整数 x，表示一次询问。 Output输出 q 行，每行 YES 或者 NO 表示对应询问的答案。 Sample Input2 24 612 Sample OutputNOYES Hint对于 10% 的数据，满足 n,q≤5,ai,x≤5。 对于 20% 的数据，满足 n,q≤10,ai,x≤10。 对于 50% 的数据，满足 ai,x≤105。 对于 100% 的数据，满足 1≤n,q≤105,1≤ai,x≤109。 时间限制：1 s 空间限制：512 MB Solution我靠大佬们都是一眼秒a…这好像是个啥子结论，用裴蜀定理证明，然鹅不会….主要求出$g=gcd(a_i)​$，然后对于每一个倒的水量x，若g是x的因数（能被x整除）则x可以倒出…记着吧233333 上代码：#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt; using namespace std;int n,m,g,x;int gcd(int x,int y)&#123; if(y==0) return x; else return gcd(y,x%y);&#125;void init()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;g); for(int i=2;i&lt;=n;i++)&#123; scanf("%d",&amp;x); g=gcd(g,x); &#125; for(int i=1;i&lt;=m;i++)&#123; scanf("%d",&amp;x); if(x%g==0) printf("YES\n"); else printf("NO\n"); &#125;&#125;int main()&#123; //freopen("1.in","r",stdin); //freopen("1.out","w",stdout); init(); return 0;&#125;]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>裴蜀定理</tag>
        <tag>结论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJOI2006 书架]]></title>
    <url>%2F2018%2F10%2F22%2F19%2F</url>
    <content type="text"><![CDATA[Description小T有一个很大的书柜。这个书柜的构造有些独特，即书柜里的书是从上至下堆放成一列。她用1到n的正整数给每本书都编了号。 小T在看书的时候，每次取出一本书，看完后放回书柜然后再拿下一本。由于这些书太有吸引力了，所以她看完后常常会忘记原来是放在书柜的什么位置。不过小T的记忆力是非常好的，所以每次放书的时候至少能够将那本书放在拿出来时的位置附近，比如说她拿的时候这本书上面有X本书，那么放回去时这本书上面就只可能有X-1、X或X+1本书。 当然也有特殊情况，比如在看书的时候突然电话响了或者有朋友来访。这时候粗心的小T会随手把书放在书柜里所有书的最上面或者最下面，然后转身离开。 久而久之，小T的书柜里的书的顺序就会越来越乱，找到特定的编号的书就变得越来越困难。于是她想请你帮她编写一个图书管理程序，处理她看书时的一些操作，以及回答她的两个提问：(1)编号为X的书在书柜的什么位置；(2)从上到下第i本书的编号是多少。 Input第一行有两个数n，m，分别表示书的个数以及命令的条数；第二行为n个正整数：第i个数表示初始时从上至下第i个位置放置的书的编号；第三行到m+2行，每行一条命令。命令有5种形式： 1． Top S——表示把编号为S的书放在最上面。 2． Bottom S——表示把编号为S的书放在最下面。 3． Insert S T——T∈{-1，0，1}，若编号为S的书上面有X本书，则这条命令表示把这本书放回去后它的上面有X+T本书； 4． Ask S——询问编号为S的书的上面目前有多少本书。 5． Query S——询问从上面数起的第S本书的编号。 Output对于每一条Ask或Query语句你应该输出一行，一个数，代表询问的答案。 Sample Input10 101 3 2 7 5 8 10 4 9 6Query 3Top 5Ask 6Bottom 3Ask 3Top 6Insert 4 -1Query 5Query 2Ask 2 Sample Output299753 Hint100%的数据，n,m &lt;= 80000 Solution一道裸的线段平衡树题a…..先上一波权值平衡树的板子（实际操作中可以按情况修改）#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;climits&gt;using namespace std;#define maxn 1000000+5 int fa[maxn],ch[maxn][2],sz[maxn],cnt[maxn],val[maxn];int rt=0,np=0;bool check(int x)&#123;return ch[fa[x]][1]==x;&#125;void link(int x,int y,bool kind)&#123; fa[x]=y;ch[y][kind]=x;&#125;void upload(int x)&#123; sz[x]=sz[ch[x][0]]+sz[ch[x][1]]+cnt[x];&#125;void rotate(int x)&#123; int y=fa[x],z=fa[y]; bool kind=check(x); int k=ch[x][!kind]; link(k,y,kind); link(x,z,check(y)); link(y,x,!kind); upload(y);upload(x); &#125;void splay(int x,int goal)&#123; while(fa[x]!=goal)&#123; int y=fa[x],z=fa[y]; if(z!=goal) (check(x)^check(y))?rotate(x):rotate(y); rotate(x); &#125; if(fa[x]==0) rt=x;&#125;void find(int x)&#123; int now=rt; while(ch[now][x&gt;val[now]]&amp;&amp;val[now]!=x) now=ch[now][x&gt;val[now]]; splay(now,0); &#125;void insert(int x)&#123; int now=rt,f=0; while(now&amp;&amp;val[now]!=x) f=now,now=ch[now][x&gt;val[now]]; if(now) cnt[now]++; else&#123; now=++np; val[now]=x; if(f) ch[f][x&gt;val[f]]=now; fa[now]=f; cnt[now]=1; &#125; splay(now,0);&#125;int prnx(int x,bool f)&#123; find(x); int now=rt; if(val[now]&gt;x&amp;&amp;f||val[now]&lt;x&amp;&amp;!f) return now; now=ch[now][f]; while(ch[now][!f]) now=ch[now][!f]; return now; &#125;void del(int x)&#123; int pre=prnx(x,0),last=prnx(x,1); splay(pre,0);splay(last,pre); int delt=ch[last][0]; if(cnt[delt])&#123;cnt[delt]--;splay(delt,0);&#125; else&#123; ch[last][0]=0;splay(last,0); &#125;&#125;int kth(int now,int k)&#123; if(k&lt;=sz[ch[now][0]]) return kth(ch[now][0],k); if(sz[ch[now][0]]+cnt[now]&lt;k) return kth(ch[now][1],k-sz[ch[now][0]]-cnt[now]); splay(now,0); return val[now];&#125;int kth(int x)&#123; int now=rt,ans=0; while(1)&#123; if(x&lt;val[now]) now=ch[now][0]; else&#123; ans+=ch[now][0]?sz[ch[now][0]]:0; if(val[now]==x)&#123;splay(now,0);return ans+1;&#125; ans+=cnt[now]; now=ch[now][1]; &#125; &#125;&#125;int main()&#123; insert(INT_MIN); insert(INT_MAX); for(int i=1;i&lt;=50000;i++) insert(i); for(int i=1;i&lt;=50000;i++) kth(rt,i); return 0;&#125; 这道题是线段平衡树，对于每个操作画下图，想一下就欧克了，没什么好说的….. 上代码：#include&lt;bits/stdc++.h&gt;using namespace std;#define maxn 80005int n,m,np=0,rt=0;int fa[maxn],ch[maxn][2],sz[maxn];int val[maxn],rk[maxn];bool check(int x)&#123;return ch[fa[x]][1]==x;&#125;void link(int x,int y,bool kind)&#123; fa[x]=y;ch[y][kind]=x;&#125;void upload(int x)&#123; sz[x]=sz[ch[x][0]]+sz[ch[x][1]]+1;&#125;void rotate(int x)&#123; int y=fa[x]; int z=fa[y]; bool kind=check(x); int k=ch[x][!kind]; link(k,y,kind); link(x,z,check(y)); link(y,x,!kind); upload(y);upload(x); &#125;void splay(int x,int goal)&#123; while(fa[x]!=goal)&#123; int y=fa[x],z=fa[y]; if(z!=goal) (check(x)^check(y))?rotate(x):rotate(y); rotate(x); &#125; if(fa[x]==0) rt=x;&#125;void insert(int x)&#123; int now=rt,f=0; while(now) f=now,now=ch[now][1]; now=++np; link(now,f,1); splay(now,0);&#125;int nxt(int x,bool f)&#123;//前提要将x旋转到根 x=ch[x][f]; while(ch[x][!f]) x=ch[x][!f]; return x;&#125;void del(int x)&#123; splay(x,0); int pre=nxt(x,0),nxtt=nxt(x,1); splay(pre,0);splay(nxtt,pre); ch[nxtt][0]=0;splay(nxtt,0);&#125;int kth(int now,int k)&#123; if(k&lt;=sz[ch[now][0]]) return kth(ch[now][0],k); if(sz[ch[now][0]]+1&lt;k) return kth(ch[now][1],k-sz[ch[now][0]]-1); return now;&#125; int s,k;char op[10];void init()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=2;i&lt;=n+1;i++) scanf("%d",&amp;val[i]),rk[val[i]]=i; for(int i=1;i&lt;=n+2;i++) insert(i); for(int i=1;i&lt;=m;i++)&#123; scanf("%s",op); if(op[0]=='T')&#123; scanf("%d",&amp;s); int t=rk[s]; del(t); /*splay(1,0); int nxtt=nxt(1,1); splay(nxtt,0);splay(1,nxtt); link(t,1,1); splay(t,0);*/ splay(1,0); int nxtt=nxt(1,1); splay(nxtt,1); link(t,nxtt,0); splay(t,0); &#125; else if(op[0]=='B')&#123; scanf("%d",&amp;s); int t=rk[s]; del(t); /*splay(n+2,0); int pre=nxt(n+2,0); splay(pre,0);splay(n+2,pre); link(t,n+2,0); splay(t,0);*/ splay(n+2,0); int pre=nxt(n+2,0); splay(pre,n+2); link(t,pre,1); splay(t,0); &#125; else if(op[0]=='I')&#123; scanf("%d%d",&amp;s,&amp;k); if(k==0) continue; int t=rk[s]; splay(t,0); if(k==1)&#123; int nxtt=nxt(t,1); swap(rk[val[t]],rk[val[nxtt]]); swap(val[t],val[nxtt]); &#125; else&#123; int nxtt=nxt(t,0); swap(rk[val[t]],rk[val[nxtt]]); swap(val[t],val[nxtt]); &#125; &#125; else if(op[0]=='A')&#123; scanf("%d",&amp;s); int t=rk[s]; splay(t,0); printf("%d\n",sz[ch[t][0]]-1);//减去最开始加入的1 &#125; else if(op[0]=='Q')&#123; scanf("%d",&amp;s); printf("%d\n",val[kth(rt,s+1)]);//减去1 &#125; &#125;&#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>noip模拟赛</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SCOI2011 糖果]]></title>
    <url>%2F2018%2F10%2F22%2F18%2F</url>
    <content type="text"><![CDATA[Description幼儿园里有N个小朋友，lxhgww老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。但是小朋友们也有嫉妒心，总是会提出一些要求，比如小明不希望小红分到的糖果比他的多，于是在分配糖果的时候，lxhgww需要满足小朋友们的K个要求。幼儿园的糖果总是有限的，lxhgww想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求。 Input输入的第一行是两个整数N，K。接下来K行，表示这些点需要满足的关系，每行3个数字，X，A，B。如果X=1， 表示第A个小朋友分到的糖果必须和第B个小朋友分到的糖果一样多；如果X=2， 表示第A个小朋友分到的糖果必须少于第B个小朋友分到的糖果；如果X=3， 表示第A个小朋友分到的糖果必须不少于第B个小朋友分到的糖果；如果X=4， 表示第A个小朋友分到的糖果必须多于第B个小朋友分到的糖果；如果X=5， 表示第A个小朋友分到的糖果必须不多于第B个小朋友分到的糖果； Output输出一行，表示lxhgww老师至少需要准备的糖果数，如果不能满足小朋友们的所有要求，就输出-1。 Sample Input5 71 1 22 3 24 4 13 4 55 4 52 3 54 5 1 Sample Output11 Hint11说明【数据范围】 对于30%的数据，保证 N&lt;=100 对于100%的数据，保证 N&lt;=100000 对于所有的数据，保证 K&lt;=100000，1&lt;=X&lt;=5，1&lt;=A, B&lt;=N Solution首先，这道题要看出是一个差分约束系统，而求至少便是求最小值，所以应转化为$d[j]&gt;=d[i]+Wij$，这样跑最长路(只有用spfa)并且判0环就行了，然而发现这样只会有60，因为数据大和毒，导致判0环会炸。然后发现可以强联通分量缩点，那么每个分量的值肯定是一样的，如果边中有1就说明不符合。最后加一个超级起点，从它开始拓扑加dp就能过了。 上代码：#include&lt;bits/stdc++.h&gt;#define maxn 150005using namespace std;int n,m,op,a,b;typedef long long ll;struct eage&#123; int to,next,len;&#125;e[maxn&lt;&lt;1];int np=0,first[maxn];void add(int u,int v,int len)&#123; e[++np]=(eage)&#123;v,first[u],len&#125;; first[u]=np;&#125;ll d[maxn];bool vis[maxn];int st[maxn],top=0,low[maxn],dfn[maxn],clock_=0,belong[maxn],cc=0;bool ok=false;int stt[maxn],topp=0;bool run()&#123; for(int i=1;i&lt;=topp;i++)&#123; int t=stt[i]; for(int p=first[t];p;p=e[p].next)&#123; int j=e[p].to,c=e[p].len; if(belong[j]==belong[t]&amp;&amp;c==1) return true; &#125; &#125; return false;&#125;void dfs(int i)&#123; vis[i]=1; dfn[i]=low[i]=++clock_; st[++top]=i; for(int p=first[i];p;p=e[p].next)&#123; int j=e[p].to; if(vis[j])&#123; if(!belong[j]) low[i]=min(low[i],dfn[j]); continue; &#125; dfs(j); low[i]=min(low[i],low[j]); &#125; if(low[i]==dfn[i])&#123; cc++;topp=0; while(1)&#123; int t=st[top--]; belong[t]=cc; stt[++topp]=t; if(t==i) break; &#125; bool okk=run(); if(okk==true) ok=true; &#125;&#125; struct node&#123; int to;ll len;&#125;;vector&lt;node&gt;g[maxn];queue&lt;int&gt;q; int rd[maxn];void work()&#123; for(int i=1;i&lt;=n+1;i++)&#123; for(int p=first[i];p;p=e[p].next)&#123; int j=e[p].to;ll c=e[p].len; if(belong[j]!=belong[i]) g[belong[i]].push_back((node)&#123;belong[j],c&#125;),rd[belong[j]]++; &#125; &#125; d[belong[n+1]]=0; q.push(belong[n+1]); while(!q.empty())&#123; int i=q.front();q.pop(); for(int j=0;j&lt;g[i].size();j++)&#123; node t=g[i][j]; int kk=t.to;ll c=t.len; d[kk]=max(d[kk],d[i]+c); rd[kk]--; if(rd[kk]==0) q.push(kk); &#125; &#125;&#125;void init()&#123; scanf("%d%d",&amp;n,&amp;m); d[n+1]=0; for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d%d",&amp;op,&amp;a,&amp;b); if(op==1)&#123; add(a,b,0); add(b,a,0); &#125; else if(op==2)&#123; add(a,b,1); &#125; else if(op==3)&#123; add(b,a,0); &#125; else if(op==4)&#123; add(b,a,1); &#125; else if(op==5)&#123; add(a,b,0); &#125; &#125; for(int i=1;i&lt;=n;i++) add(n+1,i,1); for(int i=1;i&lt;=n+1;i++)&#123; if(!vis[i]) dfs(i); &#125; if(ok) printf("-1"); else&#123; work(); ll ans=0; for(int i=1;i&lt;=n+1;i++) ans+=d[belong[i]]; printf("%lld",ans); &#125;&#125;int main()&#123; //freopen("in.txt","r",stdin); //freopen("out.txt","w",stdout); init(); return 0;&#125;]]></content>
      <categories>
        <category>noip模拟赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>缩点</tag>
        <tag>拓扑</tag>
        <tag>差分约束系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[约束]]></title>
    <url>%2F2018%2F10%2F20%2F17%2F</url>
    <content type="text"><![CDATA[Description现有 n 个点， n 条有向边。 要求将 n 个点分入两个集合 A， B，使得对于集合A 中的每一个点 x，存在一个集合 B 中的点 y，从 y 到 x 有一条有向边。 问集合A 最多能包含几个点。 Input第一行一个整数 n，表示总共有 n 个点。接下来一行 n 个整数，表示一个序列 a， a[i]代表存在一条从第 i 个点到第a[i]个点的有向边。 Output一行一个数 ans， ans 是集合 A 最多能包含的点数。 Sample Input52 4 5 3 1 Sample Output2 Hint对于 30%的数据， n&lt;=10对于 100%的数据， n&lt;=100000 Solution发现一个点最多连向另外一个点，可以想一下发现是环加内向树。那么对于入度为0的点便只能加入B集合，那么a[x]定可以为A集合，所以拓扑排序，将遇到的为标记的或x和a[x]都为B的，将a[x]加入A。最后剩下环，将环上的B集合的标记清空(这样可以更大)，然后以环上的A集合点向没有标记的点蔓延赋值，最后就能得到最佳情况。 上代码：#include&lt;bits/stdc++.h&gt;#define maxn 100005using namespace std;int n,x,rd[maxn],a[maxn];queue&lt;int&gt;q;int color[maxn];bool vis[maxn];int calc;void init()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;x); a[i]=x; rd[x]++; &#125; for(int i=1;i&lt;=n;i++) if(rd[i]==0) q.push(i),color[i]=1; int ans=0; while(!q.empty())&#123; int i=q.front();q.pop(); if(!color[a[i]])&#123; color[a[i]]=3-color[i]; if(color[a[i]]==2) ans++; &#125; else if(color[i]==1&amp;&amp;color[a[i]]==1) color[a[i]]=2,ans++; rd[a[i]]--; if(rd[a[i]]==0) q.push(a[i]); &#125; for(int i=1;i&lt;=n;i++) if(rd[i]&amp;&amp;color[i]==1) color[i]=0;//将1清完，从2开始会更多 for(int i=1;i&lt;=n;i++)&#123; if(rd[i]&amp;&amp;color[i])&#123; int x=i; while(!color[a[x]])&#123; color[a[x]]=3-color[x]; if(color[a[x]]==2) ans++; x=a[x]; &#125; &#125; &#125; /*for(int i=1;i&lt;=n;i++)&#123; if(!color[i])&#123; color[i]=1; int x=i; while(!color[a[x]])&#123; color[a[x]]=3-color[x]; if(color[a[x]]==2) ans++; x=a[x]; &#125; &#125; &#125;*/ printf("%d",ans);&#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>拓扑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[键盘]]></title>
    <url>%2F2018%2F10%2F20%2F16%2F</url>
    <content type="text"><![CDATA[Description现在文本框中有一个 x 个字符的字符串,希望在经过一系列操作后得到看到一个长度恰好为 n 的字符串。现可以有 5 种操作:1.敲击 1 次键盘,输入一个字符2.敲击 2 次键盘(Ctrl+A),选中所有已经输入的字符3.敲击 2 次键盘(Ctrl+C),复制所有选中的字符到剪贴板4.敲击 2 次键盘(Ctrl+V),把剪贴板中的所有字符输出(不清空剪贴板)5.敲击 1 次键盘(Backspace),若没有选中字符则删除一个字符否则删除所有选中的字符选中状态仅影响复制操作。问至少敲击几次键盘才能得到一个长度为 n 的字符串。 Hint对于 100%的数据 $n,x&lt;=10^6$ Solution这道题思路很nice啊，如果不考虑backspace操作的话，那么是可以递推来做的。但如果有的话，那么可以3次清空为0，然后一直乘2大约140步左右可以大于$10^6$，也就是说极限步数是n+143，实际上会远远不到这个上限，那么若x能到y则连一条边，由调和级数算下来(缩放)大约为nlogn，再最短路跑一遍大约$nlog^2n$，因为上限远远没满卡一下常数能过。(主要为这方面题提供一种思路) dij代码(会T三个点qwq，可能以为1,5操作距离太近不太友好)#include&lt;bits/stdc++.h&gt;#define maxn 2000305using namespace std;int n,x,dist[maxn];struct node&#123; int v,id; friend bool operator &lt;(node a,node b)&#123; return a.v&gt;b.v; &#125;&#125;;priority_queue&lt;node&gt;q; bool vis[maxn];void init()&#123; scanf("%d%d",&amp;x,&amp;n); memset(dist,0x3f,sizeof(dist)); if(x&gt;n)&#123; dist[n]=x-n; dist[0]=3; q.push((node)&#123;dist[0],0&#125;); &#125; else&#123; dist[n]=n-x;dist[x]=0;q.push((node)&#123;dist[x],x&#125;); &#125; while(!q.empty())&#123; node t=q.top();q.pop(); int i=t.id;if(vis[i]) continue; vis[i]=1; if(i&lt;n) if(dist[i+1]&gt;dist[i]+1)&#123;dist[i+1]=dist[i]+1;q.push((node)&#123;dist[i+1],i+1&#125;);&#125;; if(i==0) continue; if(dist[i-1]&gt;dist[i]+1)&#123;dist[i-1]=dist[i]+1;q.push((node)&#123;dist[i-1],i-1&#125;);&#125;; int len=4; int m=2*i; while(m&lt;=n)&#123; if(dist[m]&gt;dist[i]+len+2)&#123; dist[m]=dist[i]+len+2;q.push((node)&#123;dist[m],m&#125;); &#125; m=m+i;len+=2; &#125; if(dist[n]&gt;dist[i]+len+2+m-n) dist[n]=dist[i]+len+2+m-n;//超过的最快方法 &#125; printf("%d",dist[n]);&#125;int main()&#123; init(); return 0;&#125; spfa(而spfa由于直接按加的顺序展开所以会好很多…)#include&lt;bits/stdc++.h&gt;#define maxn 2000305using namespace std;int n,x,dist[maxn];/*struct node&#123; int v,id; friend bool operator &lt;(node a,node b)&#123; return a.v&gt;b.v; &#125;&#125;;*///priority_queue&lt;node&gt;q; queue&lt;int&gt;q;bool vis[maxn];void init()&#123; scanf("%d%d",&amp;x,&amp;n); memset(dist,0x3f,sizeof(dist)); if(x&gt;n)&#123; dist[n]=x-n; dist[0]=3; q.push(0);vis[0]=1; &#125; else&#123; dist[n]=n-x;dist[x]=0;q.push(x);vis[x]=1; &#125; while(!q.empty())&#123; int i=q.front();q.pop(); vis[i]=0; if(i&lt;n) if(dist[i+1]&gt;dist[i]+1)&#123;dist[i+1]=dist[i]+1;if(!vis[i+1]) vis[i+1]=1,q.push(i+1);&#125;; if(i==0) continue; if(dist[i-1]&gt;dist[i]+1)&#123;dist[i-1]=dist[i]+1;if(!vis[i-1]) vis[i-1]=1,q.push(i-1);&#125;; int len=4; int m=2*i; while(m&lt;=n)&#123; if(dist[m]&gt;dist[i]+len+2)&#123; dist[m]=dist[i]+len+2;if(!vis[m]) vis[m]=1,q.push(m); &#125; m=m+i;len+=2; &#125; if(dist[n]&gt;dist[i]+len+2+m-n) dist[n]=dist[i]+len+2+m-n;//超过的最快方法 &#125; printf("%d",dist[n]);&#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>隐式图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[祎隋]]></title>
    <url>%2F2018%2F10%2F20%2F15%2F</url>
    <content type="text"><![CDATA[生活，靠容忍和退让支撑着前行 《祎隋》 年幼时 你含糊地 把热情挥洒 年老时 你明白地 将运命呈出]]></content>
      <categories>
        <category>杂诗</category>
      </categories>
      <tags>
        <tag>杂诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[noip模拟赛2]]></title>
    <url>%2F2018%2F10%2F18%2F13%2F</url>
    <content type="text"><![CDATA[T1Description小 H 最近迷上了名为“石头，剪刀，布”的游戏。游戏规则很简单：比赛双方同时数到三，然后同时出一个手势，代表“石头”、“剪刀”或“布”。“石头”胜“剪刀”，“剪刀”胜“布”，“布”胜“石头”。举个例子， 小 H 出“石头”， 对方出“布”，则对方胜利。当然，也可以“平局”（如果双方手势相同的话）。小 H 对阵小 B。 小 H 作为一个匹托专家，能够预测小 B 未来 N 回合的手势。 但作为具有数学头脑的人， 他又是比较懒的，以至于他只愿意变换固定次数的手势来完成游戏。例如， 他只想变 1 次，则他可能出“石头”几次，剩下的都出“布”；或者其他。现在小 H 与小 B 准备进行 N 回合的比赛，且已经测出小 B 未来 N 回合的手势，小 H 只愿意改变 K 次手势（最开始手势任意）。请你帮小 H 求出他最多能赢多少场 Input输入文件名为 game.in。输入的第一行两个空格隔开的数字 N 和 K，分别表示比赛的回合数和小 H 变换手势的次数。 接下来的 N 行，每行一个字母，表示小 B 的手势： ’H’表示石头、 ’S’表示剪刀、 ’P’表示布 Output输出文件名为 game.out。输出一行一个整数， 小 H 最多能赢的场数 Sample Input5 1P P H P S Sample Output4 Hint对于 30%的数据： N≤20对于 100%的数据： N≤100 000， K≤20 Solution一道水水的dp啊qwq，刷表和i-1到i转移都可以。注意细节…O($n \ast k$)实现就欧克。 #include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;vector&gt;using namespace std;#define maxn 100005int n,k,a[maxn],dp[maxn][22][3];//0:石头,1：剪刀,2:布 char s[2];void init()&#123; scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++)&#123;scanf("%s",s);if(s[0]=='H')a[i]=0;if(s[0]=='S') a[i]=1;if(s[0]=='P') a[i]=2;&#125;; //dp[0][0][0]=dp[0][0][1]=dp[0][0][2]=0; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;=min(i,k);j++) for(int kk=0;kk&lt;=2;kk++)&#123;//枚举上一个的手势 int f=0; if(a[i]==2&amp;&amp;kk==1) f=1; if(a[i]==1&amp;&amp;kk==0) f=1; if(a[i]==0&amp;&amp;kk==2) f=1; dp[i][j][kk]=max(dp[i][j][kk],dp[i-1][j][kk]+f);//不换 int tt=(a[i]-1+3)%3; if(j&gt;=1)&#123; if(tt==kk) continue;//不换..对身体好 dp[i][j][tt]=max(dp[i][j][tt],dp[i-1][j-1][kk]+1); &#125; &#125; int maxx=0; for(int i=0;i&lt;=2;i++) maxx=max(maxx,dp[n][k][i]); printf("%d",maxx);&#125; int main()&#123; //freopen("game.in","r",stdin); //freopen("game.out","w",stdout); init(); return 0;&#125; T2Description为补贴家用，小 M 终于谋得一份兼职——牛奶销售员。小 M 打算把牛奶销售到 N 个城市，这 N 个城市编号为 1..N。这些城市之间有 R 条高速公路和 P 条泥泞小道连接。每条高速路或泥泞小道连接 N个城市中的 A 和 B， 需要的花费为 C，对于高速路的花费 C， 一定是大于等于 0 的；然而对于泥泞小道，由于边远城市的人民感谢送奶工的辛劳，会额外付更多的奶钱， 所以有些小道的花费可能为负数（表示有收益）。高速公路是双向的，可以从 A 走到 B，也可以从 B 走到 A；然后泥泞小道则不是双向的，只能从 A 走到 B。事实上， 由于泥泞道路经过的都是蛮荒之地，所以政府为了社会和谐，出台了一些政策保证： 如果一条泥泞小道可以从 A到 B，那么保证不可能通过高速路或泥泞小道从 B 再回到 A。小 M 的销售中心在城市 S，现在他想知道，把牛奶从 S 送到每个城市的最小花费的，或者根本就不能送到。 Input输入文件名为 sales.in。输入的第 1 行包含四个空格隔开的整数: N, R, P 和 S，他们的意义如题目描述。 第 2 到 R+1 行每行含三个空格隔开的整数： A, B 和 C，表示一条高速公路双向连接城市 A 和 B，需要的花费为 C。 第 R+2 到 R+P+1 行每行包含三个空格隔开的整数： A, B 和 C，表示一条泥泞小道可以从城市 A 到 B，需要的花费为 C。 Output输出文件名为 sales.out。输出有 N 行，每行一个整数，第 i 行表示从 S 到达城市 i 的最小花费，如果不存在输出”NO PATH”。 Sample Input6 3 3 41 2 53 4 55 6 103 5 -1004 6 -1001 3 -10 Sample OutputNO PATHNO PATH50-95-100 Hint对于 30%的数据： N≤10 000对于 100%的数据： 1≤N≤25,000 , 1≤P,R≤50,000高速公路的 C： 0≤C≤10,000泥泞小道的 C： -10,000≤C≤10,000 Solution这道题真的傻缺了啊qwq，别人想的是有负权边不能跑dij，我tm想的是没有负环直接跑dij，感觉复杂度差不多就直接交上去了哇qwq。实际上你的复杂度超乎你想象。开始正经：这道题有两种解法：1.spfa+slf优化，好像勉强过得到？直接用双端队列deque维护一下。slf优化还是能加就加吧，毕竟挺简单的。不过关于spfa，它已经死了.所以稳妥一点还是用dij吧，对身体好a.2.dij+缩点+拓扑：woc这个思路真的很nice啊，首先发现可以缩点连成一个DAG图，然后对于每个联通块单独跑dij，这样算下来总复杂度也就nlogn左右（事实证明真的跑得飞快！法1时间几乎是它的十倍）.然后就是注意细节的实现，也为这种混合图提供了一种思路。当把所有的入边处理完之后用vector记录入点，就可以队首存入多个起点，一次dij跑完，复杂度被大大减少.（可以回顾noip2017逛公园）. 上代码：#include&lt;bits/stdc++.h&gt;#define maxn 25005#define maxm 150005using namespace std;struct eage&#123; int to,next,len;&#125;e[maxm];int np=0,first[maxn];void add(int u,int v,int len)&#123; e[++np]=(eage)&#123;v,first[u],len&#125;; first[u]=np;&#125;int n,r,p,s,x,y,z,dfn[maxn],low[maxn],belong[maxn],cc=0,clock_=0;int st[maxn],top=0,rd[maxn];bool vis[maxn];vector&lt;int&gt;g[maxn];struct noded&#123; int from,to,len;&#125;;vector&lt;noded&gt;b[maxn];void dfs(int i,int f)&#123; vis[i]=1; st[++top]=i; low[i]=dfn[i]=++clock_; for(int p=first[i];p;p=e[p].next)&#123; int j=e[p].to; if(vis[j])&#123; if(!belong[j]) low[i]=min(low[i],dfn[j]); continue; &#125; dfs(j,i); low[i]=min(low[i],low[j]); &#125; if(low[i]==dfn[i])&#123; cc++; while(1)&#123; int t=st[top--]; belong[t]=cc; if(t==i) break; &#125; &#125;&#125;int dist[maxn];bool viss[maxn];struct node&#123; int v,id; friend bool operator &lt;(node a,node b)&#123; return a.v&gt;b.v; &#125;&#125;;void dij(int s)&#123; priority_queue&lt;node&gt;q; for(int i=0;i&lt;g[s].size();i++)&#123; int t=g[s][i]; q.push((node)&#123;dist[t],t&#125;); &#125; while(!q.empty())&#123; node t=q.top();q.pop(); int i=t.id; if(viss[i]) continue; viss[i]=1; for(int p=first[i];p;p=e[p].next)&#123; int j=e[p].to,c=e[p].len; if(belong[j]!=belong[i]) continue; if(dist[j]&gt;dist[i]+c)&#123; dist[j]=dist[i]+c; q.push((node)&#123;dist[j],j&#125;); &#125; &#125; &#125; &#125; queue&lt;int&gt;qq;void work()&#123; memset(viss,0,sizeof(viss)); for(int i=1;i&lt;=n;i++) dist[i]=1000000007; g[belong[s]].push_back(s); dist[s]=0; qq.push(belong[s]); while(!qq.empty())&#123; int i=qq.front();qq.pop(); dij(i); for(int j=0;j&lt;b[i].size();j++)&#123; noded tt=b[i][j]; int t1=tt.from,t2=tt.to,c=tt.len; dist[t2]=min(dist[t2],dist[t1]+c); g[belong[t2]].push_back(t2); rd[belong[t2]]--; if(rd[belong[t2]]==0) qq.push(belong[t2]); &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; if(dist[i]==1000000007) printf("NO PATH\n"); else printf("%d\n",dist[i]); &#125;&#125; void run()&#123; for(int i=1;i&lt;=n;i++)&#123; if(!vis[i]) continue; for(int p=first[i];p;p=e[p].next)&#123; int j=e[p].to; if(belong[j]!=belong[i])&#123; //g[belong[i]].push_back(belong[j]); b[belong[i]].push_back((noded)&#123;i,j,e[p].len&#125;); rd[belong[j]]++; &#125; &#125; &#125; work();&#125;void init()&#123; scanf("%d%d%d%d",&amp;n,&amp;r,&amp;p,&amp;s); for(int i=1;i&lt;=r;i++)&#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); add(x,y,z); add(y,x,z); &#125; for(int i=1;i&lt;=p;i++)&#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); add(x,y,z); &#125; dfs(s,0); run();&#125;int main()&#123; init(); return 0;&#125; T3Description小 Y 同学手上有两类线段，分别为 A 线段和 B 线段。A 线段的有n种，第i种有$s_i$条，其左端点和右端点为$a_i$和$b_i$，他们都是109范围内的正整数，且一定有$a_i$ ≤ $b_i$。 B 线段的有m种，第i种有$k_i$条，其左端点和右端点为$l_i$和$r_i$，他们也是109范围内的正整数，且一定有$l_i$ ≤$r_i$。 小 Y还规定，如果一条 A 线段($a_i$, $b_i$)能匹配一条 B 线段($l_i$, $r_i$)，当且仅当$l_i$ ≤ $a_i$≤$b_i$ ≤ $r_i$。现在小 Y 需要你判断能否为所有的 A 线段都指定一条与之匹配的 B 线段。注意，无论是 A 线段还是 B 线段，每条都只能匹配一次，且仅能匹配一次。 Input输入文件名为 machine.in输入的第 1 行是一个整数T，表示数据组数。每组数据的第 1 行有两个整数n, m，分别表 A 类线段和 B 类线段的种类数。接下来n行，每行 3 个整数ai、 bi、 si，描述一种 A 类线段。接下来 m 行，每行三个整数li、 ri、 ki，描述一种 B 类线段。 Output输入文件名为 machine.out仅输出共T行，每行一个字符串，若可以实现则输出 Yes，否则输出No。 Sample Input32 21 4 23 5 11 4 22 5 13 21 3 12 4 13 5 11 3 22 5 12 21 2 21 2 11 2 11 2 2 Sample OutputYesNoYes Hint对于所有数据保证有：1 ≤ $s_i$, $k_i$ ≤ 109，1 ≤ t≤ 50，1 ≤ n, m ≤ 50000。一个测试点中，所有n的和不超过 4000000，所有m的和也不超过 4000000。 Solution还是一道套路题a，用set维护直接nlognA了啊（没办法蒟蒻太蒻了）。稍微注意线段维护的细节，按照左端点排序，相同排右端点。然后用两个指针维护，对于每个i，将l小于等于它的加入到multiset里面（以右端点为关键字）然后每次lower_bound找一下就欧克了啊qwq.(勉哥说对于每个被删掉的指针要查询它的下一个必须要预先处理好) tips线段类的有很多问题可以总结a….上一次居然被那个线段贪心给卡了qwq(处理不重叠的最多线段)就是右端点排个序，左端点大的就可以加进去，贪贪贪 #include&lt;bits/stdc++.h&gt;#define maxn 50005using namespace std;struct node&#123; int l,r,w; friend bool operator &lt;(node a,node b)&#123; if(a.l!=b.l)return a.l&lt;b.l; else return a.r&lt;b.r; &#125;&#125;nda[maxn],ndb[maxn];struct noded&#123; int r,w; friend bool operator &lt;(noded a,noded b)&#123; return a.r&lt;b.r; &#125;&#125;;multiset&lt;noded&gt;s;multiset&lt;noded&gt;::iterator it,itt;int t,n,m;void init()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d%d%d",&amp;nda[i].l,&amp;nda[i].r,&amp;nda[i].w); for(int i=1;i&lt;=m;i++) scanf("%d%d%d",&amp;ndb[i].l,&amp;ndb[i].r,&amp;ndb[i].w); sort(nda+1,nda+n+1); sort(ndb+1,ndb+m+1); s.clear(); int j=1;//b的序号 for(int i=1;i&lt;=n;i++)&#123;//a的序号 while(j&lt;=m&amp;&amp;ndb[j].l&lt;=nda[i].l) s.insert((noded)&#123;ndb[j].r,ndb[j].w&#125;),j++; noded tt=(noded)&#123;nda[i].r,0&#125;; it=s.lower_bound(tt); if(it==s.end()) &#123;printf("No\n");return;&#125; while(1)&#123; noded t=*it; s.erase(it); if(t.w&gt;=nda[i].w)&#123;t.w-=nda[i].w,nda[i].w=0,s.insert((noded)&#123;t.r,t.w&#125;);break;&#125; else nda[i].w-=t.w; it=s.lower_bound(tt); if(it==s.end()) &#123;printf("No\n");return;&#125; &#125; &#125; printf("Yes\n");&#125;int main()&#123; scanf("%d",&amp;t); for(int i=1;i&lt;=t;i++) init(); return 0;&#125;]]></content>
      <categories>
        <category>noip模拟赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>dijsktra</tag>
        <tag>spfa</tag>
        <tag>slf优化</tag>
        <tag>缩点</tag>
        <tag>拓扑</tag>
        <tag>DAG图</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[noip模拟赛1]]></title>
    <url>%2F2018%2F10%2F17%2F12%2F</url>
    <content type="text"><![CDATA[T1Description每天中午，美丽的重庆一中都会上演一场华丽的千人大竞走。大量人流短时间涌进第二食堂， 食堂班长小 H 表示不淡定了，他必须合理安排饭堂饭菜的价格，来让同学们有愉快的心情就餐。已知第一饭堂饭菜的价格是有 N 位数字的整数，如果一个价格有不小于K（1≤K≤N） 个数位完全相同，那么这个价格就被认为是漂亮的，否则这个价格被认为是不漂亮的。 小 H 想改变其中一个饭菜价格，改变价格中的一位数字需要花费一些钱， 钱数等于改前和改后的数字之差的绝对值。小 H 希望你能把这个价格改地漂亮，求出最小花费，同时给出字典序最小的修改方案。 Input输入文件名为 canteen.in。输入的第一行两个空格隔开的数字 N 和 K(1≤K≤N)。 第二行是一个长度为 N 位的数字， 表示原来的价格。 Output输出文件名为 canteen.out。输出包含两行，第一行一个整数， 表示最小费用。 第二行是字典序最小的方案。 Sample Input6 5889696 Sample Output4888688 Hint对于 30%的数据： N≤10对于 100%的数据： N≤100 000 Solution比较水的一道贪心a，只是要注意细节，维护两个东西：最小费用和最小字典序。显然最小费用优先级更大。我们枚举相同的k个数字从0到9，对于每一个确定的st,用i=0~9依次考虑变的数字，注意先执行st+i，再执行st-i以保证字典序最优。然后对于小于st的从后往前改，大于st的从前往后改来保证字典序。 tips（想好细节,think twice,code once）上代码： The Code#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt; #define maxn 100005using namespace std;int n,k;char s[maxn];char ss[maxn];char tt[maxn];int cnt[10];int minn=0x3f3f3f3f;int yb[10];int calc[10];bool cmp()&#123; for(int i=1;i&lt;=n;i++)&#123; if(tt[i]&lt;ss[i]) return true; else if(tt[i]&gt;ss[i]) return false; &#125; return false;&#125;void init()&#123; scanf("%d%d",&amp;n,&amp;k); scanf("%s",s+1); for(int i=1;i&lt;=n;i++) cnt[s[i]-'0']++,ss[i]='9';//最大化 for(int st=0;st&lt;=9;st++)&#123; int t=k;//要变的个数 int ans=0;//要花的钱 for(int i=0;i&lt;=9;i++)&#123; if(i==0)&#123; if(cnt[st]&gt;=t) break; t-=cnt[st]; &#125; else&#123; int t1=st+i,t2=st-i; if(t1&lt;=9)&#123; if(cnt[t1]&gt;=t)&#123;ans+=t*i;break;&#125; t-=cnt[t1];ans+=cnt[t1]*i; &#125; if(t2&gt;=0)&#123; if(cnt[t2]&gt;=t)&#123;ans+=t*i;break;&#125; t-=cnt[t2];ans+=cnt[t2]*i; &#125; &#125; &#125; minn=min(minn,ans); calc[st]=ans; &#125; for(int st=0;st&lt;=9;st++)&#123; if(calc[st]==minn)&#123; for(int i=1;i&lt;=n;i++) tt[i]=s[i]; memset(yb,0,sizeof(yb)); int t=k;//要变的个数 for(int i=0;i&lt;=9;i++)&#123; if(i==0)&#123; if(cnt[st]&gt;=t) break; t-=cnt[st]; &#125; else&#123; int t1=st+i,t2=st-i; if(t1&lt;=9)&#123; if(cnt[t1]&gt;=t)&#123;yb[t1]=t;break;&#125; t-=cnt[t1];yb[t1]=cnt[t1]; &#125; if(t2&gt;=0)&#123; if(cnt[t2]&gt;=t)&#123;yb[t2]=t;break;&#125; t-=cnt[t2];yb[t2]=cnt[t2]; &#125; &#125; &#125; for(int i=0;i&lt;=9;i++)&#123; if(yb[i])&#123; if(i&gt;st)&#123; for(int j=1;j&lt;=n;j++) if(s[j]==(i+'0')) if(yb[i])tt[j]=st+'0',yb[i]--; else&#123;break;&#125; &#125; else&#123; for(int j=n;j&gt;=1;j--) if(s[j]==(i+'0')) if(yb[i])tt[j]=st+'0',yb[i]--; else&#123;break;&#125; &#125; &#125; &#125; if(cmp()) for(int i=1;i&lt;=n;i++) ss[i]=tt[i]; &#125; &#125; printf("%d\n",minn); for(int i=1;i&lt;=n;i++) printf("%c",ss[i]); /*memset(dp,0x3f,sizeof(dp)); for(int i=1;i&lt;=9;i++) dp[0][i]=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=min(i,k);j++) for(int kk=1;kk&lt;=9;kk++)&#123; dp[j][kk]=min(dp[j][kk],dp[j-1][kk]+abs(s[i]-'0'-kk)); &#125; int minn=0x3f3f3f3f; for(int i=1;i&lt;=9;i++) minn=min(minn,dp[k][i]); printf("%d",minn);*/&#125;int main()&#123; //freopen("canteen.in","r",stdin); //freopen("canteen.out","w",stdout); init(); return 0;&#125; T2Description小 M 新设计了一款战略游戏。游戏的地图包含有 N 个阵地（用 1..N 编号），用 N-1 条战略交通线把它们连接起来， 地图中任意两个阵地都能直接或间接地相互到达。 小 M 为每条交通线设定一个名为“战略重要性”的参数，它是一个正整数，且这个数值越大，说明这条交通线的战略重要性越大。 小 M 还设计了一个阵地间的“战略相关性”的度量标准， 那就是两个阵地间路径上“战略重要性”最小的交通线。小 M 已经完成了游戏大多数模块的代码， 还有一个在线查询模块没有完成，即对于用户查询： k， v，表示查询与阵地 v“战略相关性” 不小于 k 的阵地的数目。由于小 M 还要负责游戏的推广， 所以这个查询模块的代码就交给你了。 Input输入文件名为 strategy.in。第一行输入包含 N 和 Q。 接下来的 N-1 行描述地图中的交通线。 每行包括三个整数 pi,qi 和 ri ( 1≤pi,qi≤N， ri&lt;=1000000000 )，表示阵地 pi 和 qi的战略重要性为 ri 。接下来的 Q 行描述了 Q 次查询。 每行包含两个整数，k 和 v (1≤k≤1,000,000,000, 1≤v≤N )，表示一次查询。 Output输出文件名为 strategy.out。输出 Q 行。在第 i 行输出第 i 次查询的的答案。 Sample Input4 31 2 32 3 22 4 41 24 13 1 Sample Output302 Hint对于 20%的数据： N,Q≤3 00对于 50%的数据： N,Q≤5 000对于 100%的数据： N,Q≤100 000 Solution首先会想到离线处理，再根据单调性，想到用并查集维护，将大于等于k的边所连接的点加入并查集，这样对于每个联通块，其中任意两点都是符合“战略相关性”大于等于k的，所以对于每个询问，答案就是v所在联通块点个数减1即可。 上代码： The Code#include&lt;bits/stdc++.h&gt;using namespace std;#define maxn 100005struct eage&#123; int u,v,len; friend bool operator &lt;(eage a,eage b)&#123; return a.len&gt;b.len; &#125;&#125;e[maxn];int np=0;int n,q,x,y,z,fa[maxn],sz[maxn];struct node&#123; int id,k,v,ans; friend bool operator&lt;(node a,node b)&#123; return a.k&gt;b.k; &#125;&#125;nd[maxn];bool cmp(node a,node b)&#123; return a.id&lt;b.id;&#125;int find(int i)&#123; if(fa[i]==i) return i; int root=find(fa[i]); fa[i]=root; return root;&#125;void link(int x,int y)&#123; int fx=find(x),fy=find(y); if(fx!=fy)&#123; fa[fx]=fy; sz[fy]+=sz[fx]; &#125;&#125;bool check(int x,int y)&#123; int fx=find(x),fy=find(y); if(fx!=fy) return false; return true;&#125;void init()&#123; scanf("%d%d",&amp;n,&amp;q); for(int i=1;i&lt;=n;i++) fa[i]=i,sz[i]=1; for(int i=1;i&lt;n;i++)&#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); e[++np]=(eage)&#123;x,y,z&#125;; &#125; for(int i=1;i&lt;=q;i++)&#123; scanf("%d%d",&amp;nd[i].k,&amp;nd[i].v);nd[i].id=i; &#125; sort(e+1,e+np+1);sort(nd+1,nd+q+1); int j=1; for(int i=1;i&lt;=q;i++)&#123; while(j&lt;=np&amp;&amp;e[j].len&gt;=nd[i].k)&#123; link(e[j].u,e[j].v); j++; &#125; nd[i].ans=sz[find(nd[i].v)]-1; &#125; sort(nd+1,nd+q+1,cmp); for(int i=1;i&lt;=q;i++) printf("%d\n",nd[i].ans);&#125;int main()&#123; init(); return 0;&#125; T3Description小 Y 正用图章和颜料在草稿纸上乱涂颜色。对于数学敏感的他，突然发现这是一个有意思的数学问题：给出有 N 个格子的纸、宽度为 K 个格子的图章和 M 种不同的颜色，每次用图章把纸上连续的 K 个格子上染任意一种颜色，最后把纸涂满，那么小 Y 想知道最后纸上的颜色序列有多少种不同的情况？ Input输入文件名为 paint.in输入数据仅一行，包含三个整数 N,M,K，他们中间用一个空格分开，分别表示纸张的长度，颜色数目和图章的宽度。 Output输入文件名为 paint.out输出文件仅一行，一个非负整数，表示答案。这个数可能很大，请模1000000007 后输出。 Sample Input3 2 2 Sample Output6 Hint对于 20%的数据 N,M,K≤5对于 50%的数据 N,K≤1 000对于 100%的数据 N,M,K≤10 000 000 Solution真的是数学问题吗？？？首先要明白一点，合法的是要求至少有一个长度为K的相同颜色的块。（这个都没有想出来我好蒻A qwq）然后正难则反，我们只要求出不合法的总个数，然后用总的方法数减去不合法的即为合法的方案数，那么这里用dp,设f[i]为前i个不合法的方案数，那么就不会出现连续k个，所以：$f[i]=f[i-1] \ast m （i&lt;k）​$ $f[i]=(f[i-1]+f[i-2]+…+f[i-k+1]) \ast (m-1) (i&gt;=k)$ 第i个和第i-k个必须不一样再简单加个滑动窗口就可以O(n)过了233333 tips题目中有mod的话，一般不是dp就是数学（套路！！！）上代码： The Code#include&lt;bits/stdc++.h&gt;#define maxn 10000005using namespace std;typedef long long ll;const ll mod=1000000007;int n,m,k;ll dp[maxn];ll qkpow(ll t,int pos)&#123; if(pos==0) return 1; if(pos==1) return t%mod; ll tt=qkpow(t,pos/2); if(pos&amp;1) return tt*tt%mod*t%mod; else return tt*tt%mod;&#125;void init()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); ll all=qkpow(m,n); dp[0]=1; ll sum=0; for(int i=1;i&lt;k;i++) dp[i]=dp[i-1]*m%mod,sum=(sum+dp[i])%mod; for(int i=k;i&lt;=n;i++)&#123; dp[i]=(sum)*(m-1)%mod; sum=(sum+dp[i]-dp[i-k+1]+mod)%mod; &#125; ll ans=(all-dp[n]+mod)%mod; printf("%lld",ans);&#125;int main()&#123; init(); return 0;&#125; 小结：总结套路a鸽子，多想想那些大佬是怎么思考的。（think twice,code once）]]></content>
      <categories>
        <category>noip模拟赛</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>离线</tag>
        <tag>数学</tag>
        <tag>dp</tag>
        <tag>正难则反</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[祎隋]]></title>
    <url>%2F2018%2F10%2F16%2F11%2F</url>
    <content type="text"><![CDATA[童话，被同化前做过的梦《祎隋》 我们因多少人孤单 又有多少人为我们不安 等待是漫长的表演 相安是莫大的荒诞 为搏那一瞬笑颜 熹光几点 我们敢于冒险 心怀本愿 却屡次三番 无法实现 使得停滞不前 初心淡暗 何时起相顾无言 仿佛就从昨天 再忆那春风不及的笑脸 已是许久以前 颔首 低眉 轻笑 每个瞬间 浅唱 微吟 翩舞 总拨心弦 可我没有华丽诗篇 没有道貌伟岸 只有痴心一片 闲心几点 忽而悄然自言 你可曾是我心中的四月天？ 回神漠然 青春已半 不如数月以前 我们未曾相见 窗沿 雨 雷电 深夜未眠 愿初心不变 心境自然 虽喜忧掺半 往前仍是少年]]></content>
      <categories>
        <category>杂诗</category>
      </categories>
      <tags>
        <tag>杂诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF350E Wrong Floyd]]></title>
    <url>%2F2018%2F10%2F16%2F10%2F</url>
    <content type="text"><![CDATA[Description给定n个点,m条边以及k个标记点，要求进行Floyd时只以标记的点为中间点进行松弛操作（每条边边权为1）要求你造出m条边的数据来hack掉这种程序。 Hint3&lt;=n&lt;=300 , 2&lt;=k&lt;=n2&lt;=k&lt;=n , n-1&lt;=m&lt;=n*(n-1)/2; Solution我们只需要任意一点只和非标记点连边就可以了（这样就无法正确更新它到其他点的距离） 具体一下几个细节： 1.判k==n或m&gt;最多可以构出的边maxm； maxm=(n-1)*(n-2)/2+num;（num:非标记点的数量） 2.将随便一个标记点与所以非标记点连边； 3.再随便一个非标记点与未加入图中的点连边来保证图的联通； 4.最后随便加未加的边使边数凑够m即可； The Code#include&lt;bits/stdc++.h&gt;#define maxn 310using namespace std;int n,m,k,x,num;bool vis[maxn],iss[maxn][maxn],viss[maxn];void init()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=n;i++) iss[i][i]=1; for(int i=1;i&lt;=k;i++) scanf("%d",&amp;x),vis[x]=1; num=n-k; int maxx=(n-1)*(n-2)/2+num; if(m&gt;maxx||k==n)&#123; printf("-1");return; &#125; int t,tt=1;int calc=0; while(!vis[tt]) tt++; viss[tt]=1; for(int i=1;i&lt;=n;i++)&#123; if(!vis[i])&#123; t=i; viss[t]=1; printf("%d %d\n",t,tt); iss[t][tt]=iss[tt][t]=1; calc++; &#125; &#125; //保证联通 for(int i=1;i&lt;=n;i++)&#123; if(viss[i]) continue; printf("%d %d\n",i,t); iss[i][t]=iss[t][i]=1; calc++; if(calc==m) break; &#125; for(int i=1;i&lt;=n;i++)&#123; if(calc==m) break; if(i==tt) continue; for(int j=1;j&lt;=n;j++)&#123; if(j==tt) continue; if(iss[i][j]) continue; printf("%d %d\n",i,j); calc++; iss[i][j]=iss[j][i]=1; if(calc==m) break; &#125; &#125;&#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[32.Sort]]></title>
    <url>%2F2018%2F10%2F16%2F9%2F</url>
    <content type="text"><![CDATA[Description众所周知，排序方法有许多种。例如：简单易懂的冒泡排序，平均复杂度较优的快速排序，以及不基于比较的基数排序等等。 现在，小 DD 得到了一个自然数序列 {a1,a2,⋯,an}{a1,a2,⋯,an}。他想要对其按照从小到大的顺序进行排序（即使得每个元素均严格不大于他的后继元素）。但由于基于比较的排序算法复杂度下界已经被证明为 Θ(nlog2n)Θ(nlog2⁡n)，所以小 DD 决定尝试一种全新的排序算法：翻转排序。 在翻转排序中，小 DD 在每次操作中，可以选择一个区间 [l,r][l,r] (1≤l≤r≤n)(1≤l≤r≤n)，并翻转 al,al+1,⋯,aral,al+1,⋯,ar。即，在该次操作完后，序列将会变为 a1,a2,⋯,al−1,ar,ar−1,⋯,al+1,al,ar+1,ar+2,⋯,ana1,a2,⋯,al−1,ar,ar−1,⋯,al+1,al,ar+1,ar+2,⋯,an。 例如，对于序列 [1,6,2,4,3,5][1,6,2,4,3,5]，若选择区间 [2,4][2,4] 进行翻转，则将会得到 [1,4,2,6,3,5][1,4,2,6,3,5]。 定义一次操作的代价为 r−l+1r−l+1，即翻转的区间长度。定义一个操作序列的代价为每次操作的代价之和。现在，请你帮助小 DD 求出一个代价足够小的操作序列（你并不一定要求出代价最小的操作序列）。 Input第一行一个正整数 nn，表示序列长度。 第二行 nn 个空格隔开的非负整数，表示小 DD 得到的自然数序列 a1,a2,⋯,ana1,a2,⋯,an。 Output输出若干行，每行两个空格隔开的正整数 l,rl,r (1≤l≤r≤n)(1≤l≤r≤n)，表示一次翻转区间 [l,r][l,r] 的操作。 最后输出一行 -1 -1，标志着操作序列的结束。 Sample Input4 1 3 2 4 Sample Output2 3 -1 -1 Hint1.下发文件中提供了 checker.cpp，该程序将对于其所在目录下的 sort.in，判断其所在目录下的 sort.out 是否为一个正确的操作序列。若正确，将给出该操作序列的代价。若不正确，将给出错误信息。选手可以借助该程序来更好地检查自己的程序是否正确。 运行时，必须保证 sort.in 为一个合法的输入，且需保证 sort.out 符合题目中描述的输出格式，否则出现任何结果均有可能。 2.对于所有测试数据，保证 1≤n≤500001≤n≤50000，且 0≤ai≤1090≤ai≤109。 （附checker.cpp）#include &lt;algorithm&gt;#include &lt;cstdio&gt;int arr[50005];int main()&#123; FILE *fin = fopen("sort.in", "r"), *fout = fopen("sort.out", "r"); if (!fin) &#123; puts("INVALID : File sort.in not found."); return -1; &#125; if (!fout) &#123; puts("INVALID : File sort.out not found."); return -1; &#125; int n; fscanf(fin, "%d", &amp;n); for (int i = 0; i &lt; n; i++) fscanf(fin, "%d", arr + i); int l, r, sum = 0; while (~fscanf(fout, "%d%d", &amp;l, &amp;r)) &#123; if (l == -1 &amp;&amp; r == -1) break; sum += r - l + 1; if (l &lt;= 0 || l &gt; n) &#123; printf("INVALID : l = %d is not in range [1, %d].\n", l, n); return -1; &#125; if (r &lt;= 0 || r &gt; n) &#123; printf("INVALID : r = %d is not in range [1, %d].\n", r, n); return -1; &#125; if (l &gt; r) &#123; printf("INVALID : %d = l &gt; r = %d.\n", l, r); return -1; &#125; if (sum &gt; 20000000) &#123; puts("INVALID : Too much cost."); return -1; &#125; std::reverse(arr + --l, arr + r); &#125; bool f = true; for (int i = 1; i &lt; n; i++) f &amp;= arr[i] &gt;= arr[i - 1]; if (!f) &#123; puts("INVALID : Not sorted."); return -1; &#125; printf("VALID : Total cost is %d.\n", sum); return 0;&#125;checker Solution本题算是一个比较新颖的题目，实际上是用这种翻转来模拟实现归并排序: 先将给定数列进行离散化，每次选定一个中间的数，将小于等于它的排在左边，大于它的排在右边，再依次递归两边就可以了； 主要是复杂度（进行操作的次数）证明a…. 排一遍要n，由于其非01性，所以进行log2n次的n排，故排一遍将l到r以stdd为标准换为左边小于等于stdd，右边大于等于stdd的操作数为Θ(nlog2n) ； T(n) = 2T(n/2) + Θ(nlog2n),可以解得 T(n) = Θ(nlog22n) ； tql%%%上代码。#include&lt;bits/stdc++.h&gt;#define maxn 50005using namespace std;int n,pos[maxn];struct node&#123; int v,id; friend bool operator&lt;(node a,node b)&#123; return a.v&lt;b.v; &#125;&#125;nd[maxn];int stdd;void run(int l,int r)&#123; if(l==r) return; int mid=l+r&gt;&gt;1; run(l,mid);run(mid+1,r); int L,R;//要翻转的区间 L=R=mid;//L和R的初值 int i=mid,j=mid+1; while(i&gt;=l&amp;&amp;pos[i]&gt;stdd) L=i--; while(j&lt;=r&amp;&amp;pos[j]&lt;=stdd) R=j++; if(L!=R)&#123; printf("%d %d\n",L,R); reverse(pos+L,pos+R+1); &#125; &#125; void msort(int l,int r)&#123; if(l==r) return; int mid=stdd=(l+r)&gt;&gt;1; run(l,r);//将l到r以stdd为标准换为左边小于等于stdd，右边大于等于stdd msort(l,mid);msort(mid+1,r); &#125;void init()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;nd[i].v);nd[i].id=i; &#125; sort(nd+1,nd+n+1); for(int i=1;i&lt;=n;i++) pos[nd[i].id]=i;//离散化位置确定 msort(1,n); printf("-1 -1\n");&#125;int main()&#123; //freopen("sort.in","r",stdin); //freopen("sort.out","w",stdout); init(); return 0;&#125;]]></content>
      <categories>
        <category>Noi.ac</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数对子]]></title>
    <url>%2F2018%2F10%2F16%2F8%2F</url>
    <content type="text"><![CDATA[Description我们定义一个数对 (x,y) 是好的，当且仅当 x≤y，且 x xor y的二进制表示下有奇数个 1 现在给定 nn 个区间 [li,ri]，你需要对于每个 i∈[1,n]，输出有几对好的数 (x,y)满足 x 和 y 都在 [l1,r1]∪[l2,r2]…∪[li,ri]，即两个数都在前 i 个区间的并里 Input第一行一个正整数 n 接下来 n 行每行两个整数 [li,ri]，表示第 i个区间，保证 li≤ri Ouput输出 n 行，第 i行一个整数表示有几对好的数 (x,y) 满足 x,y 都在前 i 个区间的并里 Sample Input3 1 7 3 10 9 20 Sample Output12 25 100 Hint对于 30%30% 的数据，有 1≤n≤1001≤n≤100，1≤li≤ri≤1001≤li≤ri≤100 对于 50%50% 的数据，有 1≤n≤10001≤n≤1000，1≤li≤ri≤232−11≤li≤ri≤232−1 对于 100%100% 的数据，有 1≤n≤1051≤n≤105, 1≤li≤ri≤232−11≤li≤ri≤232−1 时间限制：2s 空间限制：512MB Solutiontips先补充几个小知识点（快速求出一个数的二进制中有多少个1）: x=x&amp;(x-1)（递归求法，适用于单个数） 表达式的意思就是:把x的二进制表示 从低位开始，将遇到的第一个为1的 二进制位 置0。 int calc=0;while(x) x=x&amp;(x-1),calc++;calc即为所求值 求0到x中有多少二进制含1个数为奇数的： long long calc(long long x)&#123; long long tmp=x,tot=0; while(tmp) &#123; if(tmp&amp;1)tot++; tmp&gt;&gt;=1; &#125; return (x&gt;&gt;1)+((x&amp;1) || (tot&amp;1));&#125;证明：00 01 10 11 100 101 110 111....继续下去可以发现规律是偶奇奇偶奇偶偶奇....所以x&gt;&gt;1之前一半的，如果x为奇数（会少算一个）或其本身有奇数个1得加上 所以说探究性质a老哥(这个性质也可以记住) p.s.当线段树叶子节点有n个时，应开总共2^(log2n+1)个点，即2*n个点 正经题解开始：首先，对于每个数对（x,y）, 若要x xor y的二进制表示下有奇数个 1，则必定一者含奇数个1，一者含偶数个。 证明：若两个都为奇数，1.则奇减奇等于偶（重叠个数为奇个）2.奇减偶先为奇（重叠个数为偶数个），奇加奇等于偶 ​ 若两个都为偶数，则可同上证明 ​ 一奇一偶，1.奇减奇等于偶，偶减奇等于奇，奇加偶等于奇2.奇减偶等于奇，偶减偶等于偶，偶加奇等于奇 所以我们采取线段树来维护区间含奇数个1和含偶数个1的个数，对于区间l,r，则用上述中所介绍的calc函数，来calc(r)-calc(l-1)得到奇数个1个数以及r-l+1-（calc(r)-calc(l-1)）得到偶数个1个数 每次输入一个区间加进去统计一个区间，然后输出总的相乘即可。p.s.线段树很好的解决了区间相交的问题，在以及统计过的区间标记vis[now]=1; 上代码： #include&lt;bits/stdc++.h&gt;#define maxn 100005using namespace std;typedef long long ll;ll num[maxn&lt;&lt;4][2];int lc[maxn&lt;&lt;4],rc[maxn&lt;&lt;4],rt=0,np=0;int n;bool vis[maxn&lt;&lt;4];void upload(int now)&#123; num[now][0]=num[lc[now]][0]+num[rc[now]][0]; num[now][1]=num[lc[now]][1]+num[rc[now]][1];&#125;ll calc(ll x)&#123; ll t=x,tot=0; while(t) &#123; if(t&amp;1)tot++; t&gt;&gt;=1; &#125; return (x&gt;&gt;1)+((x&amp;1) || (tot&amp;1));&#125;void update(int &amp;now,ll l,ll r,ll x,ll y)&#123; if(!now) now=++np; if(vis[now]) return; if(l&gt;=x&amp;&amp;r&lt;=y)&#123; num[now][1]=calc(r)-calc(l-1); num[now][0]=r-l+1-num[now][1]; vis[now]=1; return; &#125; ll m=(l+r)&gt;&gt;1; if(y&lt;=m)update(lc[now],l,m,x,y); else if(x&gt;m)update(rc[now],m+1,r,x,y); else&#123; update(lc[now],l,m,x,y); update(rc[now],m+1,r,x,y); &#125; upload(now);&#125;void init()&#123; scanf("%d",&amp;n); ll L,R,mx=1ll&lt;&lt;32; for(int i=1;i&lt;=n;i++)&#123; scanf("%lld%lld",&amp;L,&amp;R); update(rt,1,mx,L,R); printf("%lld\n",num[1][0]*num[1][1]); &#125;&#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>二进制</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[祎隋]]></title>
    <url>%2F2018%2F10%2F16%2F7%2F</url>
    <content type="text"><![CDATA[愿你像个孩子，愿你心生双翼 《祎隋》 青涩 带着年少初识的忐忑 我们相遇了 传奇 三年来我们所追寻的词字 一段故事 从这里轻启 回忆 忘不却从前往事 追不上白驹过隙 再聚 仿佛多年往复 传奇已铸 但我们的故事未完待续 我们的航船才起征途 愿 愿相框里的我们永远闪闪发光 愿你仍是原般模样]]></content>
      <categories>
        <category>杂诗</category>
      </categories>
      <tags>
        <tag>杂诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF351B Jeff and Furik]]></title>
    <url>%2F2018%2F10%2F16%2F6%2F</url>
    <content type="text"><![CDATA[Description给一个1~n的排列p[i]，Jeff先手可以交换任意两个相邻元素，而Furik会有0.5的几率把任意满足p[i] &lt; p[i+1]的p[i]和p[i+1]交换，有0.5的几率把任意满足p[i] &gt; p[i+1]的p[i]和p[i+1]交换，问将整个序列变成升序所需的最小期望步数 Input第一行一整数n表示序列长度，之后一个1~n的排列p[i] (1&lt;=n&lt;=3000) Output输出把整个序列变成升序所需的最小期望步数 Sample Input53 5 2 4 1 Sample Output13.000000 Solution考虑E[i]（i为逆序对个数）的最小期望步数，则E[0]=0,E[1]=1;那么每一次Jeff肯定是交换使逆序对减少一个而Furik则有50%减少一个50%增加一个，故$E[i]=1/2(E[i-2]+1)+1/2(E[i-1+1]+1)$;化简得$E[i]=E[i-2]+4$; 故模拟归并排序求一次逆序对个数便可实现。 Code#include&lt;bits/stdc++.h&gt;#define maxn 3005using namespace std;int n,a[maxn],t[maxn];int msort(int l,int r)&#123; if(l==r) return 0; int m=l+r&gt;&gt;1; int t1=msort(l,m); int t2=msort(m+1,r); int t3=0; int i=l,j=m+1,k=l; while(i&lt;=m&amp;&amp;j&lt;=r)&#123; if(a[i]&gt;a[j])&#123; t3+=m-i+1; t[k++]=a[j++]; &#125; else&#123; t[k++]=a[i++];//本来就应该小于 &#125; &#125; while(i&lt;=m) t[k++]=a[i++]; while(j&lt;=r) t[k++]=a[j++]; for(int p=l;p&lt;=r;p++) a[p]=t[p];//调整 return t1+t2+t3; &#125;void init()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); int nd=msort(1,n); if(nd&amp;1)&#123; printf("%lf",(double)(2*nd-1)); &#125; else printf("%lf",(double)2*nd);&#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>概率期望</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卡常数]]></title>
    <url>%2F2018%2F10%2F16%2F5%2F</url>
    <content type="text"><![CDATA[Decription（在十进制下）定义 mn(i) 表示把 i 的各位数字从小到大排序得到的数，mx(i) 表示从大到小得到的数。这里的数是允许有前导零的，比如mn(10000)=00001=1 ， mx(132)=321 等。定义 f(i)=mx(i)−mn(i) 。当然，这里 mx(i) 的定义是要在某个整数 k 位十进制数下的。 卡常数指印度数学家Kaprekar发现的常数 6174 。他发现，任取一个各位数字不全相同的四位数 x，不断地使 x=f(x) ，最终总能得到 6174 。 现在Fizzydavid学习了高级的卡常数技巧，他想知道对于五位数的情况。他每次会给你一个带前导零的五位数x，要让你求出操作 x=f(x) 进行 c 次之后的结果。他每次给你的 c 都是一样的。此时 f 定义中的 k=5。 Input第一行两个整数 T,c 。T 表示询问次数，c 的含义如题面。 接下来 T 行每行一个五位数 x ，不足五位会加前导零补到五位。 Output对于每个询问输出一行表示答案。不足五位需要补到五位。 Hint1≤T≤105,1≤c≤109,0≤x&lt;105 。 20%的数据保证 c≤10 。 另外20%的数据保证 T≤10 。 另外30%的数据保证 c≥105 。 时间限制： 2s 空间限制： 512MB Solutionwoc这道题思路很Nice啊。首先会想到肯定每个数进行一定次数之后会循环(不然就没法做了a)。然后这里应该要想到我们对当前的数求循环的时候，我们事实上已经对所有经过的数求出来了，这样稍微处理一下就可以保证每个数只被访问一次。但这样还是会T a。。。于是探究性质：发现对于一个x进行a+b次操作等于先将x进行a次操作，再进行b次操作，或者反过来，再进一步想到可以倍增预处理(Nice啊).这样就欧克了a(注意倍增不要写错a在刷状态的时候QAQ) tips1.以后遇到这种性质都可以考虑倍增(LCA也有这种性质嘛)2.补充一下姿势（雾%nd 输出的整型宽度至少为n位，右对齐，%5d即宽度至少为5位，位数大于5则输出实际位数%0nd 用得比较多，表示输出的整型宽度至少为n位，不足n位用0填充printf（”%05d”,1）输出：00001printf（”%5d”,1）输出：**1（$*$为空格） The Code#include&lt;bits/stdc++.h&gt;#define maxn 100005using namespace std;int n,x,c;int g[100005][31],mx,mn,a[7];int cmp(int x,int y)&#123; return x&gt;y;&#125;int f(int x)&#123; memset(a,0,sizeof(a)); int pos=6; while(x)&#123; a[--pos]=x%10;x/=10; &#125; sort(a+1,a+6);mn=a[1]*10000+a[2]*1000+a[3]*100+a[4]*10+a[5]; sort(a+1,a+6,cmp);mx=a[1]*10000+a[2]*1000+a[3]*100+a[4]*10+a[5]; return mx-mn;&#125;void pre()&#123; for(int i=0;i&lt;=99999;i++) g[i][0]=f(i); for(int j=1;j&lt;=30;j++) for(int i=0;i&lt;=99999;i++) g[i][j]=g[g[i][j-1]][j-1]; &#125;bool vis[31];void init()&#123; scanf("%d%d",&amp;n,&amp;c); for(int i=0;i&lt;=30;i++) if(c&amp;(1&lt;&lt;i)) vis[i]=1; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;x); for(int j=0;j&lt;=30;j++) if(vis[j]) x=g[x][j]; printf("%05d\n",x); &#125;&#125;int main()&#123; pre(); init(); return 0;&#125;]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>倍增</tag>
        <tag>预处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树]]></title>
    <url>%2F2018%2F10%2F16%2F4%2F</url>
    <content type="text"><![CDATA[The Solutionemmmmmmmm，这道题题意读错了a，有点难受…很考细节的一道题，同时告诉我们细节题要对拍。首先我们要维护的是最大的剩余空间，但实质上是最大的最近距离，比如区间所剩为5和4，实际上它们的最近距离都为2。在设定友好函数时要注意。在处理好一般操作之后是特判，主要就是对于两端的处理，因为它们是独立成段的(图中红色部分)，所以只要红色长度大于最近距离即更优。最后要注意标号尽可能小的细节。 The Code#include&lt;bits/stdc++.h&gt;#define maxn 200005using namespace std;struct node&#123; int l,r; friend bool operator &lt;(node a,node b)&#123; if((a.r-a.l)/2!=(b.r-b.l)/2)return (a.r-a.l)/2&gt;(b.r-b.l)/2; //排得是这个最近距离aQAQ 并且不能将2免去，因为奇偶 else return a.l&lt;b.l; &#125;&#125;;set&lt;node&gt;s;set&lt;node&gt;::iterator it;int n,m,x,y;map&lt;int,int&gt;mp;int pre[maxn],next[maxn],st[maxn],rk[maxn];int np=0; void init()&#123; scanf("%d%d",&amp;n,&amp;m); s.insert((node)&#123;0,n+1&#125;); pre[0]=0;next[0]=n+1;pre[n+1]=0;next[n+1]=n+1; for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d",&amp;x,&amp;y); /*if(x==1)&#123; if(t.l==0&amp;&amp;t.r==n+1)&#123; st[np]=1; rk[1]=np; next[0]=1; next[1]=n+1; pre[n+1]=1; s.erase((node)&#123;0,n+1&#125;); s.insert((node)&#123;0,1&#125;);s.insert((node)&#123;1,n+1&#125;); printf("1\n");continue; &#125; if(t.l==1&amp;&amp;t.r==n+1)&#123; st[np]=n; rk[n]=np; pre[n]=1; next[n]=n+1; pre[n+1]=n; next[0]=1; s.erase((node)&#123;1,n+1&#125;); s.insert((node)&#123;1,n&#125;);s.insert((node)&#123;n,n+1&#125;); printf("%d\n",n);continue; &#125;*/ if(x==1)&#123; mp[y]=++np; it=s.begin(); node t=*it; int len=(t.r-t.l)/2; bool ok1=false,ok2=false; int len1=0,len2=0; if(!rk[1]) len1=next[0]-1;if(!rk[n]) len2=n-pre[n+1]; if(len2&gt;len1) ok2=true;else ok1=true;//标号 if(!rk[1]&amp;&amp;ok1)&#123;//要考虑两端点的问题 if(next[0]-1&gt;=len)&#123;//标号优先 st[np]=1; rk[1]=np; next[1]=next[0];pre[next[0]]=1;next[0]=1; s.erase((node)&#123;0,next[1]&#125;); s.insert((node)&#123;0,1&#125;); s.insert((node)&#123;1,next[1]&#125;); printf("1\n");continue; &#125; &#125; if(!rk[n]&amp;&amp;ok2)&#123; if(n-pre[n+1]&gt;len)&#123; st[np]=n; rk[n]=np; pre[n]=pre[n+1];next[pre[n+1]]=n;pre[n+1]=n; s.erase((node)&#123;pre[n],n+1&#125;); s.insert((node)&#123;n,n+1&#125;); s.insert((node)&#123;pre[n],n&#125;); printf("%d\n",n);continue; &#125; &#125; int position=t.l+len;rk[position]=np;st[np]=position; pre[position]=t.l;next[position]=t.r;pre[t.r]=position; next[t.l]=position; printf("%d\n",position); s.erase((node)&#123;pre[position],next[position]&#125;); s.insert((node)&#123;pre[position],position&#125;); s.insert((node)&#123;position,next[position]&#125;); &#125; else&#123; int t=st[mp[y]]; s.erase((node)&#123;pre[t],t&#125;); s.erase((node)&#123;t,next[t]&#125;); s.insert((node)&#123;pre[t],next[t]&#125;); rk[t]=0; next[pre[t]]=next[t]; pre[next[t]]=pre[t]; pre[t]=next[t]=0; &#125; &#125;&#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[减肥计划]]></title>
    <url>%2F2018%2F10%2F15%2F3%2F</url>
    <content type="text"><![CDATA[Solution哇，这道题还是太急了，探究出个性质就直接溜了。首先当$\sum{a_i}$一定时，$\sum{b_i}$越大肯定越优，那么可以dp[i]表示$\sum{a_i}$为i时最大的$\sum{b_i}$之值。由于a的和为$n \ast max({a_i})$，所以总的复杂度会是$n^2 \ast max({a_i})$。显然会超时。所以我们来探求性质，发现当答案为$\frac{\sum{a_i}}{\sum{b_i}}$，若此时有$\frac{a_i}{b_i}$大于它时，那么加入一定会增大，反之加入小于的会减小，所以我们对于一个答案，不断删去小于它的$\frac{a_i}{b_i}$，直到$\sum{a_i}$&lt;m后停下来，那么过程中不会减小，此时再加入大于的即可，所以最多只用dp到$max({a_i})+m$，因此时间复杂度也降为$n \ast (m+max({a_i}))$ ，即可通过此题。 上代码： Code#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;queue&gt;#define maxn 10000005using namespace std;typedef long long ll;int n,m;ll dp[maxn&lt;&lt;1],a[maxn],b[maxn];ll gcd(ll x,ll y)&#123; if(y==0) return x; else return gcd(y,x%y);&#125;ll maxx=0,sum=0;void init()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;a[i],&amp;b[i]),maxx=max(maxx,a[i]),sum+=a[i]; if(sum&lt;m)&#123;printf("-1");return;&#125; for(int i=1;i&lt;=m+maxx;i++) dp[i]=-0x3f3f3f3f; dp[0]=0; for(int i=1;i&lt;=n;i++) for(int j=maxx+m;j&gt;=a[i];j--) dp[j]=max(dp[j],dp[j-a[i]]+b[i]); ll fz=-1,fm=1; for(int i=m;i&lt;=maxx+m;i++) if(fz*i&lt;dp[i]*fm) fz=dp[i],fm=i; ll g=gcd(fz,fm); fz/=g;fm/=g; printf("%d/%d",fz,fm); &#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>dp</tag>
        <tag>正睿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正睿普转提9.16]]></title>
    <url>%2F2018%2F10%2F15%2F14%2F</url>
    <content type="text"><![CDATA[代码记录…T1#include&lt;bits/stdc++.h&gt;#define maxn 100005using namespace std;typedef long long ll;int n,fa[maxn],ch[maxn][2],x;ll st[maxn],a[maxn];int top=0;void dfs(int i)&#123; if(ch[i][0]) dfs(ch[i][0]); st[++top]=a[i]; if(ch[i][1]) dfs(ch[i][1]);&#125; ll q[maxn];int rear=0;void run(ll x)&#123; /*if(x&gt;=q[rear])&#123; q[++rear]=x; return; &#125; int l=1,r=rear,mid; while(l&lt;=r)&#123; mid=(l+r)&gt;&gt;1; if(q[mid-1]&lt;=x&amp;&amp;x&lt;q[mid])&#123;q[mid]=x;return;&#125; if(x&lt;q[mid-1]) r=mid-1; else l=mid+1; &#125;*/ int t=upper_bound(q+1,q+rear+1,x)-q; if(t==rear+1) q[++rear]=x; else q[t]=x;//将刚好大于它的代替，这里是运用了贪心思想a&#125;void init()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]); for(int i=2;i&lt;=n;i++)&#123; scanf("%d%d",&amp;fa[i],&amp;x); ch[fa[i]][x]=i; &#125; dfs(1); for(ll i=1;i&lt;=top;i++) st[i]=st[i]-i; q[0]=-10000000000; for(int i=1;i&lt;=top;i++) run(st[i]); int ans=n-rear; printf("%d",ans);&#125;int main()&#123; init(); return 0;&#125; T2#include&lt;bits/stdc++.h&gt;#define maxn 500005using namespace std;int n,a[maxn],np=0,rt=0;int gcd(int x,int y)&#123; if(y==0) return x; else return gcd(y,x%y);&#125;int minv[maxn][20],gcdd[maxn][20],logg[maxn],w[25];void ready()&#123; w[0]=1; logg[0]=-1; for(int i=1;i&lt;=20;i++) w[i]=w[i-1]*2; for(int i=1;i&lt;=maxn-5;i++) logg[i]=logg[i/2]+1; for(int i=1;i&lt;=n;i++)&#123; minv[i][0]=gcdd[i][0]=a[i]; &#125; for(int i=1;i&lt;=logg[n];i++)//加个1保个险 for(int j=1;j&lt;=n;j++) if(j+w[i]-1&lt;=n)&#123; minv[j][i]=min(minv[j][i-1],minv[j+w[i-1]][i-1]);//本来是j+(1&lt;&lt;(i-1))-1+1 gcdd[j][i]=gcd(gcdd[j][i-1],gcdd[j+w[i-1]][i-1]); &#125; &#125;int cd1(int i,int j)&#123; int len=j-i+1; int t=logg[len]; return min(minv[i][t],minv[j-w[t]+1][t]);&#125;int cd2(int i,int j)&#123; int len=j-i+1; int t=logg[len]; return gcd(gcdd[i][t],gcdd[j-w[t]+1][t]);&#125;int st[maxn],top=0,yb[maxn],topp=0;bool check(int mid)&#123; topp=0; bool ok=false; for(int i=1;i&lt;=n-mid+1;i++)&#123; int j=i+mid-1; if(cd1(i,j)==cd2(i,j))&#123; ok=true; yb[++topp]=i; &#125; &#125; if(ok)&#123; top=0; for(int i=1;i&lt;=topp;i++) st[++top]=yb[i]; return true; &#125; return false;&#125;void run()&#123; int A=1,B=n,mid,ans; while(A&lt;=B)&#123; mid=A+B&gt;&gt;1; if(check(mid)) ans=mid,A=mid+1; else B=mid-1; &#125; printf("%d %d\n",top,ans-1);//L-R for(int i=1;i&lt;=top;i++) printf("%d ",st[i]);&#125; void init()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); ready(); run(); &#125;int main()&#123; init(); return 0;&#125; T3#include&lt;bits/stdc++.h&gt;#define maxn 55using namespace std;typedef long long ll;const ll mod=1e9+7;ll c[maxn][maxn],dp[maxn][maxn];int p[maxn],n;void ready()&#123; for(int i=0;i&lt;=50;i++)&#123; c[i][0]=1; for(int j=1;j&lt;=i;j++) c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod; &#125;&#125;ll dfs(int len,int now)&#123; if(dp[len][now]!=-1) return dp[len][now]; if(len==1) return dp[len][now]=1; ll ans=0;int j,k,pos=0,t[maxn];//pos和t只有内定了给，不然要重 函数递归时会改变 for(int i=1;i&lt;=n;i++) if(p[i]&gt;=now&amp;&amp;p[i]&lt;now+len) t[++pos]=p[i];//pos==len for(int i=1;i&lt;pos;i++)&#123; swap(t[i],t[i+1]);//枚举交换的位置 for(j=1;j&lt;=i;j++)//判断是否满足 if(t[j]&gt;=now+i) break;//最多为now+i-1; for(k=i+1;k&lt;=pos;k++) if(t[k]&lt;now+i) break;//最小为now+i; if(j&gt;i&amp;&amp;k&gt;pos)&#123; ll t1=dfs(i,now); ll t2=dfs(pos-i,now+i); ans=(ans+t1*t2%mod*c[pos-2][i-1]%mod)%mod;//第一个:now~now+i-1 第二个now+i~now+len-1; //在这之前进行n-2次交换,前i-1次选择前面来处理前面的i个 &#125; swap(t[i],t[i+1]); &#125; return dp[len][now]=ans; &#125;void init()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;p[i]); memset(dp,-1,sizeof(dp)); dfs(n,0); if(dp[n][0]==-1) printf("%d",0); else printf("%lld",dp[n][0]);&#125;int main()&#123; ready(); init(); return 0;&#125; T4#include&lt;bits/stdc++.h&gt;#define maxn 305using namespace std;int n,m,k;double a[maxn],b[maxn*maxn];//b:(k-x,m-x)/(k,m) 而x最多为n^2void ready()&#123; a[0]=1.0; for(int i=1;i&lt;=n;i++) a[i]=a[i-1]*(n-i+1)*1.0/i; b[0]=1; for(int i=1;i&lt;=n*n;i++) b[i]=b[i-1]*(k-i+1)*1.0/(m-i+1); &#125; void outt()&#123; printf("1"); for(int i=1;i&lt;=99;i++) printf("0");&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); ready(); double ans=0; for(int i=0;i&lt;=n;i++) for(int j=0;j&lt;=n;j++)&#123; int x=(i+j)*n-i*j; if(x&gt;k) break;//再加只会更多 ans+=a[i]*a[j]*b[x]; &#125; if(ans&gt;1e99) outt(); else printf("%lf",ans); return 0;&#125;]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>概率期望</tag>
        <tag>数学</tag>
        <tag>dp</tag>
        <tag>LIS</tag>
        <tag>ST表</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小瓶颈生成树]]></title>
    <url>%2F2018%2F10%2F15%2F2%2F</url>
    <content type="text"><![CDATA[所谓最小瓶颈生成树….就是使得生成树树上最大边权值最小。这里主要介绍一种期望O（M）（线性）的求法，其实主要就是二分，具体思路如下： 类比找第k大值的方法，首先随机一个边权w。 然后将不超过这个边权的边加入，遍历这张图。 如果图连通，那么瓶颈不超过w，于是只需考虑边权不超过w的边。 否则将这些连通点缩起来，考虑边权大于w的边。 每次将问题的规模缩小至一半。 期望时间复杂度O(m)。 相关例题有两道：A.Hangar Hurdles (CERC 16) 有一个n*n的网格图，上面有些格子可行，有些格子是障碍。 有Q个询问，想把一个正方形箱子从(r1,c1)推到(r2,c2)，问箱子最大的大小。（起点终点是正方形箱子的中点） N&lt;=1000 Q&lt;=300000 B.洪蛤吨有一个宽度为L的管道，我们可以视其为一条y=L的直线与X轴所夹的部分。 （所以这根管道的长度可以视为正无穷） 这个管道中有个N个障碍点，第i个障碍点的坐标为(Xi,Yi)。 已知有一个球体，能在不碰到障碍点的前提下，从管道的最左端走到最右端。（即从管道内横坐标负无穷的地方走到横坐标正无穷的地方）。 求这个球体的直径最大是多少。为了避免精度误差，请输出答案保留三位小数的结果。 两题有异曲同工之妙a…（/滑稽，思路差不多…）都可以用最小瓶颈树实现复杂度最小下面上一下t2的代码：（没有用最小瓶颈树优化，逃） #include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;queue&gt;#define maxn 505using namespace std;struct eage&#123; int u,v; double dist;&#125;e[maxn*maxn/2+maxn*2];bool cmp(eage a,eage b)&#123; return a.dist&lt;b.dist;&#125;double dis(int x1,int y1,int x2,int y2)&#123; return sqrt(1.0*(x1-x2)*(x1-x2)+1.0*(y1-y2)*(y1-y2)); &#125;int fa[maxn];int find(int x)&#123; if(fa[x]==x) return x; int root=find(fa[x]); fa[x]=root; return root;&#125;void link(int x,int y)&#123; int fx=find(x),fy=find(y); if(fx!=fy)&#123; fa[fx]=fy; &#125; &#125;bool check(int x,int y)&#123; int fx=find(x),fy=find(y); if(fx!=fy) return false; return true;&#125;int l,n;struct node&#123; int x,y;&#125;nd[maxn];void init()&#123; int pos=0; scanf("%d%d",&amp;n,&amp;l); for(int i=1;i&lt;=n+2;i++) fa[i]=i;//n+1是上，n+2是下 for(int i=1;i&lt;=n;i++)&#123; scanf("%d%d",&amp;nd[i].x,&amp;nd[i].y); &#125; for(int i=1;i&lt;=n;i++)&#123; e[++pos]=(eage)&#123;i,n+1,l-nd[i].y&#125;; e[++pos]=(eage)&#123;i,n+2,nd[i].y&#125;; for(int j=i+1;j&lt;=n;j++)&#123; e[++pos]=(eage)&#123;i,j,dis(nd[i].x,nd[i].y,nd[j].x,nd[j].y)&#125;; &#125; &#125; int cnt=0; sort(e+1,e+pos+1,cmp); for(int i=1;i&lt;=pos;i++)&#123; int u=e[i].u,v=e[i].v; if(check(u,v)) continue; link(u,v); cnt++; if(find(n+1)==find(n+2))&#123;//只要上底和下底连接了就行 这样才能保证极大值可以通过，如果后面更大，那这里是过不了的 printf("%.3f",e[i].dist); break; &#125; &#125;&#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>最小瓶颈生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UpdateAfterEvent]]></title>
    <url>%2F2018%2F10%2F15%2F1%2F</url>
    <content type="text"><![CDATA[Description​ 小松鼠打了10个小时的游戏，一脸满足。却发现周围再次围满了游客，逃！ 她发现整个西湖内的松鼠都以相同的速度在树之间跳跃。每跳跃一次花费一个单位的时间。我们可以把西湖抽象为一张n个点的无向图，初始时每个点上都有若干只松鼠，它们每单位时间都可以沿着一条无向边进行跳跃。 对于一只当前在点i的松鼠，它在接下来的一个单位时间内等概率向相邻的点跳跃。更具体地讲，我们称与点i通过一条无向边直接相连的点为与i相邻的点，假设这样的点有p个，那么对于每一个与i相邻的点，在下一时刻都有1/p的概率跳到它。 超萌小松鼠已知初始时刻（0时刻）每棵树上的松鼠分布情况，她想知道在T时刻，在同一棵树上的松鼠对数的期望。关于“松鼠对数”的解释：假设有4只松鼠在同一棵树上，那么我们称有6对在同一棵树上的松鼠。为了避免精度误差，我们将答案模10^9 + 7输出。 Input​ 第一行三个数n，T。意义如题面中所述。接下来一行n个数，第i个数ai表示第i个点初始时刻有ai只松鼠。接下来n行，每行n个数，第i行第j个数如果为1表示点i与点j间有无向边相连，为0则表示没有。 Output​ 输出一行一个数，表示T时刻在同一棵树上的松鼠对数的期望在模10^9 +7意义下的答案。 Solution这道题考察了许多知识点，考察综合能力。 首先，题目总体是考察概率期望，但切忌陷入思路死角，去求每棵树上的最终期望松鼠对数。实际上，我们对于每只松鼠，去求它到某点的概率p,那么每两只松鼠在某点的期望便是p1p21（还有很多可转化为概率来做的期望题）由于要除法取模，要预先递推求出逆元，复习一下公式：inv[1]=1;inv[i]=(mod-mod/i)*inv[mod%i]%mod. 那么对于松鼠到某点的概率求取，我们先O(N^2)求出最开始互相连点之间的概率，然后每一时刻，枚举中间点，进行概率传递，由于t比较大，可以用矩阵快速幂思想来将其优化到log2n级别。 最后，由于我们计算期望是O（n^3）的，无法过n&lt;=1000的点，发现如下式子： 设p(i,j)为i到j点的概率。假设计算终点在1，则ans=p(1,1)p(2,1)+p(1,1)p(3,1)…..+p(1,1)p(n,1)+p(2,1)p(3,1)+p(2,1)p(4,1)+…….发现可以转化为p(1,1)(p(2,1)+p(3,1)+p(4,1)+….+p(n,1))+p(2,1)(p(3,1)+p(4,1)+…..+p(n,1)).由此发现是可以前缀和优化的，由此只用枚举一点和终点，从而变成O(N^2).当然可以每个统计一次，然后最后除以2.貌似更方便哈….. The Code#include&lt;bits/stdc++.h&gt;#define maxn 1005using namespace std;typedef long long ll;const ll mod=1e9+7;struct matrix&#123; ll a[maxn][maxn];&#125;nd,ans;int n,t,e[maxn][maxn];matrix operator *(matrix &amp;x,matrix &amp;y)&#123; matrix c; memset(c.a,0,sizeof(c.a)); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=n;k++)&#123; c.a[i][j]=(c.a[i][j]+(x.a[i][k]*y.a[k][j])%mod)%mod; &#125; return c;&#125;void pow(int t)&#123; for(int i=1;i&lt;=n;i++) ans.a[i][i]=1; while(t)&#123; if(t&amp;1) ans=ans*nd;//最后为1 nd=nd*nd; t/=2; &#125;&#125;ll p[maxn][maxn],inv[maxn],v[maxn];void init()&#123; scanf("%d%d",&amp;n,&amp;t); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;v[i]); inv[1]=1; for(int i=2;i&lt;=1000;i++) inv[i]=(mod-mod/i)*inv[mod%i]%mod; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf("%d",&amp;e[i][j]); memset(nd.a,0,sizeof(nd.a)); for(int i=1;i&lt;=n;i++)&#123; int res=0; for(int j=1;j&lt;=n;j++) res+=e[i][j]; for(int j=1;j&lt;=n;j++) nd.a[i][j]=inv[res]*e[i][j]; &#125; if(t&gt;1)&#123; pow(t); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) p[i][j]=ans.a[i][j]; &#125; else&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) p[i][j]=nd.a[i][j]; &#125; ll calc=0; for(int i=1;i&lt;=n;i++)&#123; ll t1=0,t2=0; for(int j=1;j&lt;=n;j++)&#123; ll tt=(p[j][i]*v[j])%mod; t1=(t1+tt)%mod; t2=(t2+tt*p[j][i])%mod; &#125; calc=(calc+(t1*t1%mod-t2+mod)%mod*inv[2]%mod)%mod; &#125; printf("%lld",calc);&#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>noip模拟赛</category>
      </categories>
      <tags>
        <tag>概率期望</tag>
        <tag>前缀和优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[祎隋]]></title>
    <url>%2F2018%2F10%2F14%2Fkk%2F</url>
    <content type="text"><![CDATA[祎隋如你，春风十里不及你《祎隋》 无需仰首，我已知晓 那阳光濡缕，和风轻挠 不用回头，我已知晓 那鲜艳裙摆 ，恬然一笑 …… 因你自嘲，为你歌声倾倒 附上小鞠美图一张]]></content>
      <categories>
        <category>杂诗</category>
      </categories>
      <tags>
        <tag>杂诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文章分类]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
