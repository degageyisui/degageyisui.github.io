<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>左偏树</title>
      <link href="/2019/01/21/%E5%B7%A6%E5%81%8F%E6%A0%91/"/>
      <url>/2019/01/21/%E5%B7%A6%E5%81%8F%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>左偏树（可并堆</p><p>[也是logn维护优先级，比优先队列优在可logn合并两个优先队列而且本身更加灵活。</p><p>主要两个操作：</p><p>merge:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line"><span class="keyword">if</span>(c[x]&lt;c[y]) swap(x,y);</span><br><span class="line">ch[x][<span class="number">1</span>]=merge(ch[x][<span class="number">1</span>],y);</span><br><span class="line"><span class="keyword">if</span>(dis[ch[x][<span class="number">0</span>]]&lt;dis[ch[x][<span class="number">1</span>]]) swap(ch[x][<span class="number">0</span>],ch[x][<span class="number">1</span>]);</span><br><span class="line">dis[x]=dis[ch[x][<span class="number">1</span>]]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> x; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>del:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> merge(ch[x][<span class="number">0</span>],ch[x][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.org/problemnew/show/P1552" target="_blank" rel="noopener">例题 [APIO2012]派遣</a></p><p>实际上是用可并堆分开维护子树最大值，来保持可覆盖的点多，再依次尝试领导点。</p><p>code:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eage</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,next;</span><br><span class="line">&#125;e[maxn];</span><br><span class="line"><span class="keyword">int</span> np=<span class="number">0</span>,first[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">e[++np]=(eage)&#123;v,first[u]&#125;;</span><br><span class="line">first[u]=np;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,x,ch[maxn][<span class="number">2</span>],dis[maxn],rt;</span><br><span class="line">ll c[maxn],sz[maxn],l[maxn],sum[maxn];</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!x||!y) <span class="keyword">return</span> x+y;</span><br><span class="line"><span class="keyword">if</span>(c[x]&lt;c[y]) swap(x,y);</span><br><span class="line">ch[x][<span class="number">1</span>]=merge(ch[x][<span class="number">1</span>],y);</span><br><span class="line"><span class="keyword">if</span>(dis[ch[x][<span class="number">0</span>]]&lt;dis[ch[x][<span class="number">1</span>]]) swap(ch[x][<span class="number">0</span>],ch[x][<span class="number">1</span>]);</span><br><span class="line">dis[x]=dis[ch[x][<span class="number">1</span>]]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> x; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> merge(ch[x][<span class="number">0</span>],ch[x][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="comment">//树型dp用可并堆维护最大值（最小的都留下了 贪心 </span></span><br><span class="line">sum[i]=c[i];sz[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> A=i,B;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> p=first[i];p;p=e[p].next)&#123;</span><br><span class="line"><span class="keyword">int</span> j=e[p].to;</span><br><span class="line">B=dfs(j);</span><br><span class="line">A=merge(B,A);</span><br><span class="line">sz[i]+=sz[j];sum[i]+=sum[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(sum[i]&gt;m)&#123;</span><br><span class="line">sum[i]-=c[A];sz[i]--;</span><br><span class="line">A=del(A);</span><br><span class="line">&#125;</span><br><span class="line">ans=max(ans,(ll)sz[i]*l[i]);</span><br><span class="line"><span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%lld%lld"</span>,&amp;x,&amp;c[i],&amp;l[i]);</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">0</span>) rt=i;</span><br><span class="line"><span class="keyword">else</span> add(x,i);</span><br><span class="line">&#125;</span><br><span class="line">dfs(rt);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 省选 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 左偏树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>lct模板</title>
      <link href="/2019/01/19/lct/"/>
      <url>/2019/01/19/lct/</url>
      
        <content type="html"><![CDATA[<p>lct模板：（一旦访问就要pushdown!!!</p><p>（在一个点为该splay根节点时，不能对它父亲操作（否则造成巨大错误，性质2，认父不认子</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 300005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,op;</span><br><span class="line"><span class="keyword">int</span> val[maxn],sum[maxn],fa[maxn],ch[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> st[maxn];</span><br><span class="line"><span class="keyword">bool</span> rev[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>]==x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">bool</span> kind)</span></span>&#123;</span><br><span class="line">fa[x]=y;ch[y][kind]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">nroot</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//not root 连父轻边 </span></span><br><span class="line">    <span class="keyword">return</span> ch[fa[x]][<span class="number">0</span>]==x||ch[fa[x]][<span class="number">1</span>]==x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upload</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    sum[x]=sum[ch[x][<span class="number">0</span>]]^sum[ch[x][<span class="number">1</span>]]^val[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">download</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rev[x]) <span class="keyword">return</span>;</span><br><span class="line">    swap(ch[x][<span class="number">0</span>],ch[x][<span class="number">1</span>]);</span><br><span class="line">    rev[ch[x][<span class="number">0</span>]]^=<span class="number">1</span>;rev[ch[x][<span class="number">1</span>]]^=<span class="number">1</span>;</span><br><span class="line">    rev[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y=fa[x],z=fa[y];</span><br><span class="line">    <span class="keyword">int</span> kind=check(x);</span><br><span class="line">    <span class="keyword">int</span> k=ch[x][!kind];</span><br><span class="line">    link(k,y,kind);</span><br><span class="line">    <span class="keyword">if</span>(nroot(y)) link(x,z,check(y));fa[x]=z;</span><br><span class="line">    link(y,x,!kind);</span><br><span class="line">    upload(y);upload(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//一旦访问就要pushdown!!!</span></span><br><span class="line">    <span class="keyword">int</span> y=x,top=<span class="number">0</span>;</span><br><span class="line">    st[++top]=y;</span><br><span class="line">    <span class="keyword">while</span>(nroot(y)) st[++top]=fa[y],y=fa[y];</span><br><span class="line">    <span class="keyword">while</span>(top) download(st[top--]);</span><br><span class="line">    <span class="keyword">while</span>(nroot(x))&#123;</span><br><span class="line">        y=fa[x];</span><br><span class="line">        <span class="keyword">if</span>(nroot(y)) check(x)^check(y)?rotate(x):rotate(y);</span><br><span class="line">        rotate(x);</span><br><span class="line">    &#125;</span><br><span class="line">    upload(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;x;y=x,x=fa[x])<span class="comment">//一直打通到根</span></span><br><span class="line">    splay(x),ch[x][<span class="number">1</span>]=y,upload(x); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeroot</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    access(x);splay(x);</span><br><span class="line">    rev[x]^=<span class="number">1</span>;download(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findroot</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    access(x);splay(x);</span><br><span class="line">    <span class="keyword">while</span>(ch[x][<span class="number">0</span>]) download(x),x=ch[x][<span class="number">0</span>];</span><br><span class="line">    splay(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    makeroot(x);</span><br><span class="line">    access(y);</span><br><span class="line">    splay(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    makeroot(x);</span><br><span class="line">    <span class="keyword">if</span>(findroot(y)==x) <span class="keyword">return</span>;<span class="comment">//是否在同一splay上,findroot找深度最小点（根 </span></span><br><span class="line">    fa[x]=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    makeroot(x);</span><br><span class="line">    <span class="keyword">if</span>(findroot(y)==x&amp;&amp;fa[y]==x&amp;&amp;!ch[y][<span class="number">0</span>])<span class="comment">//findroot(y)如果找到了x，则将x提到了最高处(splay(x)) </span></span><br><span class="line">    fa[y]=ch[x][<span class="number">1</span>]=<span class="number">0</span>,upload(x);<span class="comment">//想象图，y左边如果有任何，则y和x深度相差不为1，则无边 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;val[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;op,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">0</span>) split(x,y),<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum[y]);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>) link(x,y);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">2</span>) cut(x,y);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">3</span>) splay(x),val[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及最后的cut操作，想象图，利用深度严格递增的性质来解题</p>]]></content>
      
      
      <categories>
          
          <category> 省选 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lct </tag>
            
            <tag> 动态树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>平衡树板子</title>
      <link href="/2019/01/18/%E6%9D%83%E5%80%BC%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
      <url>/2019/01/18/%E6%9D%83%E5%80%BC%E5%B9%B3%E8%A1%A1%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>qwq蒟蒻太蒻了a发现自己splay都不会敲了</p><p>权值平衡树：（按照权值的大小来维护，左边小右边大<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="keyword">int</span> val[maxn],cnt[maxn],ch[maxn][<span class="number">2</span>],fa[maxn],sz[maxn],rt=<span class="number">0</span>,np=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==ch[fa[x]][<span class="number">1</span>];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">bool</span> kind)</span></span>&#123;</span><br><span class="line">fa[x]=y;ch[y][kind]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upload</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">sz[x]=sz[ch[x][<span class="number">0</span>]]+sz[ch[x][<span class="number">1</span>]]+cnt[x]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> y=fa[x],z=fa[y];</span><br><span class="line"><span class="keyword">bool</span> kind=check(x);</span><br><span class="line"><span class="keyword">int</span> k=ch[x][!kind];</span><br><span class="line">link(k,y,kind);</span><br><span class="line">link(x,z,check(y));<span class="comment">//原来y在z哪边 在y连x之前，否则就变了 </span></span><br><span class="line">link(y,x,!kind); </span><br><span class="line">upload(y);upload(x); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> goal)</span></span>&#123;<span class="comment">//代入的为编号,val[x]才为它实际值 </span></span><br><span class="line"><span class="keyword">while</span>(fa[x]!=goal)&#123;</span><br><span class="line"><span class="keyword">int</span> y=fa[x],z=fa[y];</span><br><span class="line"><span class="keyword">if</span>(z!=goal) (check(x)^check(y))?rotate(x):rotate(y);<span class="comment">//z等于goal旋一次就欧克了 </span></span><br><span class="line">rotate(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(fa[x]==<span class="number">0</span>) rt=x;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> now=rt;</span><br><span class="line"><span class="keyword">while</span>(ch[now][x&gt;val[now]]&amp;&amp;val[now]!=x) </span><br><span class="line"> now=ch[now][x&gt;val[now]];<span class="comment">//如果没有这个数就停顿 </span></span><br><span class="line">splay(now,<span class="number">0</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//插入权值 </span></span><br><span class="line"><span class="keyword">int</span> f=<span class="number">0</span>,now=rt;</span><br><span class="line"><span class="keyword">while</span>(now&amp;&amp;val[now]!=x) f=now,now=ch[now][x&gt;val[now]];</span><br><span class="line"><span class="keyword">if</span>(now) cnt[now]++;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">now=++np;</span><br><span class="line">val[now]=x;</span><br><span class="line"><span class="keyword">if</span>(f) ch[f][x&gt;val[f]]=now;</span><br><span class="line">fa[now]=f;</span><br><span class="line">cnt[now]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">splay(now,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prnx</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">bool</span> f)</span></span>&#123;<span class="comment">//x为值，返回的为编号 </span></span><br><span class="line">find(x);</span><br><span class="line"><span class="keyword">int</span> now=rt;</span><br><span class="line"><span class="keyword">if</span>(val[now]&lt;x&amp;&amp;!f||val[now]&gt;x&amp;&amp;f) <span class="keyword">return</span> now;</span><br><span class="line">now=ch[now][f];</span><br><span class="line"><span class="keyword">while</span>(ch[now][!f]) now=ch[now][!f];</span><br><span class="line"><span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pre=prnx(x,<span class="number">0</span>),last=prnx(x,<span class="number">1</span>);</span><br><span class="line">splay(pre,<span class="number">0</span>);splay(last,pre);</span><br><span class="line">    <span class="keyword">int</span> delt=ch[last][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(cnt[delt]&gt;<span class="number">1</span>) &#123;cnt[delt]--,splay(delt,<span class="number">0</span>);&#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;ch[last][<span class="number">0</span>]=<span class="number">0</span>;splay(last,<span class="number">0</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> k)</span></span>&#123;<span class="comment">//查询当前子树的第k的编号 </span></span><br><span class="line"><span class="keyword">if</span>(sz[now]&lt;k) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//不存在的</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(k&gt;sz[ch[now][<span class="number">0</span>]]+cnt[now]) k-=cnt[now]+sz[ch[now][<span class="number">0</span>]],now=ch[now][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(sz[ch[now][<span class="number">0</span>]]&gt;=k) now=ch[now][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">splay(now,<span class="number">0</span>);<span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//查询值为x的排名第几 </span></span><br><span class="line">    find(x);</span><br><span class="line">    <span class="keyword">return</span> sz[ch[rt][<span class="number">0</span>]]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,opt,x;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">insert(INT_MIN);</span><br><span class="line">insert(INT_MAX);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;opt,&amp;x);</span><br><span class="line"><span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;</span><br><span class="line">insert(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(opt==<span class="number">2</span>)&#123;</span><br><span class="line">del(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(opt==<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,kth(x)<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(opt==<span class="number">4</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,val[kth(rt,x+<span class="number">1</span>)]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(opt==<span class="number">5</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,val[prnx(x,<span class="number">0</span>)]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(opt==<span class="number">6</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,val[prnx(x,<span class="number">1</span>)]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>文艺平衡树：（按照中序遍历来维护，中序遍历不会变，如果插入是按照编号顺序的，那么可以理解为左边编号小，右边编号大</p><p>所以如果你在一个文艺平衡树中写find同时又要维护它的性质，那么就可以加一个rank函数来返回值在其中的编号，来维持中序遍历</p><p>code:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,l,r;</span><br><span class="line"><span class="keyword">int</span> val[maxn],cnt[maxn],sz[maxn],ch[maxn][<span class="number">2</span>],fa[maxn],rt=<span class="number">0</span>,np=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==ch[fa[x]][<span class="number">1</span>];&#125;</span><br><span class="line"><span class="keyword">bool</span> rev[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">bool</span> kind)</span></span>&#123;</span><br><span class="line">fa[x]=y;ch[y][kind]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">download</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!rev[x]) <span class="keyword">return</span>;</span><br><span class="line">swap(ch[x][<span class="number">0</span>],ch[x][<span class="number">1</span>]);</span><br><span class="line">rev[ch[x][<span class="number">0</span>]]^=<span class="number">1</span>;rev[ch[x][<span class="number">1</span>]]^=<span class="number">1</span>;</span><br><span class="line">rev[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upload</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">sz[x]=sz[ch[x][<span class="number">0</span>]]+sz[ch[x][<span class="number">1</span>]]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> y=fa[x],z=fa[y];</span><br><span class="line"><span class="keyword">bool</span> kind=check(x);</span><br><span class="line"><span class="keyword">int</span> k=ch[x][!kind];</span><br><span class="line">link(k,y,kind);</span><br><span class="line">link(x,z,check(y));</span><br><span class="line">link(y,x,!kind);</span><br><span class="line">upload(y);upload(x); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> goal)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(fa[x]!=goal)&#123;</span><br><span class="line"> <span class="keyword">int</span> y=fa[x],z=fa[y];</span><br><span class="line"> <span class="keyword">if</span>(z!=goal) (check(x)^check(y))?rotate(x):rotate(y);</span><br><span class="line"> rotate(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(fa[x]==<span class="number">0</span>) rt=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> now=rt;</span><br><span class="line"><span class="keyword">while</span>(ch[now][x&gt;val[now]]&amp;&amp;val[now]!=x) now=ch[now][x&gt;val[now]];</span><br><span class="line">splay(now,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> now=rt,f=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(now) f=now,now=ch[now][<span class="number">1</span>];</span><br><span class="line">now=++np;</span><br><span class="line">link(now,f,<span class="number">1</span>);cnt[now]=<span class="number">1</span>;val[now]=x;</span><br><span class="line">splay(now,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prnx</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">bool</span> f)</span></span>&#123;</span><br><span class="line">find(x);</span><br><span class="line"><span class="keyword">int</span> now=rt;</span><br><span class="line"><span class="keyword">if</span>(val[now]&lt;x&amp;&amp;!f||val[now]&gt;x&amp;&amp;f) <span class="keyword">return</span> now;</span><br><span class="line">    now=ch[now][f];</span><br><span class="line">    <span class="keyword">while</span>(ch[now][!f]) now=ch[now][!f];</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">download(now);</span><br><span class="line"><span class="keyword">if</span>(k&lt;=sz[ch[now][<span class="number">0</span>]]) <span class="keyword">return</span> kth(ch[now][<span class="number">0</span>],k);</span><br><span class="line"><span class="keyword">if</span>(k&gt;sz[ch[now][<span class="number">0</span>]]+<span class="number">1</span>) <span class="keyword">return</span> kth(ch[now][<span class="number">1</span>],k-sz[ch[now][<span class="number">0</span>]]<span class="number">-1</span>);</span><br><span class="line">splay(now,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rvs</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=kth(rt,l);</span><br><span class="line"><span class="keyword">int</span> y=kth(rt,r+<span class="number">2</span>);</span><br><span class="line">splay(x,<span class="number">0</span>);splay(y,x);</span><br><span class="line">rev[ch[y][<span class="number">0</span>]]^=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">download(now);</span><br><span class="line"><span class="keyword">if</span>(ch[now][<span class="number">0</span>]) out(ch[now][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">if</span>(now!=<span class="number">1</span>&amp;&amp;now!=n+<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"%d "</span>,val[now]);</span><br><span class="line"><span class="keyword">if</span>(ch[now][<span class="number">1</span>]) out(ch[now][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n+<span class="number">1</span>;i++) insert(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">rvs(l,r);</span><br><span class="line">&#125;</span><br><span class="line">out(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 省选 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 平衡树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>后缀数组性质及模板</title>
      <link href="/2019/01/18/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E6%80%A7%E8%B4%A8%E5%8F%8A%E6%A8%A1%E6%9D%BF/"/>
      <url>/2019/01/18/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E6%80%A7%E8%B4%A8%E5%8F%8A%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>后缀数组：</p><p>suff(i):以s的第i个字符为第一个元素的后缀</p><p>后缀数组sa[i]就表示排名为i的后缀的起始位置的下标</p><p>而它的映射数组rk[i]就表示起始位置的下标为i的后缀的排名</p><p>LCP(i,j)为suff(sa[i])与suff(sa[j])的最长公共前缀</p><ol><li><p>$LCP(i,j)=LCP(j,i);$</p></li><li><p>$LCP(i,i)=len(sa[i])=n-sa[i]+1$</p><p>性质：</p><p>$LCP(i,k)=min(LCP(i,j),LCP(j,k)) 对于任意1&lt;=i&lt;=j&lt;=k&lt;=n​$</p><p>$LCP(i,k)=min(LCP(j,j-1)) 对于任意1&lt;i&lt;j&lt;=k&lt;=n$</p><p>设$pub(i)=lcp(i,i-1)$,$h(i)=pub(rk[i])=suff(i)和suff(sa[rk[i]-1])的最长公共前缀$</p><p>结论：$h(i)&gt;=h(i-1)-1$</p></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> t1[maxn],t2[maxn],c[maxn],sa[maxn],a[maxn],pub[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *x=t1,*y=t2;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) c[x[i]=a[i]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--) sa[c[x[i]]--]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n-k+<span class="number">1</span>;i&lt;=n;i++) y[++num]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(sa[i]&gt;k) y[++num]=sa[i]-k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) c[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) c[x[i]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) c[i]+=c[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--) sa[c[x[y[i]]]--]=y[i],y[i]=<span class="number">0</span>;<span class="comment">//y[i]表示y排名为i的下标 </span></span><br><span class="line">swap(x,y);</span><br><span class="line">num=<span class="number">1</span>;x[sa[<span class="number">1</span>]]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">x[sa[i]]=(y[sa[i]]==y[sa[i<span class="number">-1</span>]]&amp;&amp;y[sa[i]+k]==y[sa[i<span class="number">-1</span>]+k])?num:++num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(num==n) <span class="keyword">break</span>;</span><br><span class="line">m=num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,sa[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lcp</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) rk[sa[i]]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(rk[i]==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(k) k--;</span><br><span class="line"><span class="keyword">int</span> j=sa[rk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">while</span>(i+k&lt;=n&amp;&amp;j+k&lt;=n&amp;&amp;s[i+k]==s[j+k]) k++;</span><br><span class="line">pub[rk[i]]=k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line"><span class="keyword">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">n=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) a[++n]=s[i];</span><br><span class="line">    solve(n,<span class="number">122</span>);</span><br><span class="line">    lcp(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 省选 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后缀数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>生成函数预备</title>
      <link href="/2019/01/17/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E9%A2%84%E5%A4%87/"/>
      <url>/2019/01/17/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E9%A2%84%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h2 id="真的就是一些杂七杂八有用没用的东西…"><a href="#真的就是一些杂七杂八有用没用的东西…" class="headerlink" title="真的就是一些杂七杂八有用没用的东西…."></a>真的就是一些杂七杂八有用没用的东西….</h2><p>生成函数:</p><p>斐波那契数列：s(n)=f(n+2)-1</p><p>设一个数列$a_0,a_1,a_2….a_n…$</p><p>则其生成函数$g(x)=\sum_{i=0}^{\infty} a_i\times x^i$</p><p>卡特兰数前7项：1, 1, 2, 5, 14, 42, 132</p><p>$C_{n+1}=C_1C_n+C_2C_{n-1}+……+C_nC_1$</p><p>通项公式$h(n)=C(2n,n)-C(2n,n-1)$</p><p>递推公式$h(n)=h(n-1)<em>(4</em>n-2)/(n+1)$</p><p>多项式的逆：</p><p>$B=2B’-AB’^2 （mod x^n)$ 最高次数n项</p><p>$A\times B \equiv 1(mod x^n)$，如遇到mod n+1项则再添一项</p><p>$A \times B’ \equiv 1(mod x^{\lfloor n/2 \rfloor})​$</p><p>$A(1)^{-1}=a[0]^{p-2}$ </p><p>卷积的定义</p><p>$(f\ast g)(n)=\int_{-\infty}^{\infty} f(i)g(n-i)di$ 连续定义</p><p>$(f\ast g)(n)=\sum_{-\infty}^{\infty} f(i)g(n-i)$离散定义</p><p>连续卷积的例子：做馒头</p><p>楼下早点铺子生意太好了，供不应求，就买了一台机器，不断的生产馒头。<br>假设馒头的生产速度是 f(t) ，那么一天后生产出来的馒头总量为： $\int_0^{24} f(t)dt$<br>馒头生产出来之后，就会慢慢腐败，假设腐败函数为 g(t) ，比如，10个馒头，24小时会腐败：$10 \ast g(t)$<br>想想就知道，第一个小时生产出来的馒头，一天后会经历24小时的腐败，第二个小时生产出来的馒头，一天后会经历23小时的腐败。<br>如此，我们可以知道，一天后，馒头总共腐败了： $\int_0^{24} f(t)g(24-t) dt$</p><p>两个多项式相乘，卷积f(i)对应其次数为i的系数(比如分治fft利用了这个思想)</p><p>多项式开根：<a href="https://www.cnblogs.com/yoyoball/p/8724115.html" target="_blank" rel="noopener">较优博文推导</a></p><p>tips:大抵推导思路就是先指数除2的同余多项式，然后通过平方相乘等来使指数恢复，从而可以用倍增将复杂度降到一半.</p><script type="math/tex; mode=display">(\frac{G^2(x)+A(x)}{2G(x)})^2\equiv A(x)(mod\ x^{2n})</script><script type="math/tex; mode=display">B(x)=(\frac{G^2(x)+A(x)}{2G(x)})^2(mod x^{2n})</script><p>泰勒公式：</p><p>定义：泰勒公式是将一个在$x=x0$处具有n阶导数的函数f(x)利用关于$(x-x0)$的n次多项式来逼近函数的方法。</p><p><img src="https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D561/sign=143f6442fadeb48fff69a1d8c11e3aef/a686c9177f3e670920f8bbdc32c79f3df8dc551d.jpg" alt=""></p><p>等号后的多项式称为函数f(x)在x0处的泰勒展开式，剩余的Rn(x)是泰勒公式的余项，是$(x-x0)^n$的高阶无穷小。</p><p>还可以看作<img src="https://img-blog.csdn.net/20180602214026172" alt=""></p><p>常见泰勒展开：(一般取$x_0=0$得到)<br><img src="https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D240/sign=af5105143cfae6cd08b4ac653fb30f9e/4bed2e738bd4b31cbf7b70988ed6277f9e2ff84a.jpg" alt="">取$x_0=0$<br><img src="https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D216/sign=010037de72899e517c8e3d1574a6d990/f9198618367adab47e17ff6082d4b31c8601e4ca.jpg" alt=""> 取$x_0 = 0$<br><img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D235/sign=aa5a1804763e6709ba0042fc0ec69fb8/7a899e510fb30f244f7b0820c195d143ad4b032b.jpg" alt=""><br>$ln(1-x)=-x-\frac{x^2}{2}-\frac{x^3}{3}-…..$<br><img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D217/sign=6137b9730533874498c5287d660fd937/b3b7d0a20cf431ad5cfca41a4236acaf2edd98e3.jpg" alt=""><br><img src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D208/sign=f90c39d7be4543a9f11bfdcc26178a7b/03087bf40ad162d9b8c6853f18dfa9ec8a13cded.jpg" alt=""><br><img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D403/sign=40cad0fa3001213fcb334fdc67e636f8/9358d109b3de9c821c821dac6581800a19d8432a.jpg" alt=""></p><p>多项式除法：</p><p>$A^R(x) = x^n A(\frac{1}{x})$</p><p>反转系数（随便举个栗子就行</p><script type="math/tex; mode=display">x^n A(\frac{1}{x}) = x^{n - m}D(\frac{1}{x}) x^mB(\frac{1}{x}) + x^{n - m + 1}x^{m - 1}R(\frac{1}{x})</script><script type="math/tex; mode=display">A^R(x) = D^R(x)B^R(x) + x^{n - m + 1}R^R(x)</script><p>因为$R^R(x)$的次数大于等于n-m+1，所以$mod x^{n-m+1}$可以全部消去(次数大于它的相当于乘了个倍数)</p><p>$A^R(x) = D^R(x)B^R(x) \pmod {x^{n - m + 1}}$</p><p>多项式取模：</p><p>$A(x)\equiv R(x)\pmod{B(x)}$</p><p>就是多项式除法搞余数</p><p>牛顿迭代法：</p><p>求函数f(x)的零点</p><p>方法：选一个$x_0$将f(x)泰勒展开，选取泰勒前几项来寻找$f(x)=0$的根.</p><p>通常只保留线性部分。</p><p>$f(x)=f(x_0)+f’(x_0)(x-x0)=0$</p><p>得到：$x=x0-\frac{f(x_0)}{f’(x_0)}$</p><p>多带几个$x_0$得到近似解</p><p>多项式牛顿迭代法：</p><p>问题：<strong>求函数g(f(x))的零点多项式f(x)</strong><br>解释：g(f(x))是一个关于多项式f(x)的函数，其中f(x)是变量。<br>即求一个多项式f(x)使得</p><script type="math/tex; mode=display">g(f(x))\equiv0\pmod{x^n}</script><p>e.g.</p><script type="math/tex; mode=display">g(f(x))=lnf(x)-A(x)</script><p>这个函数的零点为eA(x)eA(x)</p><script type="math/tex; mode=display">g(f(x))=f(x)-A^k(x)</script><p>这个函数的零点即Ak(x)</p><p>多项式牛顿迭代法用来解关于多项式方程</p><p><a href="https://blog.csdn.net/semiwaker/article/details/73251486" target="_blank" rel="noopener">留坑链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 省选 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>多项式板子</title>
      <link href="/2019/01/16/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%9D%BF%E5%AD%90/"/>
      <url>/2019/01/16/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%9D%BF%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p>fft板子：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cp</span>&#123;</span></span><br><span class="line"><span class="keyword">double</span> x,y;<span class="comment">//x实部y虚部 </span></span><br><span class="line">cp <span class="keyword">operator</span>+(<span class="keyword">const</span> cp &amp;a)&#123;</span><br><span class="line"><span class="keyword">return</span> (cp)&#123;x+a.x,y+a.y&#125;;</span><br><span class="line">&#125; </span><br><span class="line">cp <span class="keyword">operator</span>-(<span class="keyword">const</span> cp &amp;a)&#123;</span><br><span class="line"><span class="keyword">return</span> (cp)&#123;x-a.x,y-a.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line">cp <span class="keyword">operator</span>*(<span class="keyword">const</span> cp &amp;a)&#123;</span><br><span class="line"><span class="keyword">return</span> (cp)&#123;x*a.x-y*a.y,x*a.y+y*a.x&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">cp x1[maxn*<span class="number">3</span>],x2[maxn*<span class="number">3</span>];<span class="comment">//内存经常有不够的情况</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(cp y[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=len/<span class="number">2</span>;i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;j) swap(y[i],y[j]);</span><br><span class="line"><span class="keyword">int</span> k=len&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(j&gt;=k)&#123;</span><br><span class="line">j-=k;</span><br><span class="line">k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j&lt;k) j+=k;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(cp y[],<span class="keyword">int</span> len,<span class="keyword">int</span> on)</span></span>&#123;</span><br><span class="line">change(y,len);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> h=<span class="number">2</span>;h&lt;=len;h&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">cp base=(cp)&#123;<span class="built_in">cos</span>(<span class="number">2</span>*pi/h),<span class="built_in">sin</span>(<span class="number">2</span>*pi*on/h)&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;j+=h)&#123;</span><br><span class="line">cp w=(cp)&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=j;k&lt;j+h/<span class="number">2</span>;k++)&#123;</span><br><span class="line">cp t1=y[k];</span><br><span class="line">cp t2=w*y[k+h/<span class="number">2</span>];</span><br><span class="line">y[k]=t1+t2;</span><br><span class="line">y[k+h/<span class="number">2</span>]=t1-t2;</span><br><span class="line">w=w*base;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(on==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) y[i].x/=len;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(len&lt;len1*<span class="number">2</span>||len&lt;len2*<span class="number">2</span>) len&lt;&lt;=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1;i++) x1[i]=(cp)&#123;a[i],<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=len1;i&lt;len;i++) x1[i]=(cp)&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len2;i++) x2[i]=(cp)&#123;b[i],<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=len2;i&lt;len;i++) x2[i]=(cp)&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">fft(x1,len,<span class="number">1</span>);</span><br><span class="line">fft(x2,len,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) x1[i]=x1[i]*x2[i];</span><br><span class="line">    fft(x1,len,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ntt板子:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll x1[maxn*<span class="number">3</span>],x2[maxn*<span class="number">3</span>];</span><br><span class="line"><span class="function">ll <span class="title">qkpow</span><span class="params">(ll t,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">ll ans=<span class="number">1</span>,base=t;</span><br><span class="line"><span class="keyword">while</span>(pos)&#123;</span><br><span class="line"><span class="keyword">if</span>(pos&amp;<span class="number">1</span>) ans=ans*base%mod;</span><br><span class="line">base=base*base%mod;</span><br><span class="line">pos&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(ll y[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=len/<span class="number">2</span>;i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;j) swap(y[i],y[j]);</span><br><span class="line"><span class="keyword">int</span> k=len&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(j&gt;=k)&#123;</span><br><span class="line">j-=k;</span><br><span class="line">k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j&lt;k) j+=k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ntt</span><span class="params">(ll y[],<span class="keyword">int</span> len,<span class="keyword">int</span> on)</span></span>&#123;</span><br><span class="line">change(y,len);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> h=<span class="number">2</span>;h&lt;=len;h&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">ll base=qkpow(<span class="number">3</span>,(mod<span class="number">-1</span>)/h);<span class="comment">//改动1 </span></span><br><span class="line"><span class="keyword">if</span>(on==<span class="number">-1</span>) base=qkpow(base,mod<span class="number">-2</span>);<span class="comment">//改动2</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;j+=h)&#123;</span><br><span class="line">ll w=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=j;k&lt;j+h/<span class="number">2</span>;k++)&#123;</span><br><span class="line">ll t1=y[k];</span><br><span class="line">ll t2=w*y[k+h/<span class="number">2</span>]%mod;</span><br><span class="line">y[k]=(t1+t2)%mod;</span><br><span class="line">y[k+h/<span class="number">2</span>]=(t1-t2+mod)%mod;</span><br><span class="line">w=w*base%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll inv=qkpow(len,mod<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">if</span>(on==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) y[i]=y[i]*inv%mod; <span class="comment">//改动3 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(len&lt;len1*<span class="number">2</span>||len&lt;len2*<span class="number">2</span>) len&lt;&lt;=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1;i++) x1[i]=a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=len1;i&lt;len;i++) x1[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len2;i++) x2[i]=b[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=len2;i&lt;len;i++) x2[i]=<span class="number">0</span>;</span><br><span class="line">ntt(x1,len,<span class="number">1</span>);ntt(x2,len,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) x1[i]=x1[i]*x2[i];</span><br><span class="line">ntt(x1,len,<span class="number">-1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>多项式求逆：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxlen 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn maxlen*3 </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line">ll a[maxn],b[<span class="number">2</span>][maxn],x1[maxn],x2[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function">ll <span class="title">qkpow</span><span class="params">(ll t,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>,base=t;</span><br><span class="line">    <span class="keyword">while</span>(pos)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos&amp;<span class="number">1</span>) ans=ans*base%mod;</span><br><span class="line">        base=base*base%mod;</span><br><span class="line">        pos&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(ll y[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=len/<span class="number">2</span>;i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) swap(y[i],y[j]);</span><br><span class="line">        <span class="keyword">int</span> k=len&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=k)&#123;</span><br><span class="line">            j-=k;k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;k) j+=k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ntt</span><span class="params">(ll y[],<span class="keyword">int</span> len,<span class="keyword">int</span> on)</span></span>&#123;</span><br><span class="line">    change(y,len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> h=<span class="number">2</span>;h&lt;=len;h&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        ll base=qkpow(<span class="number">3</span>,(mod<span class="number">-1</span>)/h);<span class="comment">//改动1 </span></span><br><span class="line">        <span class="keyword">if</span>(on==<span class="number">-1</span>) base=qkpow(base,mod<span class="number">-2</span>);<span class="comment">//改动2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;j+=h)&#123;</span><br><span class="line">            ll w=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=j;k&lt;j+h/<span class="number">2</span>;k++)&#123;</span><br><span class="line">                ll t1=y[k];</span><br><span class="line">                ll t2=w*y[k+h/<span class="number">2</span>]%mod;</span><br><span class="line">                y[k]=(t1+t2)%mod;</span><br><span class="line">                y[k+h/<span class="number">2</span>]=(t1-t2+mod)%mod;</span><br><span class="line">                w=w*base%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll inv=qkpow(len,mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">if</span>(on==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) y[i]=y[i]*inv%mod; <span class="comment">//改动3 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(ll a[],ll b[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(x1,<span class="number">0</span>,<span class="keyword">sizeof</span>(x1));</span><br><span class="line">    <span class="built_in">memset</span>(x2,<span class="number">0</span>,<span class="keyword">sizeof</span>(x2));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        x1[i]=a[i];x2[i]=b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ntt(x1,len,<span class="number">1</span>);ntt(x2,len,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) x1[i]=x2[i]*x1[i]%mod;</span><br><span class="line">    ntt(x1,len,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) a[i]=x1[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">int</span> cur=<span class="number">0</span>;</span><br><span class="line">    b[cur][<span class="number">0</span>]=qkpow(a[<span class="number">0</span>],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">int</span> bas=<span class="number">1</span>,len=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(bas&lt;=(n&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">        cur^=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(b[cur],<span class="number">0</span>,<span class="keyword">sizeof</span>(b[cur]));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bas;i++) b[cur][i]=(b[cur][i]+b[cur^<span class="number">1</span>][i]*<span class="number">2l</span>l)%mod;</span><br><span class="line">        mul(b[cur^<span class="number">1</span>],b[cur^<span class="number">1</span>],len);</span><br><span class="line">        mul(b[cur^<span class="number">1</span>],a,len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bas;i++) b[cur][i]=(b[cur][i]-b[cur^<span class="number">1</span>][i]+mod)%mod;</span><br><span class="line">        bas&lt;&lt;=<span class="number">1</span>;len&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>,b[cur][i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多项式除法：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxlen 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn maxlen*3</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">ll f[maxn],g[maxn],d[maxn],r[maxn],gr[maxn],fr[maxn],t[<span class="number">2</span>][maxn],x1[maxn],x2[maxn];</span><br><span class="line"><span class="function">ll <span class="title">qkpow</span><span class="params">(ll t,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>,base=t;</span><br><span class="line">    <span class="keyword">while</span>(pos)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos&amp;<span class="number">1</span>) ans=ans*base%mod;</span><br><span class="line">        base=base*base%mod;</span><br><span class="line">        pos&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(ll y[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=len/<span class="number">2</span>;i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) swap(y[i],y[j]);</span><br><span class="line">        <span class="keyword">int</span> k=len&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=k)&#123;</span><br><span class="line">            j-=k;k&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;k) j+=k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ntt</span><span class="params">(ll y[],<span class="keyword">int</span> len,<span class="keyword">int</span> on)</span></span>&#123;</span><br><span class="line">    change(y,len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> h=<span class="number">2</span>;h&lt;=len;h&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        ll base=qkpow(<span class="number">3</span>,(mod<span class="number">-1</span>)/h);<span class="comment">//改动1 </span></span><br><span class="line">        <span class="keyword">if</span>(on==<span class="number">-1</span>) base=qkpow(base,mod<span class="number">-2</span>);<span class="comment">//改动2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;j+=h)&#123;</span><br><span class="line">            ll w=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=j;k&lt;j+h/<span class="number">2</span>;k++)&#123;</span><br><span class="line">                ll t1=y[k];</span><br><span class="line">                ll t2=w*y[k+h/<span class="number">2</span>]%mod;</span><br><span class="line">                y[k]=(t1+t2)%mod;</span><br><span class="line">                y[k+h/<span class="number">2</span>]=(t1-t2+mod)%mod;</span><br><span class="line">                w=w*base%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll inv=qkpow(len,mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">if</span>(on==<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) y[i]=y[i]*inv%mod; <span class="comment">//改动3 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(ll a[],ll b[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(x1,<span class="number">0</span>,<span class="keyword">sizeof</span>(x1));</span><br><span class="line">    <span class="built_in">memset</span>(x2,<span class="number">0</span>,<span class="keyword">sizeof</span>(x2));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        x1[i]=a[i];x2[i]=b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ntt(x1,len,<span class="number">1</span>);ntt(x2,len,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) x1[i]=x2[i]*x1[i]%mod;</span><br><span class="line">    ntt(x1,len,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) a[i]=x1[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mull</span><span class="params">(ll a[],ll b[],<span class="keyword">int</span> len1)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(len&lt;len1*<span class="number">2</span>) len&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(x1,<span class="number">0</span>,<span class="keyword">sizeof</span>(x1));</span><br><span class="line">    <span class="built_in">memset</span>(x2,<span class="number">0</span>,<span class="keyword">sizeof</span>(x2));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1;i++) x1[i]=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1;i++) x2[i]=b[i];</span><br><span class="line">    ntt(x1,len,<span class="number">1</span>);ntt(x2,len,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) x1[i]=x2[i]*x1[i]%mod;</span><br><span class="line">    ntt(x1,len,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++) a[i]=x1[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cur;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inv</span><span class="params">(ll a[],<span class="keyword">int</span> tot)</span></span>&#123;</span><br><span class="line">    cur=<span class="number">0</span>;</span><br><span class="line">    t[cur][<span class="number">0</span>]=qkpow(a[<span class="number">0</span>],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">int</span> bas=<span class="number">1</span>,len=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(bas&lt;=(tot&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">        cur^=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(t[cur],<span class="number">0</span>,<span class="keyword">sizeof</span>(t[cur]));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bas;i++) t[cur][i]=(t[cur][i]+t[cur^<span class="number">1</span>][i]*<span class="number">2l</span>l)%mod;</span><br><span class="line">        mul(t[cur^<span class="number">1</span>],t[cur^<span class="number">1</span>],len);</span><br><span class="line">        mul(t[cur^<span class="number">1</span>],a,len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bas;i++) t[cur][i]=(t[cur][i]-t[cur^<span class="number">1</span>][i]+mod)%mod;</span><br><span class="line">        bas&lt;&lt;=<span class="number">1</span>;len&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;f[i]),fr[n-i]=f[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;g[i]),gr[m-i]=g[i];</span><br><span class="line">    inv(gr,n-m+<span class="number">1</span>);<span class="comment">//t[cur]现在为gr的逆元 </span></span><br><span class="line">    mull(fr,t[cur],n+<span class="number">1</span>);<span class="comment">//fr变为dr</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n-m;i++) d[i]=fr[n-m-i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n-m;i++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>,d[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    mull(d,g,n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) r[i]=(f[i]-d[i]+mod)%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m<span class="number">-1</span>;i++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>,r[i]);   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 省选 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式 </tag>
            
            <tag> ntt </tag>
            
            <tag> fft </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>终</title>
      <link href="/2019/01/16/d1t1/"/>
      <url>/2019/01/16/d1t1/</url>
      
        <content type="html"><![CDATA[<p>首先题目中的贡献式子</p><script type="math/tex; mode=display">\frac{(A_i - A_j)B_iB_j}{2A_iA_j}</script><p>化简得$\frac{1}{2}(B_i\frac{B_j}{A_j}-B_j\frac{B_i}{A_i})$</p><p>发现可以看成一个向量叉积，转成面积，再观察题目中的特殊性质$B_i$先单调不降，再单调不增，看上去就联想到做一个凸包，使得面积最大（权值越大，得解</p><p>code:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line"><span class="keyword">double</span> x,y;</span><br><span class="line">point <span class="keyword">operator</span>-(<span class="keyword">const</span> point &amp;a)&#123;</span><br><span class="line"><span class="keyword">return</span> (point)&#123;x-a.x,y-a.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line">point <span class="keyword">operator</span>+(<span class="keyword">const</span> point &amp;a)&#123;</span><br><span class="line"><span class="keyword">return</span> (point)&#123;x+a.x,y+a.y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(point a,point b)&#123;</span><br><span class="line"><span class="keyword">return</span> a.x&lt;b.x||(a.x==b.x&amp;&amp;a.y&lt;b.y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;p[maxn],st[maxn];</span><br><span class="line"><span class="keyword">double</span> <span class="keyword">operator</span>^(point a,point b)&#123;</span><br><span class="line"><span class="keyword">return</span> a.x*b.y-b.x*a.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(point a,point b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,a[maxn],b[maxn];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calc</span><span class="params">(point a,point b,point c)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (b-a)^(c-a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),b[i]=(sum+=a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">   p[i]=(point)&#123;(<span class="keyword">double</span>)b[i],(<span class="keyword">double</span>)b[i]*<span class="number">1.0</span>/(<span class="keyword">double</span>)a[i]&#125;;</span><br><span class="line">&#125;</span><br><span class="line">sort(p+<span class="number">1</span>,p+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> top=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(top&gt;<span class="number">1</span>&amp;&amp;calc(st[top<span class="number">-1</span>],st[top],p[i])&lt;=<span class="number">0</span>) top--;<span class="comment">//保证了单调性 后面=0的肯定比前面长 </span></span><br><span class="line">st[++top]=p[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp=top;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line"><span class="keyword">while</span>(top&gt;tmp&amp;&amp;calc(st[top<span class="number">-1</span>],st[top],p[i])&lt;=<span class="number">0</span>) top--;</span><br><span class="line">st[++top]=p[i]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=top;i++)&#123;</span><br><span class="line">ans+=(st[i<span class="number">-1</span>]^st[i])/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.5f"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 省选 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算几何初步</title>
      <link href="/2019/01/15/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%88%9D%E6%AD%A5/"/>
      <url>/2019/01/15/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%88%9D%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span></span><br><span class="line">  <span class="keyword">double</span> x,<span class="keyword">double</span> y;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> point &amp;a,<span class="keyword">const</span> point &amp;b)&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x&lt;b.x||a.x==b.x&amp;&amp;a.y&lt;b.y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用点积求夹角：$acos(dot(a,b)/len(a)/len(b))$</p><p>叉积：$T=\vec{a} \times \vec{b}=-\vec{b} \times \vec{a} =X_aY_b-X_bY_a=\vline \vec{a} \vline \vline \vec{b} \vline sin(vec{a},vec{b})$</p><p>方向用右手定则判断，垂直平面</p><p>T=0: 两向量共线或反向<br>T&gt;0:b在a左侧<br>T&lt;0:b在a右侧<br><img src="https://i.loli.net/2019/01/15/5c3d307ad09be.png" alt=""></p><p>两向量所构平行四边形面积为叉积</p><p>旋转:<br>向量(x,y)绕坐标原点逆时针旋转$\theta$度<br>（用三垂直定理）</p><script type="math/tex; mode=display">x'=xcos\theta-ysin\theta</script><script type="math/tex; mode=display">y'=xsin\theta+ycos\theta</script><p>tips:<br>在读入时对每个点进行微小扰动<br>point a=(point){x+eps(),y+eps()};<br>或point a=rotate(a,1e-7)<br>以避免出现斜率不存在的情况</p><p>数据存储<br>1.直线/线段：斜截式或一般式<br>$Ax + By + C = 0 or y = kx + b$<br>2.圆：圆⼼坐标，圆的半径<br>$(x − a)^2 + (y − b)^2 = r2$<br>3.多边形：多边形上所有点坐标（推荐使用逆时针）<br>4.半平面：<br>$Ax + By + C ≥ 0$</p><p>公式定理：<br>1.正弦定理：AAS/ASA解三角形<br>2.余弦定理：SAS/SSS解三角形<br>3.质⼼：点集的加权平均数，就是好⼏个杠杆原理<br>$x_0=\frac{1}{N}\sum_{i=1}^N x_im_i,y_0=\frac{1}{N}\sum_{i=1}^N y_im_i$<br>三角形质⼼：中线交点<br>四边形质⼼：两个三角形质⼼的质⼼，权重为三角形面积<br>定比分点：杠杆原理坐标化<br>4.三角形面积:正弦定理，叉积，海伦公式:$p = (a + b + c)/2; S = \sqrt{p(p − a)(p − b)(p− c)}$</p><p>应用：<br>1.判折线段的拐向 a,b,c $\vec{ab} \times \vec{bc}$ 叉积大于0则左拐，否则右拐<br>2.判断点是否在线段上: a,b,c </p><p>（忘了按保存键就先咕咕咕了2333</p><p>C 语言里 double atan2(double y,double x) 返回的是原点至点(x,y)的方位角，即与 x 轴的夹角。</p><p>取值范围为 <img src="https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D47/sign=f817c2ad06e9390152028c3979ec2ec3/dcc451da81cb39db32331ddbd7160924aa18304f.jpg" alt="img"> ；</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//得到两直线相交的交点</span></span><br><span class="line"><span class="function">point <span class="title">getpoint</span><span class="params">(line a,line b)</span></span>&#123;</span><br><span class="line"> point aa=a.e-a.s,bb=b.e-b.s,cc=b.s-a.s;</span><br><span class="line">   <span class="keyword">double</span> t=(bb^cc)/(aa^bb);</span><br><span class="line">   <span class="keyword">return</span> (point)&#123;a.s+aa*t&#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 省选 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>马拉车算法</title>
      <link href="/2019/01/13/%E9%A9%AC%E6%8B%89%E8%BD%A6/"/>
      <url>/2019/01/13/%E9%A9%AC%E6%8B%89%E8%BD%A6/</url>
      
        <content type="html"><![CDATA[<p>马拉车算法</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=<span class="number">2</span>*n;j++,i+=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s[i]=<span class="string">'#'</span>;</span><br><span class="line">        s[i+<span class="number">1</span>]=str[j];</span><br><span class="line">    &#125;</span><br><span class="line">    s[<span class="number">0</span>]=<span class="string">'$'</span>;</span><br><span class="line">    s[<span class="number">2</span>*n+<span class="number">1</span>]=<span class="string">'#'</span>;</span><br><span class="line">    s[<span class="number">2</span>*n+<span class="number">2</span>]=<span class="string">'@'</span>;</span><br><span class="line">    s[<span class="number">2</span>*n+<span class="number">3</span>]=<span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manacher</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mx=<span class="number">0</span>,p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mx&gt;i)len[i]=min(mx-i,len[<span class="number">2</span>*p-i]);</span><br><span class="line">        <span class="keyword">else</span> len[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[i-len[i]]==s[i+len[i]])len[i]++;</span><br><span class="line">        <span class="keyword">if</span>(len[i]+i&gt;mx)mx=len[i]+i,p=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 省选 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 马拉车算法 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>莫比乌斯反演未整理</title>
      <link href="/2019/01/02/58/"/>
      <url>/2019/01/02/58/</url>
      
        <content type="html"><![CDATA[<p>$\sigma(p^k)=k+1$<br>$phi(p^k)=p^{k-1}\times(p-1)$<br>$(phi\star1)(p^k)=p^k$</p><p>证明：</p><p>$1(i)=1$</p><p>$(phi\star1)(n)=\sum_{i|n}(phi(i)\times 1)$<br>$(phi\star1)(p^k)=(phi)(1)+(phi)(p^1)+….+(phi)(p^k)$<br>套公式$phi(p^k)=p^{k-1}\times(p-1)$<br>化为$(p-1)\times(p^0+p^1+…+p^{k-1})=p^k$</p><p>由于$(phi\star1)(p^k)$是积性函数，所以$phi\star1=id$</p><p>莫比乌斯反演：</p><p>定义<strong>1</strong>的逆是$\mu​$（莫比乌斯函数）</p><p>如果$g=f\star1$，就有$f=f\ \star 1\ \star\mu=g\ \star\mu$</p><p>所以$g(n)=\sum_{d|n}f(d)$则$f(n)=\sum_{d|n}g(d)\times\mu(n/d)$ （莫比乌斯反演定理）</p><p>另一个方向：$g(n)=\sum_{n|d}f(d)$ 则$f(n)=\sum_{n|d}g(d)\times \mu(d/n)$  其中d的取值范围为f的定义域</p><script type="math/tex; mode=display">\mu(n)=(-1)^{t}</script><p>当 <script type="math/tex">n=p_1\times p_2\times ...\times p_t且p_i各不相同</script></p><script type="math/tex; mode=display">else  \mu(i)=0</script><p>结论： $phi=\mu \star id$  </p><p>莫比乌斯函数常用的两个性质：</p><ul><li>对于任意正整数$n$，$\sum_{d|n}\mu(d)=[n=1]$。（$[n=1]$表示只有当$n=1$成立时，返回值为1；否则，值为0；(这个就是用μ是容斥系数的性质可以证明)<strong>(PS:这一条性质是莫比乌斯反演中最常用的)</strong></li><li>对于任意正整数n，$\sum_{d|n}\frac{\mu(d)}{d}=\frac{\phi(n)}{n}$。（这个性质很奇妙，它把欧拉函数和莫比乌斯函数结合起来）</li></ul><p>整除分块：</p><ul><li>对于每一个$\lfloor\frac{n}{i}\rfloor$我们可以通过打表<del>(或理性的证明)</del>可以发现：有许多$\lfloor\frac{n}{i}\rfloor$的值是一样的，而且它们呈一个块状分布；再通过打表之类的各种方法,我们惊喜的发现对于每一个值相同的块，它的最后一个数就是$n/(n/i)$。得出这个结论后，我们就可以做的$O(\sqrt{n})$处理了。<br>附一个整除分块的代码吧：</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    r=n/(n/l);</span><br><span class="line">    ans+=(r-l+<span class="number">1</span>)\star(n/l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_mu</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;prim[++cnt]=i;mu[i]=<span class="number">-1</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;prim[j]\stari&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[prim[j]\stari]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prim[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> mu[i\starprim[j]]=-mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 省选 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>祎隋</title>
      <link href="/2019/01/02/57/"/>
      <url>/2019/01/02/57/</url>
      
        <content type="html"><![CDATA[<h2 id="我愿…"><a href="#我愿…" class="headerlink" title="我愿…"></a>我愿…</h2><p><font face="等线">《祎隋》</font>&lt;/br&gt;  </p><p><font face="等线">我愿意是歌声不成形体</font>&lt;/br&gt;    </p><p><font face="等线">又发自于你</font> &lt;/br&gt;   </p><p><font face="等线">轻托你的灵动美丽</font>&lt;/br&gt;    </p><p><font face="等线">我愿意是烟火转瞬即逝</font>&lt;/br&gt;    </p><p><font face="等线">又引你一视</font>&lt;/br&gt;    </p><p><font face="等线">映亮你的天真欣喜</font>&lt;/br&gt;    </p><p><font face="等线">我愿意是微风不被注意</font>&lt;/br&gt;    </p><p><font face="等线">又轻拂着你</font>&lt;/br&gt;    </p><p><font face="等线">飘扬你的醉人芳香</font>&lt;/br&gt;    </p><p><font face="等线">我愿意是皎月独凌寒处</font>&lt;/br&gt;    </p><p><font face="等线">又照你一世</font>&lt;/br&gt;   </p><p><font face="等线">平稳你的夜夜美梦</font>&lt;/br&gt;   </p><p><font face="等线">我愿意是时光静默流淌</font> &lt;/br&gt;  </p><p><font face="等线">又伴你一生</font>&lt;/br&gt;    </p><p><font face="等线">承载你的所有过往</font>&lt;/br&gt;    </p><p><img src="https://i.loli.net/2019/01/02/5c2cd3d567883.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 杂诗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂诗 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网络流</title>
      <link href="/2018/12/16/56/"/>
      <url>/2018/12/16/56/</url>
      
        <content type="html"><![CDATA[<p>首先主要是关于退流的理解，仔细理解这张图：<br><img src="https://i.loli.net/2018/12/16/5c166eaf19395.png" alt=""></p><p>然后上模板：<br>最大流<br>(1)EK:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 205</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxm 2005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,x,y,z;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eage</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> from,to,next,cap,flow;</span><br><span class="line">&#125;e[maxm&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> first[maxn],np=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">e[++np]=(eage)&#123;u,v,first[u],c,<span class="number">0</span>&#125;;</span><br><span class="line">first[u]=np;</span><br><span class="line">e[++np]=(eage)&#123;v,u,first[v],<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">first[v]=np;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> a[maxn],fa[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">other</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> i&amp;<span class="number">1</span>?i+<span class="number">1</span>:i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">a[s]=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">fa[s]=<span class="number">0</span>;</span><br><span class="line">q.push(s);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> i=q.front();q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> p=first[i];p;p=e[p].next)&#123;</span><br><span class="line"><span class="keyword">int</span> j=e[p].to;</span><br><span class="line"><span class="keyword">if</span>(!a[j]&amp;&amp;e[p].cap&gt;e[p].flow)&#123;</span><br><span class="line">a[j]=min(a[i],e[p].cap-e[p].flow);</span><br><span class="line">fa[j]=p;</span><br><span class="line">q.push(j);</span><br><span class="line"><span class="keyword">if</span>(j==t) <span class="keyword">return</span> a[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果没有找到任意一条 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ek</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> maxflow=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> del=bfs(<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">if</span>(del==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">maxflow+=del;</span><br><span class="line"><span class="keyword">int</span> f=fa[n];</span><br><span class="line"><span class="keyword">while</span>(f)&#123;</span><br><span class="line">e[f].flow+=del;</span><br><span class="line">e[other(f)].flow-=del;</span><br><span class="line">f=fa[e[f].from];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n);</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line"> add(x,y,z);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%d"</span>,ek());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(2)Dinic<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 205</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxm 2005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eage</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> from,to,next,cap,flow;</span><br><span class="line">&#125;e[maxm&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> first[maxn],np=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">e[++np]=(eage)&#123;u,v,first[u],c,<span class="number">0</span>&#125;;</span><br><span class="line">first[u]=np;</span><br><span class="line">e[++np]=(eage)&#123;v,u,first[v],<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">first[v]=np;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,x,y,z,s,t;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">other</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> i&amp;<span class="number">1</span>?i+<span class="number">1</span>:i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> mn)</span></span>&#123;</span><br><span class="line">vis[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i==t) <span class="keyword">return</span> mn;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> p=first[i];p;p=e[p].next)&#123;</span><br><span class="line"><span class="keyword">int</span> j=e[p].to;</span><br><span class="line"><span class="keyword">int</span> dis=e[p].cap-e[p].flow;</span><br><span class="line"><span class="keyword">if</span>(vis[j]||dis==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> del=dfs(j,min(mn,dis));</span><br><span class="line"><span class="keyword">if</span>(del==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">e[p].flow+=del;</span><br><span class="line">e[other(p)].flow-=del;</span><br><span class="line"><span class="keyword">return</span> del; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ek</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxflow=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">int</span> del=dfs(s,inf);</span><br><span class="line"><span class="keyword">if</span>(del==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">maxflow+=del;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n);</span><br><span class="line">s=<span class="number">1</span>,t=n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">add(x,y,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,ek());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>费用流:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 305</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxm 3005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eage</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> from,to,next,cap,flow,w;</span><br><span class="line">&#125;e[maxm&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> first[maxn],np=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">e[++np]=(eage)&#123;u,v,first[u],c,<span class="number">0</span>,w&#125;;</span><br><span class="line">first[u]=np;</span><br><span class="line">e[++np]=(eage)&#123;v,u,first[v],<span class="number">0</span>,<span class="number">0</span>,-w&#125;;</span><br><span class="line">first[v]=np;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">other</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> i&amp;<span class="number">1</span>?i+<span class="number">1</span>:i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,x,y,z,w,dist[maxn],a[maxn],fa[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    a[<span class="number">1</span>]=inf;</span><br><span class="line">    fa[<span class="number">1</span>]=<span class="number">0</span>;q.push(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">    dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">    <span class="keyword">int</span> i=q.front();q.pop();</span><br><span class="line">    vis[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=first[i];p;p=e[p].next)&#123;</span><br><span class="line">    <span class="keyword">int</span> j=e[p].to;</span><br><span class="line">    <span class="keyword">if</span>(e[p].cap&gt;e[p].flow)</span><br><span class="line">    <span class="keyword">if</span>(dist[j]&gt;dist[i]+e[p].w)&#123;</span><br><span class="line">    dist[j]=dist[i]+e[p].w;</span><br><span class="line">    a[j]=min(a[i],e[p].cap-e[p].flow);</span><br><span class="line">    fa[j]=p;</span><br><span class="line">    <span class="keyword">if</span>(!vis[j]) q.push(j),vis[j]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ek</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> maxflow=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cost=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(spfa())&#123;</span><br><span class="line">maxflow+=a[n];</span><br><span class="line">cost+=dist[n]*a[n];</span><br><span class="line"><span class="keyword">int</span> f=fa[n];</span><br><span class="line"><span class="keyword">while</span>(f)&#123;</span><br><span class="line">e[f].flow+=a[n];</span><br><span class="line">e[other(f)].flow-=a[n];</span><br><span class="line">f=fa[e[f].from];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d"</span>,maxflow,cost);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;x,&amp;y,&amp;z,&amp;w);</span><br><span class="line">add(x,y,z,w);</span><br><span class="line">&#125;</span><br><span class="line">ek();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>二分图:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 405</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxm 40005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eage</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> from,to,next,cap,flow;</span><br><span class="line">&#125;e[maxm&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> first[maxn],np=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">e[++np]=(eage)&#123;u,v,first[u],c,<span class="number">0</span>&#125;;</span><br><span class="line">first[u]=np;</span><br><span class="line">e[++np]=(eage)&#123;v,u,first[v],<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">first[v]=np;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">other</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> i&amp;<span class="number">1</span>?i+<span class="number">1</span>:i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,x,y,s,t;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> mn)</span></span>&#123;</span><br><span class="line">vis[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i==t) <span class="keyword">return</span> mn;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> p=first[i];p;p=e[p].next)&#123;</span><br><span class="line"><span class="keyword">int</span> j=e[p].to,dis=e[p].cap-e[p].flow;</span><br><span class="line"><span class="keyword">if</span>(vis[j]||dis==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">int</span> del=dfs(j,min(mn,dis));</span><br><span class="line">    <span class="keyword">if</span>(del==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    e[p].flow+=del;</span><br><span class="line">    e[other(p)].flow-=del;</span><br><span class="line">    <span class="keyword">return</span> del;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ek</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> maxflow=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">int</span> del=dfs(s,inf);</span><br><span class="line">    <span class="keyword">if</span>(del==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    maxflow+=del; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,maxflow);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">s=<span class="number">401</span>,t=<span class="number">402</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=y;j++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">add(i,x+n,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">add(s,i,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) add(i+n,t,<span class="number">1</span>);<span class="comment">//最多只出去一个，保证两边不连到一个点上 </span></span><br><span class="line">ek();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 省选 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>划分物品</title>
      <link href="/2018/11/08/55/"/>
      <url>/2018/11/08/55/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>你有 n 个物品，第 i 个物品的重量是$w_i$。</p><p>你需要把这些物品划分成若干组，满足每一组的重量和都是质数。</p><p>两个方案是不同的当且仅当存在两个物品 i 和 j，在第一个方案里他们处在同一组，第二个方案里他们不处在同一组。（对998244353取模）</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>$n&lt;=16,w_i&lt;=100$</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>10<br>2 3 4 5 6 7 8 9 10 11</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>1177</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>一道经典的状压dp题，我们可以用$sum_i$来表示状态为i的集合所表示的重量和(类似思路也可以搞其他的)设$dp_i$表示状态为i的集合所能容纳的方案数，那么$dp_i=\sum_{(j属于i且j为素数)}dp_{i-j}$。显然这样是不正确的，因为有重复的，所以我们便固定一个x属于i，然后可以正确dp。</p><p>上代码:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxv 1605</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line">ll dp[<span class="number">1</span>&lt;&lt;<span class="number">18</span>];</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">1</span>&lt;&lt;<span class="number">18</span>];</span><br><span class="line"><span class="keyword">int</span> n,w[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[maxv];</span><br><span class="line"><span class="keyword">int</span> prime[maxv&gt;&gt;<span class="number">1</span>],top=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span></span>&#123;</span><br><span class="line">vis[<span class="number">0</span>]=vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxv<span class="number">-5</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[i]) prime[++top]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=top&amp;&amp;prime[j]*i&lt;=maxv<span class="number">-5</span>;j++)&#123;</span><br><span class="line">vis[prime[j]*i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">int</span> all=(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w[i]);sum[<span class="number">1</span>&lt;&lt;i<span class="number">-1</span>]=w[i];</span><br><span class="line">&#125;</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=all;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>((i|(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>))!=i) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)==i) <span class="keyword">continue</span>;</span><br><span class="line">sum[i]=sum[i-(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)]+w[j];<span class="comment">//可用如此方式来记录每个状态代表的值 </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=all;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> x=i&amp;(-i);<span class="comment">//固定一个 注意i&amp;-i的值是1&lt;&lt;后的 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i;j;j=i&amp;(j<span class="number">-1</span>))&#123;</span><br><span class="line"><span class="keyword">if</span>((x|j)!=j) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(vis[sum[j]]) <span class="keyword">continue</span>;</span><br><span class="line">dp[i]=(dp[i]+dp[i-j])%mod;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,dp[all]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ready();</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计数</title>
      <link href="/2018/11/07/54/"/>
      <url>/2018/11/07/54/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>既然是萌萌哒 visit_world 的比赛，那必然会有一道计数题啦！<br>考虑一个N个节点的二叉树，它的节点被标上了$1-N$的编号. 并且，编号为i的节点在二叉树的前序遍历中恰好是第i个出现.<br>我们定义$A_i$表示编号为i的点在二叉树的中序遍历中出现的位置.<br>现在，给出m个限制条件，第i个限制条件给出了$u_i,v_i$,表示$A_{u_i}&lt;A_{v_i}$，也即中序遍历中$u_i$在$v_i$之前出现.<br>你需要计算有多少种不同的带标号二叉树满足上述全部限制条件，答案对$1e9+7$取模.</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>$T&lt;=5,N&lt;=400,M&lt;=10^3$</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>3 5<br>0<br>3 2<br>1 2<br>2 3<br>3 3<br>1 2<br>2 3<br>3 1</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>42<br>1<br>0</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先M=0可以看出是个卡特兰数。<br>然后我们知道先序遍历，根据其特性来枚举出合法的中序遍历，每次找到一个根，枚举它左边有多少个，右边有多少个，然后判断是否合法，合法的话方案数乘起来累加。<br>见图：<br><img src="https://i.loli.net/2018/11/07/5be3017335edf.png" alt=""><br>首先枚举后有三个大小关系：根的中序遍历大于任意左子树的，任意右子树的大于根的，任意右子树的大于左子树的。<br>然后发现check是$n^2$的，而dp又是$n^3$的，这样就$n^5$了，<font color="red">这里有个很nice的思路</font>，用二维前缀和优化，如果要求i的中序遍历小于j的，那么$a[i][j]=1$，然后sum求一波二维前缀和，对于$sum[i][j]$其含义便是1-i中小于1-j中的个数和，那么我们询问$[l1,r1]小于[l2,r2]$就为$sum[r1,r2]-sum[l1-1,r2]-sum[r1,l2-1]+sum[l1-1,l2-1]$然后就优化成$O(1)$的check了，整体复杂度就被优化至了$O(n^3)$，真的TQL%%%</p><p>上代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 405</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn],n,t,m,x,y,sum[maxn][maxn];</span><br><span class="line">ll dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l1,<span class="keyword">int</span> r1,<span class="keyword">int</span> l2,<span class="keyword">int</span> r2)</span></span>&#123;<span class="comment">//如果返回值说l1~r1有小于l2~r2的 </span></span><br><span class="line">    <span class="keyword">return</span> sum[r1][r2]-sum[l1<span class="number">-1</span>][r2]-sum[r1][l2<span class="number">-1</span>]+sum[l1<span class="number">-1</span>][l2<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> l1,<span class="keyword">int</span> r1,<span class="keyword">int</span> l2,<span class="keyword">int</span> r2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(calc(l2,r2,l1,r1))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(calc(now,now,l1,r1))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(calc(l2,r2,now,now))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="keyword">sizeof</span>(sum));</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">a[x][y]=<span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">sum[i][j]=sum[i<span class="number">-1</span>][j]+sum[i][j<span class="number">-1</span>]-sum[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">1</span>;len&lt;=n;len++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> j=i+len;</span><br><span class="line"><span class="keyword">if</span>(j&gt;n) <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//其实这余下三坨是可以归在一起算的 </span></span><br><span class="line"><span class="keyword">if</span>(!calc(i,i,i+<span class="number">1</span>,j))dp[i][j]=(dp[i][j]+dp[i+<span class="number">1</span>][j])%mod;<span class="comment">//如果没有限制 </span></span><br><span class="line">        <span class="keyword">if</span>(!calc(i+<span class="number">1</span>,j,i,i))dp[i][j]=(dp[i][j]+dp[i+<span class="number">1</span>][j])%mod;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;j;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(check(i,i+<span class="number">1</span>,k,k+<span class="number">1</span>,j)) dp[i][j]=(dp[i][j]+dp[i+<span class="number">1</span>][k]*dp[k+<span class="number">1</span>][j])%mod;</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,dp[<span class="number">1</span>][n]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 二维前缀和 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>购物</title>
      <link href="/2018/11/07/53/"/>
      <url>/2018/11/07/53/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>visit_world 有一个商店，商店里卖 个商品，第 i 个的价格为$a_i$<br>我们称一个正整数 K 是美妙的，当且仅当我们可以在商店里选购若干个商品，使得价格之和落在区间$ [K, 2K]$ 中。<br>问：有多少个美妙的数。</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>$N&lt;=10^5,a_i&lt;=10^9$<br>时空限制：1s / 512MB</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>3<br>1 2 3</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>6</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>我们将$a_i$从小到大排序，对于前i个，假设它们和为sum,那么k能去到的范围即为$[\frac{sum+1}{2},sum]$，那么对于$\frac{sum-1}{2}$开始是覆盖的不到，我们便会减去一些来使覆盖，所以肯定是逐渐拿小的来，到最后剩下$a_i$，那么设前i-1个的和为sum’，则$[sum’+1,\frac{a_i-1}{2}]$是覆盖不到，所以最终把这些空隙减掉即可。</p><p>上代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">ll sum=<span class="number">0</span>,del=<span class="number">0</span>;</span><br><span class="line">sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">del+=max((a[i]+<span class="number">1</span>)/<span class="number">2</span>-sum<span class="number">-1</span>,<span class="number">0l</span>l);</span><br><span class="line">sum+=a[i]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,sum-del);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>physics</title>
      <link href="/2018/11/06/52/"/>
      <url>/2018/11/06/52/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>一个n行m列的矩阵，每个为0或1，如果一个边长为K的正方形包含的所有数都为1，那么会形成一个强度为K的电场，有q次询问，每次询问会把1个1变做0，求每次询问的最大电场强度值。</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>$n,m&lt;=2 \ast 10^3 ,1&lt;=q&lt;=10^4$</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>5 5 5<br>+-+++<br>+++++<br>+++++<br>+++++<br>++++-<br>1 5<br>2 2<br>5 3<br>2 3<br>1 1</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>4<br>3<br>3<br>2<br>2</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先会想到用单调栈$n^2$计算最大1正方形，然后发现每改一个只会影响一列的up数组，然后发现如果答案递减不好维护，那么正难则反，我们先将所有的改动加进来，然后倒序考虑所有操作。<br>那么答案是会依次递增的，我们维护一个up和一个down数组来记录每个格子向上和向下最多多少格，对于每次询问，O(N)更新那一列的up和down，再O(n)单调队列扫一遍那一行，类似滑动窗口的来查询长度为k的序列的$min(up_i)和min(down_i)$，看它们加起来是否大于等于k，如果满足继续扩大k，否则标记答案。</p><p>上代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2005 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxq 10005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y,ans;</span><br><span class="line">&#125;nd[maxq];</span><br><span class="line"><span class="keyword">int</span> n,m,a[maxn][maxn],q,st[maxn],top=<span class="number">0</span>,up[maxn][maxn],down[maxn][maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> maxx=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) up[i][j]=(a[i][j]==<span class="number">0</span>?<span class="number">0</span>:up[i<span class="number">-1</span>][j]+<span class="number">1</span>); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--) down[i][j]=(a[i][j]==<span class="number">0</span>?<span class="number">0</span>:down[i+<span class="number">1</span>][j]+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    st[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    top=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(top&amp;&amp;up[i][j]&lt;=up[i][st[top]])&#123;<span class="comment">//单调栈 </span></span><br><span class="line">    maxx=max(maxx,min(up[i][st[top]],j<span class="number">-1</span>-st[top<span class="number">-1</span>]));</span><br><span class="line">    top--;</span><br><span class="line">&#125;</span><br><span class="line">st[++top]=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(top)&#123;</span><br><span class="line">maxx=max(maxx,min(up[i][st[top]],m-st[top<span class="number">-1</span>]));</span><br><span class="line">    top--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcc</span><span class="params">(<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) up[i][j]=(a[i][j]==<span class="number">0</span>?<span class="number">0</span>:up[i<span class="number">-1</span>][j]+<span class="number">1</span>); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--) down[i][j]=(a[i][j]==<span class="number">0</span>?<span class="number">0</span>:down[i+<span class="number">1</span>][j]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> q1[maxn],q2[maxn],front1,front2,rear1,rear2;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(len&gt;min(n,m)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">front1=front2=rear1=rear2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line"><span class="keyword">while</span>(front1&lt;rear1&amp;&amp;j-q1[front1]&gt;=len)front1++;</span><br><span class="line"><span class="keyword">while</span>(front1&lt;rear1&amp;&amp;up[i][q1[rear1<span class="number">-1</span>]]&gt;=up[i][j])rear1--;</span><br><span class="line">q1[rear1++]=j;</span><br><span class="line"><span class="keyword">while</span>(front2&lt;rear2&amp;&amp;j-q2[front2]&gt;=len)front2++;</span><br><span class="line"><span class="keyword">while</span>(front2&lt;rear2&amp;&amp;down[i][q2[rear2<span class="number">-1</span>]]&gt;=down[i][j])rear2--;</span><br><span class="line">q2[rear2++]=j;</span><br><span class="line"><span class="keyword">if</span>(j&gt;=len&amp;&amp;up[i][q1[front1]]+down[i][q2[front2]]<span class="number">-1</span>&gt;=len)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) a[i][j]=(s[j]==<span class="string">'+'</span>?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;nd[i].x,&amp;nd[i].y);a[nd[i].x][nd[i].y]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">calc();</span><br><span class="line">nd[q].ans=maxx;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=q;i&gt;=<span class="number">2</span>;i--)&#123;</span><br><span class="line">a[nd[i].x][nd[i].y]=<span class="number">1</span>;</span><br><span class="line">calcc(nd[i].y);<span class="comment">//更新 </span></span><br><span class="line">nd[i<span class="number">-1</span>].ans=nd[i].ans;</span><br><span class="line"><span class="keyword">while</span>(check(nd[i].x,maxx+<span class="number">1</span>)) maxx++,nd[i<span class="number">-1</span>].ans=maxx;<span class="comment">//只改动了这一行 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,nd[i].ans); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正难则反 </tag>
            
            <tag> 单调队列 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Chinese</title>
      <link href="/2018/11/06/51/"/>
      <url>/2018/11/06/51/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>一个n行m列的矩阵，每个格子可以填一个$1~k$的整数，矩阵中的一个格子为炼字当且仅当其值比其所在行和列的其它数都大，定义一个矩阵的精彩度为炼字的个数。设$f_i$为精彩度为i的方案数，显然:$\sum_{i=0}^{n \ast m} f_i=k^{n \ast m}$。现在你需要求出$\sum_{i=0}^{n \ast m} f_i \ast i mod (1e9+7)$</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>$n,m&lt;=10^9,k&lt;=10^6$</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>2 2 2</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>8</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先，对$\sum_{i=0}^{n \ast m} f_i \ast i$的理解为所有方案中炼字的个数和，那么考虑对每个格子单独计算贡献，如图：<br><img src="https://i.loli.net/2018/11/06/5be18a56030c0.jpg" alt=""><br>那么每个格子产生的贡献即为</p><script type="math/tex; mode=display">\sum_{i=1}^{k} k^{(n-1) \ast (m-1)} \ast (i-1)^{n-1} \ast (i-1)^{m-1}</script><p>因为相应性质，我们只要再乘上$n \ast m$即为最终答案。</p><p>上代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll n,m,k;</span><br><span class="line"><span class="function">ll <span class="title">qkpow</span><span class="params">(ll t,ll pos)</span></span>&#123;</span><br><span class="line">ll ans=<span class="number">1</span>,base=t;</span><br><span class="line"><span class="keyword">while</span>(pos)&#123;</span><br><span class="line"><span class="keyword">if</span>(pos&amp;<span class="number">1</span>) ans=ans*base%mod;</span><br><span class="line">base=base*base%mod;</span><br><span class="line">pos&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">ll t1=qkpow(k,(n<span class="number">-1</span>)*(m<span class="number">-1</span>)); </span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;i++) ans=(ans+qkpow(i,n<span class="number">-1</span>)*qkpow(i,m<span class="number">-1</span>)%mod*t1%mod)%mod;</span><br><span class="line">ans=ans*n%mod*m%mod;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Certificate</title>
      <link href="/2018/11/05/50/"/>
      <url>/2018/11/05/50/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>已知有$N(N≤14)$个变量，变量取值0或1。<br>已知$f(0,0,⋯,0)，⋯，f(1,1,⋯,1)$的函数值。<br>对于每种输入$x=(x_0,x_1,⋯,x_n)$，求最少需要知道几个变量的值即可确定函数值。<br>举个例子：假设有两个变量，函数$f(a,b)=a\&amp;b$，那么对于$f(x)=0$，我们只要知道其中一个变量为0即可确定函数值为0，否则我们需要知道两个变量是否都为1，才能确定函数值为1。</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>可以先$2^N$枚举选出的t个关键问题，再$2^N$判断，复杂度为$4^N$，可以勉强卡过。</p><p>上代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 16</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">1</span>&lt;&lt;maxn],check[<span class="number">1</span>&lt;&lt;maxn],n,a[<span class="number">1</span>&lt;&lt;maxn];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1</span>&lt;&lt;maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line">cnt++;</span><br><span class="line">x-=x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">int</span> all=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line"><span class="built_in">memset</span>(ans,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;s[i];i++) a[i]=(s[i]==<span class="string">'0'</span>?<span class="number">0</span>:<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;all;i++)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(check,<span class="number">-1</span>,<span class="keyword">sizeof</span>(check));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;all;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(check[i&amp;j]==<span class="number">-1</span>) check[i&amp;j]=a[j];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(check[i&amp;j]!=a[j]) check[i&amp;j]=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> len=calc(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;all;j++) <span class="keyword">if</span>(check[i&amp;j]==a[j]) ans[j]=min(ans[j],len);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;all;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>树的距离</title>
      <link href="/2018/11/03/48/"/>
      <url>/2018/11/03/48/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>开始有一个空的集合S，进行Q次操作：</p><p>1.插入一个数x（如果已存在就忽略）<br>2.删除一个数x（如果不存在就忽略）<br>3.询问点集中数与x的最短距离<br>定义两个数a,b的距离为，每次将a乘一个质数或除以一个质数因子，使a变成b的最小步数。$（Q≤50000,x≤1000000，时限2秒）$</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>对于两个数A,B:</p><script type="math/tex; mode=display">A=p_1^{a_1}+p_2^{a_2}+.....p_n^{a_n}</script><script type="math/tex; mode=display">B=p_1^{b_1}+p_2^{b_2}+.....p_n^{b_n}</script><p>(如果某些$p_i$，相应的次数为0)<br>那么A,B的距离即为</p><script type="math/tex; mode=display">\sum_{i=1}^n abs(a_i-b_i)</script><p>设gcd(A,B)为g，那么dis可以化为$num(\frac a{g})+num(\frac b{g})$，其中num(x)表示x包含的质数个数。<br>然后我们发现枚举B的话复杂度无法承受，那么转过来枚举A的因数来作为GCD，然后统计相应步数即可。当然这里可以用set或map来维护以谁为gcd的最小B.</p><p>上代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> prime[maxn&gt;&gt;<span class="number">1</span>],top=<span class="number">0</span>,s[maxn];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span></span>&#123;</span><br><span class="line">vis[<span class="number">0</span>]=vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn<span class="number">-5</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[i]) prime[++top]=i,s[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=top&amp;&amp;i*prime[j]&lt;=maxn<span class="number">-5</span>;j++)&#123;</span><br><span class="line">vis[prime[j]*i]=<span class="number">1</span>;s[prime[j]*i]=s[i]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> q,op,x;</span><br><span class="line"><span class="keyword">int</span> c[maxn][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;op,&amp;x);</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">1</span>&amp;&amp;!vis[x])&#123;</span><br><span class="line">vis[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;<span class="number">1l</span>l*j*j&lt;=x;j++) <span class="keyword">if</span>(x%j==<span class="number">0</span>)&#123; </span><br><span class="line">    c[j][s[x]-s[j]]++;</span><br><span class="line">    c[x/j][s[j]]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">2</span>&amp;&amp;vis[x])&#123;</span><br><span class="line">vis[x]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;<span class="number">1l</span>l*j*j&lt;=x;j++) <span class="keyword">if</span>(x%j==<span class="number">0</span>)&#123;</span><br><span class="line">c[j][s[x]-s[j]]--;</span><br><span class="line">c[x/j][s[j]]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">3</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;<span class="number">1l</span>l*j*j&lt;=x;j++) <span class="keyword">if</span>(x%j==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">20</span>;k++) <span class="keyword">if</span>(c[j][k]) ans=min(ans,k+s[x]-s[j]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">20</span>;k++) <span class="keyword">if</span>(c[x/j][k]) ans=min(ans,k+s[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans==<span class="number">1e9</span>) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ready();</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>滔滔的map代码：<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;map&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cmath&gt;</span></span><br><span class="line"><span class="comment">#include&lt;vector&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;algorithm&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=<span class="number">1000000</span>+<span class="number">5</span>,inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">int n,f[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">vector&lt;int&gt;primes;</span><br><span class="line">map&lt;int,int&gt;mp[maxn];</span><br><span class="line">void init()&#123;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">2</span>;i&lt;=maxn-<span class="number">5</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!f[i])f[i]=<span class="number">1</span>,primes.push_back(i);</span><br><span class="line"><span class="keyword">for</span>(int k=<span class="number">0</span>;k&lt;primes.size()&amp;&amp;i*primes[k]&lt;=maxn-<span class="number">5</span>;k++)&#123;</span><br><span class="line">f[i*primes[k]]=f[i]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i%primes[k]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void ins(int x)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[x])<span class="keyword">return</span>;vis[x]=<span class="number">1</span>;</span><br><span class="line">int sq=sqrt(x+<span class="number">0</span>.<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=sq;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(x%i==<span class="number">0</span>)mp[i][f[x]]++;</span><br><span class="line"><span class="keyword">if</span>(x%i==<span class="number">0</span>&amp;&amp;i*i!=x)mp[x/i][f[x]]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void del(int x)&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[x])<span class="keyword">return</span>;vis[x]=<span class="number">0</span>;</span><br><span class="line">int sq=sqrt(x+<span class="number">0</span>.<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=sq;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(x%i==<span class="number">0</span>)<span class="keyword">if</span>(--mp[i][f[x]]==<span class="number">0</span>)mp[i].erase(f[x]);</span><br><span class="line"><span class="keyword">if</span>(x%i==<span class="number">0</span>&amp;&amp;i*i!=x)<span class="keyword">if</span>(--mp[x/i][f[x]]==<span class="number">0</span>)mp[x/i].erase(f[x]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int Find(int i)&#123;</span><br><span class="line"><span class="keyword">if</span>(!mp[i].size())<span class="keyword">return</span> inf*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> mp[i].<span class="keyword">begin</span>()-&gt;first;</span><br><span class="line">&#125;</span><br><span class="line">void solve(int x)&#123;</span><br><span class="line">int sq=sqrt(x+<span class="number">0</span>.<span class="number">5</span>),ans=inf;</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=sq;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(x%i==<span class="number">0</span>)ans=min(ans,f[x]+Find(i)-<span class="number">2</span>*f[i]);</span><br><span class="line"><span class="keyword">if</span>(x%i==<span class="number">0</span>&amp;&amp;i*i!=x)ans=min(ans,f[x]+Find(x/i)-<span class="number">2</span>*f[x/i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans&gt;=inf)printf(<span class="string">"-1\n"</span>);</span><br><span class="line"><span class="keyword">else</span> printf(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">init();</span><br><span class="line">scanf(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">1</span>,op,x;i&lt;=n;i++)&#123;</span><br><span class="line">scanf(<span class="string">"%d%d"</span>,&amp;op,&amp;x);</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">1</span>)ins(x);</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">2</span>)del(x);</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">3</span>)solve(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 枚举 </tag>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>小G的树</title>
      <link href="/2018/11/03/47/"/>
      <url>/2018/11/03/47/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给出n个点的树，每条边长会等概率是1或2，求树的直径的期望。（$n≤60$）</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>只要会树型dp求树的直径，然后枚举就可以$O(n^4)$过了</p><p>上代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 70</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll g[maxn&lt;&lt;<span class="number">1</span>][maxn&lt;&lt;<span class="number">1</span>],ff[maxn][maxn&lt;&lt;<span class="number">1</span>][maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> n,x,y;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eage</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,next;</span><br><span class="line">&#125;e[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> np=<span class="number">0</span>,first[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">e[++np]=(eage)&#123;v,first[u]&#125;;</span><br><span class="line">first[u]=np;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sz[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">     ff[i][<span class="number">0</span>][<span class="number">0</span>]=sz[i]=<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> p=first[i];p;p=e[p].next)&#123;</span><br><span class="line"> <span class="keyword">int</span> j=e[p].to;</span><br><span class="line"> <span class="keyword">if</span>(j==f) <span class="keyword">continue</span>;</span><br><span class="line"> dfs(j,i);</span><br><span class="line"> <span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span>(g));</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> l1=<span class="number">0</span>;l1&lt;=sz[i]*<span class="number">2</span>;l1++)</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> z1=l1;z1&lt;=sz[i]*<span class="number">2</span>;z1++)<span class="keyword">if</span>(ff[i][l1][z1])</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> l2=<span class="number">0</span>;l2&lt;=sz[j]*<span class="number">2</span>;l2++)</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> z2=l2;z2&lt;=sz[j]*<span class="number">2</span>;z2++) <span class="keyword">if</span>(ff[j][l2][z2])&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">1</span>;len&lt;=<span class="number">2</span>;len++)&#123;</span><br><span class="line">     <span class="keyword">int</span> t=max(z1,z2);</span><br><span class="line">     t=max(t,l1+l2+len);</span><br><span class="line"> g[max(l1,l2+len)][t]+=ff[i][l1][z1]*ff[j][l2][z2];;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sz[i]+=sz[j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;=sz[i]*<span class="number">2</span>;l++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> z=l;z&lt;=sz[i]*<span class="number">2</span>;z++)</span><br><span class="line">ff[i][l][z]=g[l][z];</span><br><span class="line"> &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);add(x,y);add(y,x);</span><br><span class="line">&#125; </span><br><span class="line">dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;=n*<span class="number">2</span>;l++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> z=l;z&lt;=n*<span class="number">2</span>;z++)&#123;</span><br><span class="line">ans+=ff[<span class="number">1</span>][l][z]*z;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lf"</span>,ans/(<span class="number">1l</span>l&lt;&lt;(n<span class="number">-1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率期望 </tag>
            
            <tag> 树型dp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>郁闷的小G</title>
      <link href="/2018/11/03/46/"/>
      <url>/2018/11/03/46/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>有5种类型的题E,EM,M,MH,H若干，其中E,EM可用来出第一题，EM,M,MH可用来出第二题，MH,H可用来出第三题，求最多可出多少场模拟赛。（设N为最大数，$1≤N≤10^18$）</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>我干考试时懵了直接上了个大模拟，结果用二分简单到爆炸！！！</p><p>模拟：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll e,em,m,mh,h,a,b,c,x=<span class="number">1</span>,y=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld%lld"</span>,&amp;e,&amp;em,&amp;m,&amp;mh,&amp;h);</span><br><span class="line"> a=e+em,b=m,c=mh+h;</span><br><span class="line"> <span class="keyword">if</span>(a&lt;=b) x=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">if</span>(c&lt;=b) y=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">if</span>(!x&amp;&amp;!y)&#123;</span><br><span class="line"> ll ans=min(a,min(b,c));</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(!x)&#123;</span><br><span class="line"> ll mid=(b+c)/<span class="number">2</span>;</span><br><span class="line"> <span class="keyword">if</span>(mid-b&lt;=mh) y=mid-b;</span><br><span class="line"> <span class="keyword">else</span> y=mh;</span><br><span class="line"> ll minn=y+b;</span><br><span class="line"> ll ans=min(a,minn);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>(!y)&#123;</span><br><span class="line"> ll mid=(a+b)/<span class="number">2</span>;</span><br><span class="line"> <span class="keyword">if</span>(mid-b&lt;=em) x=mid-b;</span><br><span class="line"> <span class="keyword">else</span> x=em;</span><br><span class="line"> ll minn=b+x;</span><br><span class="line"> ll ans=min(minn,c);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(a&gt;c)&#123;</span><br><span class="line"> ll mv=a-c;</span><br><span class="line"> <span class="keyword">if</span>(mv&gt;em) mv=em;</span><br><span class="line">a=a-mv; </span><br><span class="line"> <span class="keyword">if</span>(b+mv&gt;=c)&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%lld"</span>,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(mv==em)&#123;</span><br><span class="line">b+=mv;</span><br><span class="line">ll mid=(b+c)/<span class="number">2</span>;</span><br><span class="line">             <span class="keyword">if</span>(mid-b&lt;=mh) y=mid-b;</span><br><span class="line">             <span class="keyword">else</span> y=mh;</span><br><span class="line">             ll minn=y+b;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"%lld"</span>,minn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">b+=mv;</span><br><span class="line">em-=mv;<span class="comment">//还剩的步数 </span></span><br><span class="line">ll mvv=min(em,mh);</span><br><span class="line">ll cnt=(c-b)/<span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt&gt;mvv) cnt=mvv;</span><br><span class="line">ll minn=b+cnt*<span class="number">2</span>;</span><br><span class="line">c=c-cnt,a=a-cnt;em-=mvv;mh-=mvv;</span><br><span class="line"><span class="keyword">if</span>(minn&lt;c)&#123;</span><br><span class="line">   <span class="keyword">if</span>(em)&#123;</span><br><span class="line">   ll mid=(minn+c)/<span class="number">2</span>;</span><br><span class="line">                 <span class="keyword">if</span>(mid-minn&lt;=em) y=mid-minn;</span><br><span class="line">                 <span class="keyword">else</span> y=em;</span><br><span class="line">                 minn=minn+y;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(mh)&#123;</span><br><span class="line">   ll mid=(minn+c)/<span class="number">2</span>;</span><br><span class="line">                 <span class="keyword">if</span>(mid-minn&lt;=mh) y=mid-minn;</span><br><span class="line">                 <span class="keyword">else</span> y=mh;</span><br><span class="line">                 minn=minn+y;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,minn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span>&#123;</span><br><span class="line"> ll mv=c-a;</span><br><span class="line"> <span class="keyword">if</span>(mv&gt;mh) mv=mh;</span><br><span class="line">c=c-mv; </span><br><span class="line"> <span class="keyword">if</span>(b+mv&gt;=a)&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%lld"</span>,a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(mv==mh)&#123;</span><br><span class="line">b+=mv;</span><br><span class="line">ll mid=(a+b)/<span class="number">2</span>;</span><br><span class="line">             <span class="keyword">if</span>(mid-b&lt;=em) x=mid-b;</span><br><span class="line">             <span class="keyword">else</span> x=em;</span><br><span class="line">             ll minn=b+x;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"%lld"</span>,minn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">b+=mv;</span><br><span class="line">mh-=mv;<span class="comment">//还剩的步数 </span></span><br><span class="line">ll mvv=min(em,mh);</span><br><span class="line">ll cnt=(c-b)/<span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt&gt;mvv) cnt=mvv;</span><br><span class="line">ll minn=b+cnt*<span class="number">2</span>;</span><br><span class="line">c=c-cnt,a=a-cnt;em-=mvv;mh-=mvv;</span><br><span class="line"><span class="keyword">if</span>(minn&lt;c)&#123;</span><br><span class="line">   <span class="keyword">if</span>(em)&#123;</span><br><span class="line">   ll mid=(minn+c)/<span class="number">2</span>;</span><br><span class="line">                 <span class="keyword">if</span>(mid-minn&lt;=em) y=mid-minn;</span><br><span class="line">                 <span class="keyword">else</span> y=em;</span><br><span class="line">                 minn=minn+y;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(mh)&#123;</span><br><span class="line">   ll mid=(minn+c)/<span class="number">2</span>;</span><br><span class="line">                 <span class="keyword">if</span>(mid-minn&lt;=mh) y=mid-minn;</span><br><span class="line">                 <span class="keyword">else</span> y=mh;</span><br><span class="line">                 minn=minn+y;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,minn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>滔滔的二分：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(LL mid,LL A,LL B,LL C,LL A_B,LL B_C)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(A&lt;mid)&#123;<span class="keyword">if</span>(A+A_B&lt;mid)<span class="keyword">return</span> <span class="literal">false</span>;A_B-=mid-A;&#125;B+=A_B;</span><br><span class="line"><span class="keyword">if</span>(B&lt;mid)&#123;<span class="keyword">if</span>(B+B_C&lt;mid)<span class="keyword">return</span> <span class="literal">false</span>;B_C-=mid-B;&#125;</span><br><span class="line">C+=B_C;<span class="keyword">if</span>(C&lt;mid)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">LL A,B,C,A_B,B_C;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld%lld"</span>,&amp;A,&amp;A_B,&amp;B,&amp;B_C,&amp;C);</span><br><span class="line">LL L=min(&#123;A,B,C&#125;),R=max(&#123;A+A_B,B+A_B+B_C,B_C+C&#125;),ans;</span><br><span class="line"><span class="keyword">while</span>(L&lt;=R)&#123;</span><br><span class="line">LL mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(check(mid,A,B,C,A_B,B_C))ans=mid,L=mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> R=mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>取数游戏</title>
      <link href="/2018/11/01/45/"/>
      <url>/2018/11/01/45/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>有一个$N \ast M$的矩阵，你需要进行恰好K次操作，每次可以选择其中一行或者其中一列，将其中的元素全部累加到ans里去，然后把全中的这些数全部减去P，问ans最大是多少</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>2 2 2 2<br>1 3<br>2 4</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>11</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>$N,M&lt;=1000,K&lt;=10^5,0&lt;=P&lt;=100,1&lt;A_{ij}&lt;1000$</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先探究性质发现取行或取列只分别对列和行整体造成影响，贪心还是要取大的，所以只考虑对自身的影响。再发现取行或取列都是分别对以后的取列或取行造成-p的影响，所以先后是没有关系的。<br>那么先预处理出去行k次和取列k次最大值，再O(n)枚举行列分别取多少，再减去$i \ast (k-i) \ast p$即可。</p><p>上代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll h[maxn],l[maxn],sh[maxn],sl[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,k,p,x;</span><br><span class="line">priority_queue&lt;ll&gt;q,qq;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;k,&amp;p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">    h[i]+=x;l[j]+=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) q.push(h[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">ll t=q.top();q.pop();</span><br><span class="line">sh[i]=sh[i<span class="number">-1</span>]+t;t-=m*p;</span><br><span class="line">q.push(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) qq.push(l[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">ll t=qq.top();qq.pop();</span><br><span class="line">sl[i]=sl[i<span class="number">-1</span>]+t;t-=n*p;</span><br><span class="line">qq.push(t); </span><br><span class="line">&#125;</span><br><span class="line">ll ans=<span class="number">-1000000000000</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++)&#123;</span><br><span class="line">  ans=max(ans,sh[i]+sl[k-i]<span class="number">-1l</span>l*i*(k-i)*p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 优先队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>字符串</title>
      <link href="/2018/11/01/44/"/>
      <url>/2018/11/01/44/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>要求用m种字母构造一个长度为n的字符串，使得该字符串的所有长度为k的子串均为回文串，问方案数</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>三个整数$n,m,k(1≤n,m,k≤2000)$</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>输出满足条件的字符串数量，结果模$10^9+7$</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>5 2 4</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>2</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>对于每个位置，考虑它在一个回文串中的位置，与它相应的与它用并查集相连(回文串必须一样)，最后剩下若干集合，有cnt个，那么答案即为$m^{cnt}$，当然也可以直接分k,n关系讨论</p><p>并查集代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;P;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>,maxn=<span class="number">100001</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=(ll)ans*a%mod;</span><br><span class="line">        a=(ll)a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,k,fa[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=find(x),y=find(y);</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span> ;</span><br><span class="line">    fa[x]=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,k;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fa[i]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;k&amp;&amp;i+k-j&lt;=n;j+=<span class="number">2</span>)</span><br><span class="line">                unite(i,i+k-j);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">if</span>(fa[i]==i)ans++;</span><br><span class="line">        ans=Pow(m,ans);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>nk关系代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="function">ll <span class="title">qkpow</span><span class="params">(ll t,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">ll ans=<span class="number">1</span>,base=t;</span><br><span class="line"><span class="keyword">while</span>(pos)&#123;</span><br><span class="line"><span class="keyword">if</span>(pos&amp;<span class="number">1</span>) ans=ans*base%mod;</span><br><span class="line">base=base*base%mod;</span><br><span class="line">pos=pos&gt;&gt;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,qkpow(m,n));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k==n) <span class="built_in">printf</span>(<span class="string">"%lld"</span>,qkpow(m,(k+<span class="number">1</span>)/<span class="number">2</span>));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k&amp;<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%lld"</span>,m*m%mod);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k&gt;n) <span class="built_in">printf</span>(<span class="string">"%lld"</span>,qkpow(m,n));</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d"</span>,m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Coin</title>
      <link href="/2018/10/31/43/"/>
      <url>/2018/10/31/43/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>小M有个n行m列的棋盘，每个格子都包含了至多一枚硬币，硬币正面或者反面朝上。<br>小M和小D轮流操作，小M先手。每个人可以选择棋盘中没在之前被选择过的一行或者一列，然后将所选的行或列上的硬币全部翻转，即正面变成反面，反面变成正面。<br>当所有硬币都正面朝上或者所有的行列都被选择，游戏结束。最后一次操作的玩家将会获得1分。如果当前局面所有的硬币都正面朝上，小M和小D都将获得2分的额外收益。<br>问两个人如果都按最优策略操作，即最大化自己的分数，那么小M最后的得分是多少。（T组数据，1≤T,n,m≤100）<br>保证每列至少有一个硬币，每行至少有一个反面朝上的硬币。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>1<br>2 5<br>exexe<br>xeoex</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>3</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先如果能构成全向上的局面，那么两人肯定是要构成的。否则就按照n+m奇偶来决定最后谁走。<br>我们假设向上为0，向下为1，那么对于每一个$a_{ij}$，要求满足$h_i xor l_j xor a_{ij}==0$，变化一下即为<br>$h_i xor l_j==a_{i-j}$，所以我们设$a_{ij}$为边权，然后可以连边维护，用类似二分图染色的方法扫一遍以判断是否合法(本可以用并查集维护，但貌似方式不对，联系不紧密)<br>那么我们现在就会有诸多联通块，对每个联通块是个独立游戏，我们开始讨论：<br>如果是奇-奇那么先手在这一块必定赢，而偶偶先手必输但是没影响因为如果有奇奇的话，先手最后是多下一步的，这是第一部分。第二部分就是奇偶，如果只有奇数个奇偶，那么最终先手可以多选一个奇偶的奇而获胜，否则后手选到奇偶的偶获胜。<br>注意细节实现就行了。</p><p>上代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 105</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eage</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,next,len;</span><br><span class="line">&#125;e[maxn*maxn*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> np=<span class="number">0</span>,first[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">e[++np]=(eage)&#123;v,first[u],len&#125;;</span><br><span class="line">first[u]=np;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t,n,m;</span><br><span class="line"><span class="keyword">char</span> op[maxn];</span><br><span class="line"><span class="keyword">bool</span> ok;</span><br><span class="line"><span class="keyword">int</span> base;</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> color[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">cnt[color[i]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> p=first[i];p;p=e[p].next)&#123;</span><br><span class="line"><span class="keyword">int</span> j=e[p].to,c=e[p].len;</span><br><span class="line"><span class="keyword">if</span>(c==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(color[j])&#123;</span><br><span class="line">    <span class="keyword">if</span>(color[j]!=color[i]) ok=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">color[j]=color[i];</span><br><span class="line">dfs(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(color[j])&#123;</span><br><span class="line"><span class="keyword">if</span>(color[i]==color[j]) ok=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">color[j]=<span class="number">3</span>-color[i];</span><br><span class="line">dfs(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+m;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!color[i])&#123;</span><br><span class="line">cnt[<span class="number">1</span>]=cnt[<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">color[i]=<span class="number">1</span>;</span><br><span class="line">ok=<span class="literal">true</span>;</span><br><span class="line">dfs(i);</span><br><span class="line"><span class="keyword">if</span>(!ok) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt[<span class="number">1</span>]&amp;<span class="number">1</span>&amp;&amp;cnt[<span class="number">2</span>]&amp;<span class="number">1</span>) base^=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!(cnt[<span class="number">1</span>]&amp;<span class="number">1</span>)&amp;&amp;!(cnt[<span class="number">2</span>]&amp;<span class="number">1</span>)) ;</span><br><span class="line"><span class="keyword">else</span> base^=<span class="number">2</span>;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">memset</span>(color,<span class="number">0</span>,<span class="keyword">sizeof</span>(color));</span><br><span class="line"><span class="built_in">memset</span>(first,<span class="number">0</span>,<span class="keyword">sizeof</span>(first));</span><br><span class="line">np=<span class="number">0</span>;</span><br><span class="line">ok=<span class="literal">true</span>;</span><br><span class="line">base=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,op+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line"> <span class="keyword">if</span>(op[j]==<span class="string">'x'</span>)&#123;</span><br><span class="line"> add(i,j+n,<span class="number">1</span>);</span><br><span class="line"> add(j+n,i,<span class="number">1</span>);</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span>(op[j]==<span class="string">'o'</span>)&#123;</span><br><span class="line"> add(i,j+n,<span class="number">0</span>);</span><br><span class="line"> add(j+n,i,<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">run();</span><br><span class="line"><span class="keyword">if</span>(!ok)&#123;</span><br><span class="line"><span class="keyword">int</span> calc=n+m;</span><br><span class="line"><span class="keyword">if</span>(calc&amp;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(base) <span class="built_in">printf</span>(<span class="string">"3\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"2\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐式图 </tag>
            
            <tag> 博弈论 </tag>
            
            <tag> 二分图 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Poker</title>
      <link href="/2018/10/31/42/"/>
      <url>/2018/10/31/42/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>一共有n张扑克牌，第i张扑克牌的编号为$a_i$，这里保证n为偶数。<br>先将n张牌随机的分成两堆大小为$\frac{n}{2}$的牌，一人拿一堆，随机为均匀随机。<br>将n张牌随机打乱，两人开始比大小，按顺序翻各自的牌，如果前者大于后者，那么前者得一分，否则后者得一分，问前者和后者得分的期望，输出答案乘上n!然后对1e9+7取模的值。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>4<br>1 2 3 2</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>20 28</p><h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><p>$n&lt;=10^5$</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>其实是个假期望题。<br>发现总方案数是n!，所以实际上是找全排列并统计得分。然后发现是排列，所以每次可以固定两个不同的数，然后乘上(n-2)!</p><p>上代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[maxn];</span><br><span class="line">ll jc;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">jc=<span class="number">1l</span>l;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">if</span>(i&lt;=n<span class="number">-2</span>) jc=jc*(ll)i%mod;</span><br><span class="line">&#125;</span><br><span class="line">sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">ll ans1=<span class="number">0</span>;</span><br><span class="line">ll cnt=<span class="number">0</span>;</span><br><span class="line">ll len=n/<span class="number">2</span>; </span><br><span class="line">ll ans2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]==a[i+<span class="number">1</span>])&#123;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">cnt++;</span><br><span class="line">ans1=(ans1+cnt*jc%mod*(ll)(n-i)%mod)%mod;</span><br><span class="line">ans2=(ans2+cnt*jc%mod*(ll)(n-i+cnt<span class="number">-1</span>)%mod)%mod;</span><br><span class="line">cnt=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans1=ans1*len%mod;</span><br><span class="line">ans2=ans2*len%mod;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld "</span>,ans1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans2);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率期望 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>当那一天来临</title>
      <link href="/2018/10/30/41/"/>
      <url>/2018/10/30/41/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>一条线段上有n个点，每个点有一个权值，要是一个人经过一个权值为w的点，那么他的金钱就增加w（w可以为负数）。<br>现在Jack最开始在1号点，Rose最开始在n号点（此时Jack只有1号点的金钱，Rose只有n号点的金钱），他们要走到某个站点相会，整个过程中只能相向而行，并且每一次走一个点。首先是Jack选择自己向右走一个点或者让Rose向左做一个点；接着是Rose选择让Jack向右走一个点或者自己向左走一个点；接着又是Jack选择，直到两个人相遇。<br>现在两人都采用最优策略，问相遇之后他们谁金钱多。如果Jack比Rose的金钱多，输出“win”，相等输出“tie”，少则输出“lose”。（T组数据，T≤10,1≤n≤10000）</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><p>3<br>4<br>1 3 2 3<br>4<br>1 2 2 3<br>5<br>-1 -2 -1 -1 -1 </p><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><p>win<br>tie<br>lose</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>对于100%的数据，1&lt;=N&lt;=10000.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先我们可以将题目的选项实际化，让自己走就是正常，让别人走就是让终点往自己这边移动，然后我们发现答案只与最终相遇位置有关。那么举几个例子，发现在n为偶数时，先手能够决定终点是在n/2+1或者n/2.而在n为奇数时，若先手先让自己走，那么后手能决定终点在n/2+1或n/2+1+1;若先手先让对面走，那么后手能决定终点在n/2+1或n/2。(所以大力分情况讨论即可)实际上n为奇数就是-1变成n为偶数然后交换先手权罢了。</p><p>上代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,a[maxn],sum1,sum2;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">sum1=sum2=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">int</span> z=n/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">if</span>(i&lt;=z) sum1+=a[i];</span><br><span class="line"><span class="keyword">if</span>(i&gt;=z) sum2+=a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n&amp;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> t=sum1-sum2;</span><br><span class="line"><span class="keyword">int</span> changez=-a[z]-a[z<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">int</span> changey=a[z]+a[z+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> change=max(changey,changez);<span class="comment">//由先手决定</span></span><br><span class="line">t=min(t,t+change);<span class="comment">//由后手决定</span></span><br><span class="line"><span class="keyword">if</span>(t&gt;<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"win\n"</span>);</span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"tie\n"</span>);</span><br><span class="line"><span class="keyword">if</span>(t&lt;<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"lose\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> t=sum1-sum2;</span><br><span class="line"><span class="keyword">int</span> change=-a[z]-a[z<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(change&gt;<span class="number">0</span>) t+=change;</span><br><span class="line"><span class="keyword">if</span>(t&gt;<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"win\n"</span>);</span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"tie\n"</span>);</span><br><span class="line"><span class="keyword">if</span>(t&lt;<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"lose\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++) init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博弈论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>假如战争今天爆发</title>
      <link href="/2018/10/30/40/"/>
      <url>/2018/10/30/40/</url>
      
        <content type="html"><![CDATA[<p><font color="green">假如<del>战争今天爆发</del>生活欺骗了你</font></p><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>有n件物品，每件物品要被三个机器一次加工（即是说，只有被第一个机器加工后才能被第二个机器加工，被第二个机器加工后才能被第三个机器加工）。第i件物品被三个机器加工所需要的时间分别为$A_i,B_i,C_i$，保证 $min(C_i)≥max(B_i)$。每个机器同一时刻只能加工一件物品，求让每件物品都被三个机器加工完所需要的最少时间。$（1≤n≤100000,0&lt;A_i,B_i,C_i&lt;106）$</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><p>3<br>5 3 4<br>3 2 9<br>3 4 8</p><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><p>26</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先可以假设已经排好了顺序，那么计算最终时间，设dp(i,j)表示第i个被第j个机器加完工的时间，那么:<br>$dp[i][j]=max(dp[i][j-1],dp[i-1][j])+a_{ij}$，那我们把它转移到图上面即从(1,1)到(n,3)，每次可以从左边或上边转移过来，实际上就发现是求最长路，如图：<br><img src="https://i.loli.net/2018/11/06/5be1a22f9e267.png" alt=""><br>那么对于绿色和黄色的我们交换其间任意两个是没有影响的，而对于蓝色和黄色处便会有影响，这便是决定排列顺序的，所以当i要排在j前面的条件如下：</p><script type="math/tex; mode=display">max(a_{i1}+a_{i2}+a_{i3}+a_{j3},a_{i1}+a_{j1}+a_{j2}+a_{j3})<=max(a_{j1}+a_{j2}+a_{j3}+a_{i3},a_{j1}+a_{i1}+a_{i2}+a_{i3})</script><script type="math/tex; mode=display">max(a_{i2}+a_{i3},a_{j1}+a_{j2})+a_{i1}+a_{j3}<=max(a_{j2}+a_{j3},a_{i1}+a_{i2})+a_{j1}+a_{i3}</script><p>设$a_{i1}+a_{i2}$为$A_i$，$a_{i2}+a_{i3}$为$B_i$，那么，转化为：</p><script type="math/tex; mode=display">max(B_i,A_j)+A_i-B_i<=max(B_j,A_i)+A_j-B_j</script><p>进一步转化为：</p><script type="math/tex; mode=display">max(-A_j,-B_i)<=max(-A_i,-B_j)</script><p>那么以这个为关键字排序就欧克了，就可以得到最终的最优排列顺序。</p><p>上代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll suma[maxn],sumc[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(node x,node y)&#123;</span><br><span class="line"><span class="keyword">int</span> ai=x.a+x.b,aj=y.a+y.b,bi=x.b+x.c,bj=y.b+y.c;</span><br><span class="line"><span class="keyword">return</span> max(-aj,-bi)&lt;=max(-ai,-bj);</span><br><span class="line">&#125;</span><br><span class="line">&#125;nd[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;nd[i].a,&amp;nd[i].b,&amp;nd[i].c);</span><br><span class="line">    sort(nd+<span class="number">1</span>,nd+n+<span class="number">1</span>);</span><br><span class="line">    ll ta=<span class="number">0</span>,tb=<span class="number">0</span>,tc=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    ta+=nd[i].a;</span><br><span class="line"><span class="keyword">if</span>(tb&lt;ta) tb=ta;</span><br><span class="line">tb+=nd[i].b;</span><br><span class="line"><span class="keyword">if</span>(tc&lt;tb) tc=tb;</span><br><span class="line">tc+=nd[i].c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,tc);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> dp </tag>
            
            <tag> 最长路 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>强军战歌</title>
      <link href="/2018/10/30/39/"/>
      <url>/2018/10/30/39/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给出一个数列<script type="math/tex">A</script>，当这个数列不是不下降的时候我们删除其中一个数，直到它是不下降的。求不同的删除方案总数，答案对<script type="math/tex">1000000007</script>取模。我们定义删除方案不同有两种情况：</p><ul><li>删掉的数构成的集合不同</li><li>删掉的数构成的集合相同，但删除顺序不同</li></ul><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><p>3<br>1 7 5</p><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><p>4</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>$1&lt;=n&lt;=2000,1&lt;=A_i&lt;=2000$</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>探究问题本质，发现是删掉数后刚好(首次)是个非严格LIS，那么我们如果去掉刚好这个限制，总方案数就会是$\sum_{i=1}^{n} cnt_i \ast (n-i)!$，其中$cnt_i$为长度为i的LIS个数，那么显然这样是不行的，因为有很多不合法的计入了。<br>那么什么样的是不合法的呢，即已经是LIS之后还继续删除，这样的数即为$\sum_{i=2}^{n} cnt_i \ast i \ast (n-i)!$，注意这里1的没有计入，因为1删完之后就没了a23333.<br>综上，$ans=\sum_{i=1}^{n} cnt_i \ast (n-i)!-\sum_{i=2}^{n} cnt_i \ast i \ast (n-i)!$.<br>然后是对于$cnt_i$的计算，我们设dp(i,j)表示以i结尾长度为j的LIS个数，那么：<br>(tips:可以了解一下这个思路，以后统计找结尾和长度以便于统计，因为LIS结尾要求递增，可以dp)<br>$dp[i][j]+=dp[k][j-1] k在j前面且a[k]&lt;=a[j]$<br>由于范围限制，我们使用树状数组来维护将其优化到$n^2logn$，那么这里需要离散化来确定哪些比它小。(详见代码注释)</p><p>上代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2005 </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[maxn],aa[maxn];</span><br><span class="line">ll dp[maxn][maxn];<span class="comment">//以i结尾,长度为j </span></span><br><span class="line">ll cnt[maxn];</span><br><span class="line">ll jc[maxn];</span><br><span class="line">ll c[maxn][maxn];<span class="comment">//c[i][j]：长度为i，在j前面(lowbit长度)的方案数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span></span>&#123;</span><br><span class="line">jc[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=<span class="number">2000</span>;i++) jc[i]=jc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> w,<span class="keyword">int</span> i,ll d)</span></span>&#123;</span><br><span class="line">     <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">     c[w][i]=(c[w][i]+d)%mod;</span><br><span class="line">     i+=(i&amp;-i);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> w,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">ll res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">res=(res+c[w][i])%mod;</span><br><span class="line">i-=(i&amp;-i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">   rear=0;</span></span><br><span class="line"><span class="comment">   for(int j=i;j&lt;=n;j++)&#123;</span></span><br><span class="line"><span class="comment">   int t=upper_bound(q+1,q+rear+1,a[j])-q;</span></span><br><span class="line"><span class="comment">   if(t==rear+1) q[++rear]=a[j];else&#123;</span></span><br><span class="line"><span class="comment">   if(t==1) continue;//头不能更换 来保证独立性，以当前为开头 </span></span><br><span class="line"><span class="comment">   q[t]=a[j];</span></span><br><span class="line"><span class="comment">&#125; </span></span><br><span class="line"><span class="comment">cnt[t]++;</span></span><br><span class="line"><span class="comment">   for(int k=t-1;k&gt;=2;k--) cnt[k]++; </span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span><span class="comment">//干！不行aaaaaaaaaaaa</span></span><br><span class="line"><span class="built_in">memcpy</span>(aa,a,<span class="keyword">sizeof</span>(a));</span><br><span class="line">sort(aa+<span class="number">1</span>,aa+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> cntt=unique(aa+<span class="number">1</span>,aa+n+<span class="number">1</span>)-aa<span class="number">-1</span>;</span><br><span class="line"><span class="comment">/*for(int i=1;i&lt;=n;i++)&#123;//枚举开头 </span></span><br><span class="line"><span class="comment">    memset(c,0,sizeof(c));</span></span><br><span class="line"><span class="comment">dp[i][1]=1;</span></span><br><span class="line"><span class="comment">int pos=lower_bound(aa+1,aa+n+1,a[i])-aa;</span></span><br><span class="line"><span class="comment">update(1,pos,1); </span></span><br><span class="line"><span class="comment">for(int j=2;j&lt;=n;j++)&#123;</span></span><br><span class="line"><span class="comment">ll calc=0;</span></span><br><span class="line"><span class="comment">for(int k=i+1;k&lt;=n;k++)&#123;</span></span><br><span class="line"><span class="comment">pos=lower_bound(aa+1,aa+n+1,a[k])-aa;</span></span><br><span class="line"><span class="comment">int tt=sum(j-1,pos-1);</span></span><br><span class="line"><span class="comment">calc+=tt;</span></span><br><span class="line"><span class="comment">update(j,pos,tt);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">dp[i][j]=calc;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">1</span>]=<span class="number">1</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=i;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> pos=lower_bound(aa+<span class="number">1</span>,aa+cntt+<span class="number">1</span>,a[i])-aa;</span><br><span class="line">dp[i][j]=sum(j<span class="number">-1</span>,pos);<span class="comment">//等于长度为j-1的 </span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=i;k++)&#123;</span><br><span class="line">        <span class="keyword">int</span> pos=lower_bound(aa+<span class="number">1</span>,aa+cntt+<span class="number">1</span>,a[i])-aa;</span><br><span class="line">        update(k,pos,dp[i][k]);</span><br><span class="line">&#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) cnt[j]=(cnt[j]+dp[i][j])%mod;</span><br><span class="line"></span><br><span class="line">ll all=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">all=(all+cnt[i]*jc[n-i]%mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line">ll del=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">del=(del+cnt[i]*i%mod*jc[n-i]%mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line">ll ans=(all-del+mod)%mod;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ready();</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> LIS </tag>
            
            <tag> 离散化 </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>已经没有什么好害怕的了</title>
      <link href="/2018/10/29/38/"/>
      <url>/2018/10/29/38/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定一个长度为n只包含左括号和右括号的序列，现在小R想要知道经过每一个位置的合法子串有多少个（空串是一个合法的串，如果A和B都是合法的串，那么(A)和AB都是合法的串）。</p><p>共T组数据，对于每组数据，输出一个整数表示答案，令$ans_i$为经过第i个位置的子串个数，那么你需要输出$\sum^{n}_{i=1}(i×ans_i mod 1e9+7)$。$（1≤T≤10,n≤10^6）$</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先对于每一个合法的串内部扩起来的，我们对它所涵盖的加1，那么会想到差分，如图:<br><img src="https://i.loli.net/2018/11/06/5be1a22f6e282.png" alt=""><br>即为差分的方式:在左端点加1，在右端点+1的地方减1.<br>首先是可以暴力维护的，但是肯定会超时，那么我使用递推来将其优化到O(n).</p><p>上代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> st[maxn],top=<span class="number">0</span>,q[maxn],h[maxn],pre[maxn],next[maxn];</span><br><span class="line">ll val[maxn];<span class="comment">//q,h:前后括号 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="keyword">sizeof</span>(h));</span><br><span class="line"><span class="built_in">memset</span>(q,<span class="number">0</span>,<span class="keyword">sizeof</span>(q));</span><br><span class="line"><span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="keyword">sizeof</span>(pre));</span><br><span class="line"><span class="built_in">memset</span>(next,<span class="number">0</span>,<span class="keyword">sizeof</span>(next));</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> len=<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">top=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;s[i];i++)&#123;</span><br><span class="line">       <span class="keyword">if</span>(s[i]==<span class="string">'('</span>) st[++top]=i;</span><br><span class="line">       <span class="keyword">else</span><span class="keyword">if</span>(top) h[st[top]]=i+<span class="number">1</span>,q[i+<span class="number">1</span>]=st[top],top--;<span class="comment">//标记后一个括号和前一个括号 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i; </span><br><span class="line"><span class="keyword">for</span>(i=len+<span class="number">1</span>;i&gt;=<span class="number">1</span>;i--)&#123;next[i]++;next[q[i]]+=next[i];&#125; <span class="comment">//对前面括号造成贡献</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;s[i];i++)&#123;pre[i]--;pre[h[i]]+=pre[i];&#125; <span class="comment">//对后面括号造成贡献 </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;s[i];i++) val[i]=pre[i]+next[i];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;s[i];i++) val[i]+=val[i<span class="number">-1</span>];<span class="comment">//差分 </span></span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;s[i];i++) ans=(ans+val[i]*<span class="number">1l</span>l*i%mod);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++) init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 差分 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线段树什么的最讨厌了</title>
      <link href="/2018/10/29/37/"/>
      <url>/2018/10/29/37/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>这是小R写的线段树的一段建树代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildtree</span><span class="params">(<span class="keyword">int</span> k1,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">  buildtree(k1*<span class="number">2</span>,l,mid);buildtree(k1*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只要调用buildtree(1,0,n)就可以得到一颗线段树了。显然，一颗线段树一共有O(n)个节点，因为每一个节点都代表了一个不同的区间，所以线段树上一共出现了O(n)个不同的区间。</p><p>现在小R给了你一个区间[L,R]，他想要你告诉他一个最小的不超过lim的n使得区间[L,R]出现在了用buildtree(1,0,n)建出来的线段树中，若无解输出−1。（T组数据，$T≤100,lim≤2×10^9,0≤L≤R≤10^9,\frac{L}{R−L+1}≤2×10^3$）</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>实际上就是以子区间回溯到根区间，那么对于一个自区间(l,r)它有可能变为$(l-(r-l+1),r) (l-(r-l+2),r) (l,r+r-l+1) (l,r+r-l)$，由于$\frac{L}{R−L+1}≤2×10^3$，所以极限40几次，加上剪枝可以过掉。<br>这里注意第4个转换要特判l!=r否则会陷入循环。另外考场傻了没注意$l-(r-l+1)&lt;0$也要返回，因为如果这个都小于0，那么向左会小于0，而向右后再向左会更小于0 </p><p>上代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">ll l,r,lim;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll l,ll r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==<span class="number">0</span>)&#123;</span><br><span class="line">ans=min(ans,r);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(l&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(r&gt;lim) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(r&gt;ans) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(l-(r-l+<span class="number">1</span>)&lt;<span class="number">0</span>) <span class="keyword">return</span>;<span class="comment">//剪枝要给够，要不然一个二个跑到lim+1那要得a，因为如果这里</span></span><br><span class="line">                       <span class="comment">//不满足，那么像左会小于0，而向右后再向左会更小于0 </span></span><br><span class="line">    dfs(l-(r-l+<span class="number">1</span>),r);<span class="comment">//右子树 </span></span><br><span class="line">    dfs(l-(r-l+<span class="number">2</span>),r);<span class="comment">//右子树 左边比右边多一个 先找到0先约束 </span></span><br><span class="line">dfs(l,r+r-l+<span class="number">1</span>);<span class="comment">//左子树 </span></span><br><span class="line">    <span class="keyword">if</span>(l!=r)dfs(l,r+r-l);<span class="comment">//左子树 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;l,&amp;r,&amp;lim);</span><br><span class="line">ans=lim+<span class="number">1</span>;<span class="comment">//将限制降低 </span></span><br><span class="line"><span class="comment">//if(l==r)&#123;printf("%d\n",l);return;&#125;</span></span><br><span class="line">dfs(l,r);</span><br><span class="line"><span class="keyword">if</span>(ans==lim+<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dfs </tag>
            
            <tag> 剪枝 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>选择难题</title>
      <link href="/2018/10/29/36/"/>
      <url>/2018/10/29/36/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>ZZr经过努力奋斗终于考入了UKP University！</p><p>初来乍到的ZZr很快发现自己的智商水平是远超同学的，于是他选了三门极具难度的数学课：离散数学、数学分析、高等代数。学习数学是一定要通过做练习来提高成绩的，于是ZZr购买了一套奇怪的练习题，这套练习题被分为了p节。每节都有三道难题，分别是关于离散数学、数学分析和高等代数的。第ii节中的三道题的难度分别为$a_i,b_i,c_i$。其中ai表示离散数学对应题目的难度，bi表示数学分析对应题目的难度，ci表示高等代数对应题目的难度，ai,bi,ci都是非负整数。</p><p>然而ZZr毕竟才艺出众，丰富的社团活动让他并没有多少时间做练习，于是他决定只从每节中选且仅选一道题来完成。但ZZr发现自己竟然忙到选择题目的时间都没有，于是他委托作为舍友的你帮他选择。</p><p>经过研究发现，完成这套奇怪的练习题获得的总能力提高度D有一个奇怪的计算方式：总能力提高度为三门学科各自的能力提高度之和，而每门学科的能力提高度为所做的该学科难题中的难度的最大值，如果该学科没有做题，则其能力提高度为0。为了避免被ZZr远远甩下，你决定好好研究一下帮ZZr如何选择题目，使得ZZr能获得的总能力提高度最小，并计算出这个最小值。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>输入的第一行包含一个正整数n，表示这套练习题共有n节。</p><p>接下来共n行，每行包含三个非负整数ai,bi,ci，其含义如上文所述。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>输出包含一个正整数D，表示ZZr能获得的最小总能力提高度。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>3<br>1 2 100<br>1 100 3<br>100 4 5</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>5</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>全部测试点：$n&lt;=10^6,a_i,b_i,c_i&lt;=10^8$。</p><p>时空限制：2s/1GB</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先观察这题数据范围，会发现特别限制$diff(a_i)$，在考场上就想着用$diff(a_i) \ast n$的算法，结果思路是正确的！那么我们发现这道题是一个三元组，不太好搞，所以枚举maxa来限制一维，所以小于等于maxa的三元组就被干掉了。剩下便是二元组，那么对于两个二元组$(b_i,c_i)(b_j,c_j)$如果$b_i&lt;=b_j\&amp;c_i&lt;=c_j$那么前者就是无用的，因为后者将它覆盖，那么我们若将二元组按b_i为第一关键字从小到大排序，就会发现第二维是单减的(要不然它就无用了).</p><p>所以我们可以一边遍历n来找出$min(b_i+c_{i+1})​$即为最佳的maxb和maxc选项，可以想象一下，两侧都比它们小。</p><p>那么这样我们就能达到$diff(a_i) \ast n$的复杂度，但这对于$n=10^6$还远远不够，那么不是O(n)就是$nlog_n$了。那么我们用set来将后面的n尽量降到$log_n$：</p><p>用lower_bound来找到第一个大于等于$b_i$的点，如果$c_i$小于它的话那么i无用，所以不加入，否则向前找无用的删除，再用另一个multiset来维护最小值，要注意细节实现.</p><p>这样的话每个点都最多加入一次，删除一次，所以复杂度是logn的。</p><p>(p.s更新:实际上对minn的维护并不是logn的因为最坏会出现$n^2$个最小值，然而这种上界很不满，所以只会t一个点)</p><p>上代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000006</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(node x,node y)&#123;</span><br><span class="line"><span class="keyword">if</span>(x.a!=y.a) <span class="keyword">return</span> x.a&gt;y.a;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> x.b&lt;y.b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;nd[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">void</span> _scanf(<span class="keyword">int</span> &amp;x)&#123;</span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> c=getchar();</span><br><span class="line"><span class="keyword">while</span>(c&gt;<span class="string">'9'</span>||c&lt;<span class="string">'0'</span>) c=getchar();</span><br><span class="line"><span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+c-<span class="string">'0'</span>;c=getchar();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nd1</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> b,c;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(nd1 x,nd1 y)&#123;</span><br><span class="line"><span class="keyword">if</span>(x.b!=y.b)<span class="keyword">return</span> x.b&lt;y.b;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> x.c&gt;y.c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">set</span>&lt;nd1&gt;s;</span><br><span class="line"><span class="built_in">set</span>&lt;nd1&gt;::iterator it,itt,kk;</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;minn;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">_scanf(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">_scanf(nd[i].a);_scanf(nd[i].b);_scanf(nd[i].c);</span><br><span class="line">&#125;</span><br><span class="line">sort(nd+<span class="number">1</span>,nd+n+<span class="number">1</span>);</span><br><span class="line">s.insert((nd1)&#123;<span class="number">0</span>,inf&#125;);s.insert((nd1)&#123;inf,<span class="number">0</span>&#125;);</span><br><span class="line">minn.insert(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//枚举maxa是多少 </span></span><br><span class="line"> <span class="keyword">if</span>(nd[i].a!=nd[i<span class="number">-1</span>].a) ans=min(ans,nd[i].a+*minn.begin());</span><br><span class="line"> </span><br><span class="line"> nd1 t=(nd1)&#123;nd[i].b,nd[i].c&#125;;</span><br><span class="line"> it=s.lower_bound(t);</span><br><span class="line"> kk=it;it--;</span><br><span class="line"> <span class="comment">//printf("%d %d",it-&gt;b,it-&gt;c);</span></span><br><span class="line"> <span class="keyword">if</span>(nd[i].c&lt;kk-&gt;c) <span class="keyword">continue</span>;<span class="comment">//不要加入 </span></span><br><span class="line"> <span class="keyword">int</span> tmp=nd[i].c,pre=kk-&gt;c;</span><br><span class="line"> <span class="keyword">while</span>(it-&gt;c&lt;tmp)&#123;</span><br><span class="line"> minn.erase(minn.find(pre+it-&gt;b));</span><br><span class="line"> pre=it-&gt;c;</span><br><span class="line"> itt=it;</span><br><span class="line"> it--;</span><br><span class="line"> s.erase(itt);</span><br><span class="line"> &#125;</span><br><span class="line"> minn.erase(minn.find(pre+it-&gt;b));</span><br><span class="line"> s.insert(t);</span><br><span class="line"> minn.insert(it-&gt;b+nd[i].c);</span><br><span class="line"> minn.insert(nd[i].b+kk-&gt;c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在外面判a不选</span></span><br><span class="line">ans=min(ans,*minn.begin());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,ans); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("1.txt","r",stdin);</span></span><br><span class="line"><span class="comment">//freopen("2.txt","w",stdout);</span></span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> noip模拟赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> set </tag>
            
            <tag> 二元组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>squirrel</title>
      <link href="/2018/10/29/35/"/>
      <url>/2018/10/29/35/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>小B在University of Stupid Aliens玩耍时目睹了一群松鼠传话的一幕！</p><p>作为一个杰出的语言学家，小B发现了松鼠传话时有如下规律：有nn只松鼠站在一条直线上，从左到右依次编号为1,2,3,…,n。每只松鼠所说的话可以被看作是一个整数。设编号为ii的松鼠说的话为$s_i$。编号为1,2的松鼠要说的话可以被分别认为是某一常数a的某次幂（即分别为$a^{m_1}和a^{m_2}$）。</p><p>但松鼠们的大脑容量有限，所以在一切计算过程中它们会将所计算的结果取除以某一正整数pp的余数（即modp）。注意，编号为1,21,2的松鼠在计算幂时也会取余数（即$s_1, s_2$分别为$a^{m_1}modp和a^{m_2}modp$）。</p><p>接下来，编号为i(i≥3)的松鼠要说的话是站在它左边的第二只松鼠的话α次方乘左边的第一只松鼠的话β次方。也就是说，有$s_i=s^α_{i−2}⋅s^β_{i−1}modp(i≥3)$。小B对松鼠们传话的方式十分痴迷，他现在已经知道前两只松鼠说话的内容，他想让你告诉他任意一只他指定的松鼠将会说什么。（你可以认为这里的松鼠有足够多只。）</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>输入的第一行包含六个正整数$a,m_1,m_2,α,β,p$。各字母的含义如上文所述。</p><p>第二行包含一个正整数K，表示小B的问题个数。接下来K行每行一个正整数$b_1,b_2,…,b_K$，表示小B想知道编号为$b_i$的松鼠所说的话。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>输出包含K行。每行一个整数，第ii行表示编号为$b_i$的松鼠所说的话。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>2 1 1 1 1 107<br>5<br>2<br>3<br>4<br>5<br>6</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>2<br>4<br>8<br>32<br>42</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>对于全部数据，$a&lt;p&lt;=5∗10^3,K&lt;=10^3$。</p><p>时空限制：1s/512MB</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先给出两个降幂公式:<br>欧拉降幂公式：$a^{x}mod p = a^{x \mod \phi_{p}+\phi_{p} }mod p (x ≥ \phi_{p})$。其中$\phi_{p}$为欧拉函数，其意义是小于等于p且与p互质的数的个数。请注意该公式的成立条件：x≥$\phi_{p}$。</p><p>当p是质数时，该公式可简化为费马小定理：$a^x \mod p = a^{x \mod (p−1) }mod p$。此公式对任意的x均成立，不需要满足x≥p−1。</p><p>首先我们发现p是在5000以内的，那么跑一遍欧拉函数即可。然后分别动用两个公式可以将幂降到很小，然后用快速幂只需几十次就可以计算出。这里给出快速幂非递归写法.<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">ll qkpow(ll k,int pos)&#123;</span><br><span class="line">  ll ans=<span class="number">1</span>,base=k;</span><br><span class="line">  <span class="keyword">while</span>(pos)&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos&amp;<span class="number">1</span>)ans=ans*base%mod;</span><br><span class="line">    base=base*base%mod;</span><br><span class="line">    pos=pos<span class="meta">&gt;&gt;</span><span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发现$b_i$很大，肯定就tm想到循环节，事实上只要m1和m2再次出现就会循环，而由于p&lt;=5000，所以最多有$5000^2$种，所以可以很短时间求出，再一次输出即可，注意细节实现，比如前面的一些q可能还没开始循环，要单独输出比如4 3 7 4 3，对于1的询问就不能再mod。</p><p>上代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> phi[<span class="number">5005</span>];</span><br><span class="line"><span class="keyword">bool</span> isp[<span class="number">5005</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ready</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">   <span class="built_in">memset</span>(isp,<span class="number">1</span>,<span class="keyword">sizeof</span>(isp)); </span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) phi[i]=i; </span><br><span class="line">   isp[<span class="number">0</span>]=isp[<span class="number">1</span>]=<span class="number">0</span> ;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)<span class="keyword">if</span>(isp[i])&#123;</span><br><span class="line">   phi[i]=phi[i]/i*(i<span class="number">-1</span>); </span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>;k*i&lt;=n;k++)</span><br><span class="line">   &#123;</span><br><span class="line">   isp[i*k]=<span class="number">0</span>;</span><br><span class="line">   phi[i*k]=phi[i*k]/i*(i<span class="number">-1</span>); </span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll a,mod,m1,m2,alpha,beita;</span><br><span class="line"><span class="keyword">int</span> k;ll q[<span class="number">1005</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(node a,node b)&#123;</span><br><span class="line"><span class="keyword">if</span>(a.x!=b.x) <span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">ll <span class="title">qkpow</span><span class="params">(ll t,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pos==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(pos==<span class="number">1</span>) <span class="keyword">return</span> t;</span><br><span class="line">ll tt=qkpow(t,pos/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(pos&amp;<span class="number">1</span>) <span class="keyword">return</span> tt*tt%mod*t%mod;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> tt*tt%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> zq,qd;</span><br><span class="line">ll t1,t2;</span><br><span class="line"><span class="built_in">map</span>&lt;node,<span class="keyword">int</span>&gt;mp;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,ll&gt;mpv;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve1</span><span class="params">()</span></span>&#123;<span class="comment">//费马小定理 </span></span><br><span class="line">m1=m1%(mod<span class="number">-1</span>);m2=m2%(mod<span class="number">-1</span>);</span><br><span class="line">alpha=alpha%(mod<span class="number">-1</span>);beita=beita%(mod<span class="number">-1</span>); </span><br><span class="line">t1=qkpow(a,m1);t2=qkpow(a,m2);mpv[<span class="number">1</span>]=t1;</span><br><span class="line"><span class="keyword">int</span> pos=<span class="number">3</span>;<span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">   node t=(node)&#123;m1,m2&#125;;</span><br><span class="line">   <span class="keyword">if</span>(!mp.count(t)) mp[t]=pos<span class="number">-1</span>,mpv[pos<span class="number">-1</span>]=qkpow(a,m2);</span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">   zq=pos<span class="number">-1</span>-mp[t],qd=mp[t]<span class="number">-1</span>;<span class="comment">//哥哥a,眼睛好点吧 </span></span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   ans=(m1*alpha+m2*beita)%(mod<span class="number">-1</span>);</span><br><span class="line">   m1=m2;m2=ans;</span><br><span class="line">   pos++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> px;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;=px) <span class="keyword">return</span> x%px+px;</span><br><span class="line"><span class="keyword">return</span> x; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve2</span><span class="params">()</span></span>&#123;<span class="comment">//欧拉函数 </span></span><br><span class="line">    px=phi[mod];</span><br><span class="line">m1=calc(m1),m2=calc(m2);</span><br><span class="line">alpha=calc(alpha);beita=calc(beita);</span><br><span class="line">t1=qkpow(a,m1);mpv[<span class="number">1</span>]=t1;</span><br><span class="line"><span class="keyword">int</span> pos=<span class="number">3</span>;<span class="keyword">int</span> ans;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">   node t=(node)&#123;m1,m2&#125;;</span><br><span class="line">   <span class="keyword">if</span>(!mp.count(t)) mp[t]=pos<span class="number">-1</span>,mpv[pos<span class="number">-1</span>]=qkpow(a,m2);</span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">   zq=pos<span class="number">-1</span>-mp[t],qd=mp[t]<span class="number">-1</span>;<span class="comment">//哥哥a,眼睛好点吧 </span></span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   ans=calc(m1*alpha+m2*beita);</span><br><span class="line">   m1=m2;m2=ans;</span><br><span class="line">   <span class="comment">//printf("%d %d %lld\n",m1,m2,qkpow(a,m2));</span></span><br><span class="line">   pos++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld%lld%lld"</span>,&amp;a,&amp;m1,&amp;m2,&amp;alpha,&amp;beita,&amp;mod);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;q[i]);</span><br><span class="line"><span class="keyword">if</span>(isp[mod]) solve1();</span><br><span class="line"><span class="keyword">else</span> solve2();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(q[i]&gt;=qd)&#123;</span><br><span class="line">  <span class="keyword">int</span> kk=(q[i]-qd+<span class="number">1</span>)%zq;</span><br><span class="line">  <span class="keyword">if</span>(kk==<span class="number">0</span>) kk=zq;</span><br><span class="line">  kk=qd+kk<span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,mpv[kk]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,mpv[q[i]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("squirrel.in","r",stdin);</span></span><br><span class="line"><span class="comment">//freopen("squirrel.out","w",stdout);</span></span><br><span class="line">ready(<span class="number">5000</span>);</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> noip模拟赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 欧拉函数 </tag>
            
            <tag> 费马小定理 </tag>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>密码锁</title>
      <link href="/2018/10/29/34/"/>
      <url>/2018/10/29/34/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>小M有一把密码锁，由NN个开关组成。</p><p>一开始的时候，所有开关都是关上的。当且仅当其中指定的K个开关：$x_1,x_2,x_3,…,x_k$为开，其他开关为关时，密码锁才会打开。 你可以进行SS种的操作，每种操作有一个参数$size_i$，表示假如你选择了第i种的操作的话，你可以任意选择连续的$size_i$个开关，把它们全部取反（原来是开的变为关，原来是关的变为开）。</p><p>你的任务很简单，帮助小M计算最少需要多少步才能打开密码锁，或者如果无解的话，请输出−1。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>输入的第一行有三个正整数N,K,S，他们的意义如题目所述。 第二行有K个正整数，表示开关$x_1,x_2,x_3,…,x_k$必须为开，保证$x_i$两两不同。 第三行有S个正整数，其中第ii个表示$size_i$，可能有重复的$size_i$可能有重复。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>输出文件仅一行一个整数，表示答案。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>10 8 2<br>1 2 3 5 6 7 8 9<br>3 5</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>2</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>对于50%的数据，1≤N≤20，1≤K≤5，1≤S≤3；</p><p>对于另外20%的数据，1≤N≤10000，1≤K≤5，1≤S≤30；</p><p>对于100%的数据，1≤N≤10000，1≤K≤10，1≤S≤100。</p><p>时空限制：1s/512MB</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先会注意到这题的数据范围，前50%用撞鸭dp就可以过但要注意群体异或避免逐个修改。(考试时真的傻了)即$(1&lt;&lt;sz_i)&lt;&lt;j$这样可以刚好异或一段。</p><p>其次观察到k最大只有10，那么撞鸭上限是20，随后又会想到这里每覆盖一段实际上是加1，而又要mod2，发现是个01差分。那我们先将其中要开的开关在段中绘好，那么最终就是要将其变为全0.将其转化为差分数组，最多就会有20个1，每赋一段l,r，会在l处+1,r+1处+1，相当于将l处的1转化到r+1,若r+1也为1就消为了0，实际上我们将所有1匹配即可。然后可以bfs记录一遍dist{i,j}，只需要O(n)跑。最后用一个撞鸭dp来记录所有点全部匹配的最小步数即可。</p><p>注意这里裸的dp是$总状态数\ast(2\ast k)^2$，所以我们先固定一个新增加的元素，然后枚举与它匹配的元素来达到最小，从而变成了$总状态数\ast2\ast k$.</p><p>上代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxk 10005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxs 10005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,s,x[maxk],sz[maxs];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> e[<span class="number">35</span>][<span class="number">35</span>];</span><br><span class="line"><span class="keyword">int</span> dist[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> pos[maxn],np=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dist));</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">q.push(s);</span><br><span class="line">dist[s]=<span class="number">0</span>;vis[s]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> t=q.front();q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> tt=t+sz[i];</span><br><span class="line"><span class="keyword">if</span>(tt&lt;=n+<span class="number">1</span>&amp;&amp;!vis[tt])&#123;</span><br><span class="line">dist[tt]=dist[t]+<span class="number">1</span>;</span><br><span class="line">vis[tt]=<span class="number">1</span>;</span><br><span class="line">q.push(tt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> tt=t-sz[i];</span><br><span class="line"><span class="keyword">if</span>(tt&gt;=<span class="number">1</span>&amp;&amp;!vis[tt])&#123;</span><br><span class="line">vis[tt]=<span class="number">1</span>;</span><br><span class="line">dist[tt]=dist[t]+<span class="number">1</span>;</span><br><span class="line">q.push(tt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!a[i]) <span class="keyword">continue</span>;</span><br><span class="line">e[pos[s]][pos[i]]=dist[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1</span>&lt;&lt;<span class="number">22</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;k,&amp;s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x[i]),a[x[i]]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;sz[i]);</span><br><span class="line">sort(sz+<span class="number">1</span>,sz+s+<span class="number">1</span>);s=unique(sz+<span class="number">1</span>,sz+s+<span class="number">1</span>)-sz<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>;i&gt;=<span class="number">1</span>;i--) a[i]^=a[i<span class="number">-1</span>];<span class="comment">//不会影响前面 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++) <span class="keyword">if</span>(a[i]) pos[i]=++np;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++) <span class="keyword">if</span>(a[i]) bfs(i);</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> all=(<span class="number">1</span>&lt;&lt;np)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=all;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> pre=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=np;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!(i&amp;(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))))<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(pre==<span class="number">-1</span>) pre=j;</span><br><span class="line"><span class="keyword">else</span> dp[i]=min(dp[i],dp[i-(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))-(<span class="number">1</span>&lt;&lt;(pre<span class="number">-1</span>))]+e[j][pre]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dp[all]==<span class="number">0x3f3f3f3f</span>) <span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d"</span>,dp[all]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> noip模拟赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 差分 </tag>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>逃脱</title>
      <link href="/2018/10/28/33/"/>
      <url>/2018/10/28/33/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>小 M 的宠物猫 CC 昨天干了背叛主人的事，于是她逃到一个远方的迷<br>宫躲藏了起来。<br>这个迷宫包含 N（用 1..N 编号） 个路口和 N-1 条连接两个路口的双向<br>隧道。 所以每两个路口之间都有唯一的路径。每个只与一条隧道相连的路<br>口都是迷宫的出口。<br>小 M 非常生气， 决定派出一些小狗从不同的出口出发尝试抓住 CC。 小<br>狗和 CC 的移动速度相同（在每个单位时间内，每个小狗都可以从一个路口<br>移动到相邻的一个路口，同时 CC 也可以这么做，当然他们在任意单位时间<br>都可以不移动，停留在原来的路口上）。 小狗们和 CC 总是知道对方在哪里。<br>如果在任意时刻，某个小狗和 CC 处于同一个路口或在穿过同一个隧道， 小<br>狗就可以抓住 CC。反过来，如果 CC 在小狗们抓住她之前到达一个出口， 于<br>是 CC 就逃脱了。<br>CC 不确定她能否成功逃脱，这取决于小狗的数量。给定 CC 当前所在的<br>路口 S，帮助小 M 确定为了抓住 CC 所需要的小狗的最小数量。假定小狗们<br>会自己选择最佳的方案来安排他们出发的出口。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>输入的第一行包含 N 和 S，分别表示路口数目和 CC 当前所在路口的编<br>号。接下来的 N–1 行，每行有两个整数（在 1~N 范围内）描述连接两个路<br>口的一条隧道。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>输出为了确保抓住 CC 所需的小狗的最小数量</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>7 1<br>1 2<br>1 3<br>3 4<br>3 5<br>4 6<br>5 7</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>3</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>对于 20%的数据： N≤3 00<br>对于 50%的数据： N≤5 000<br>对于 100%的数据： N≤100 000</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先对于起点即为出口的特判，当且仅当起点只有一个儿子，这时只需一只狗即可。<br>然后发现最坏情况是每个叶子节点都要一只狗，但狗可以跑过去拦截，所以将顶点与叶子节点路程割半，然后可以颜色染上下半段部分（使用树上倍增精准定位）当发现遍历到染过的时可以减1（用这次染色代替那次）如此下来便最优。<br>而由于是触碰返回，所以复杂度实际上是O（n）的。</p><p>上代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005 </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eage</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,next;</span><br><span class="line">&#125;e[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> np=<span class="number">0</span>,first[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">e[++np]=(eage)&#123;v,first[u]&#125;;</span><br><span class="line">first[u]=np; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,s,x,y,dep[maxn],fa[maxn][<span class="number">18</span>];</span><br><span class="line"><span class="keyword">int</span> st[maxn],top=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> ok=<span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> f,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">     dep[i]=d;fa[i][<span class="number">0</span>]=f;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">17</span>;j++) fa[i][j]=fa[fa[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line"> <span class="keyword">int</span> chd=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> p=first[i];p;p=e[p].next)&#123;</span><br><span class="line"> <span class="keyword">int</span> j=e[p].to;</span><br><span class="line"> <span class="keyword">if</span>(j==f) <span class="keyword">continue</span>;</span><br><span class="line"> chd++;</span><br><span class="line"> dfs(j,i,d+<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>(i==s&amp;&amp;chd==<span class="number">1</span>) ok=<span class="literal">true</span>;</span><br><span class="line"> <span class="keyword">if</span>(chd==<span class="number">0</span>) st[++top]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*int lca(int u,int v)&#123;</span></span><br><span class="line"><span class="comment">if(dep[u]&lt;dep[v]) swap(u,v);</span></span><br><span class="line"><span class="comment">int x=dep[u]-dep[v];</span></span><br><span class="line"><span class="comment">for(int i=0;i&lt;=17;i++)&#123;</span></span><br><span class="line"><span class="comment">if((1&lt;&lt;i)&amp;x) u=fa[u][i];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">if(u==v) return u;</span></span><br><span class="line"><span class="comment">for(int i=17;i&gt;=0;i--)&#123;</span></span><br><span class="line"><span class="comment">if(fa[u][i]!=fa[v][i]) </span></span><br><span class="line"><span class="comment">u=fa[u][i],v=fa[v][i];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">return fa[u][0];</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">bool</span> color[maxn];</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfss</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(color[i])&#123;ans--;<span class="keyword">return</span>;&#125;</span><br><span class="line">color[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> p=first[i];p;p=e[p].next)&#123;</span><br><span class="line"><span class="keyword">int</span> j=e[p].to;</span><br><span class="line"><span class="keyword">if</span>(j==fa[i][<span class="number">0</span>])<span class="keyword">continue</span>;</span><br><span class="line">dfss(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">add(x,y);add(y,x);</span><br><span class="line">&#125;</span><br><span class="line">dfs(s,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(ok==<span class="literal">true</span>) <span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=top;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> x=dep[st[i]]-dep[s];</span><br><span class="line">    x=x/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> u=st[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">17</span>;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&amp;(<span class="number">1</span>&lt;&lt;j)) u=fa[u][j];</span><br><span class="line">&#125;</span><br><span class="line">ans++;</span><br><span class="line">dfss(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;<span class="comment">//实际复杂度只要O(n) 因为触碰返回 </span></span><br><span class="line"><span class="comment">//freopen("escaping.in","r",stdin);</span></span><br><span class="line"><span class="comment">//freopen("escaping.out","w",stdout);</span></span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> noip模拟赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dfs </tag>
            
            <tag> 树上倍增 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>红绿灯</title>
      <link href="/2018/10/25/32/"/>
      <url>/2018/10/25/32/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>小R最近感觉很不开心，所以他打算去炸了一所和他距离906.5公里的高中。</p><p>现在小R打算出发前往他的目的地，和他的方案有关的交通网可以抽象为一张nn个点mm条无向边的无向图，小R要从1号点到达nn号点。现在经过事先的资料收集，小R已经拿到了这张无向图：第ii条边连接着uiui和vivi，长度为didi。</p><p>小R根据这些资料，很快便规划出了最短路径，然而很快，小R便发现他忽略一个至关重要的东西：红绿灯。</p><p>为了简化为题，我们假定每一条边上都有一个红绿灯，每一个红绿灯都可以用ki,li,riki,li,ri来定义，即只有在时刻数模kiki的值在区间[li,ri][li,ri]的时刻，小R才能在这条边上移动（每一时刻小R能前进1单位长度）。</p><p>举个例子，现在有一条长度为7的边，小R到达它其中一个端点的时刻是3，k=3,l=1,r=2k=3,l=1,r=2，小R想要通过这条边。首先他等到了时刻4，然后再这条边上前进了2单位长度，然后他又必须停下1单位时间，然后再前进两个单位…最终小R到达另一个端点的时刻为14。</p><p>现在小R打算知道从1到这张图的每一个顶点最少要花多少时间，你可以告诉他吗？（假设小R在第0时刻出发）</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行输入两个整数n,m。</p><p>接下来m行每行6个整数$u_i,v_i,d_i,k_i,l_i,r_i$描述了一条边。保证存在一种方案可以在有限的时间内到达每一个节点。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>输出n行，第i行表示到达第i个点的最少时间。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>3 2<br>1 2 3 3 0 2<br>2 3 7 3 1 2</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>0<br>3<br>14</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>对于100%的数据，$n≤5\times10^5,m≤10^6,0≤l_i≤r_i&lt;k_i≤20,1≤d≤106$<br>时间限制： 3s<br>空间限制： 512MB</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>因为每天边权都是正的，先到等红绿灯总不比后到更差，所以可以跑一遍dij，主要处理一下每条边的耗费时间，注意细节。p.s.代码中计算长度时有小技巧，巧妙的避免了求刚好走完时的多走的路程，而将其转化为和其他一样的最后走一段l+len，<del>妙a</del>。（这种减1的小技巧在其他题也适用）</p><p>上代码:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxm 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eage</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,next;ll len;<span class="keyword">int</span> k,l,r;</span><br><span class="line">&#125;e[maxm&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> np=<span class="number">0</span>,first[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,ll len,<span class="keyword">int</span> k,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">e[++np]=(eage)&#123;v,first[u],len,k,l,r&#125;;</span><br><span class="line">first[u]=np;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m,x,y,a1,a2,a3;ll z;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">ll v;<span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(node a,node b)&#123;</span><br><span class="line"><span class="keyword">return</span> a.v&gt;b.v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt;q;</span><br><span class="line">ll dist[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> l,<span class="keyword">int</span> r,ll len,ll now)</span></span>&#123;</span><br><span class="line">ll dis=<span class="number">0</span>;</span><br><span class="line">now=now%k;</span><br><span class="line"><span class="keyword">if</span>(now&lt;l) dis+=(l-now),now=l; </span><br><span class="line"><span class="keyword">if</span>(now&lt;=r)&#123;</span><br><span class="line"><span class="keyword">int</span> mv=r-now+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(mv&gt;=len) <span class="keyword">return</span> len+dis;<span class="comment">//直接走达 </span></span><br><span class="line">dis+=mv;</span><br><span class="line">len-=mv;now=r+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(now!=k)&#123;</span><br><span class="line">dis+=k-now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> d=r-l+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> cnt=(len<span class="number">-1</span>)/d;</span><br><span class="line">len=(len<span class="number">-1</span>)%d+<span class="number">1</span>;</span><br><span class="line">dis+=(ll)<span class="number">1l</span>l*cnt*k;</span><br><span class="line">dis+=(l+len);</span><br><span class="line"><span class="keyword">return</span> dis;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dist));</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">q.push((node)&#123;dist[<span class="number">1</span>],<span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">node t=q.top();q.pop();</span><br><span class="line"><span class="keyword">int</span> i=t.id;</span><br><span class="line"><span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">vis[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> p=first[i];p;p=e[p].next)&#123;</span><br><span class="line"><span class="keyword">int</span> j=e[p].to;</span><br><span class="line">ll dis=calc(e[p].k,e[p].l,e[p].r,e[p].len,t.v); </span><br><span class="line">    <span class="keyword">if</span>(dist[j]&gt;dis+dist[i])&#123;</span><br><span class="line">    dist[j]=dis+dist[i];</span><br><span class="line">    q.push((node)&#123;dist[j],j&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%lld%d%d%d"</span>,&amp;x,&amp;y,&amp;z,&amp;a1,&amp;a2,&amp;a3);</span><br><span class="line">add(x,y,z,a1,a2,a3);</span><br><span class="line">add(y,x,z,a1,a2,a3);</span><br><span class="line">&#125;</span><br><span class="line">dij();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,dist[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dijsktra </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>祎隋</title>
      <link href="/2018/10/24/31/"/>
      <url>/2018/10/24/31/</url>
      
        <content type="html"><![CDATA[<font size="5" color="pink">相框里的那些闪闪发光的我们啊</font><font size="5" color="pink">在夏天发生的事，你忘了吗</font><p>多年之后，他是否还走在这条路上<br>想起那欲擒故纵实是欲纵故擒<br>….<br>忙里偷闲<br>你恬然一笑<br>使时间一止<br>阳光下，被放大的灰尘<br>光阴里，被遗忘的我们</p><p><img src="https://i.loli.net/2018/11/06/5be1a2b871089.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 杂诗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂诗 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>序列</title>
      <link href="/2018/10/24/30/"/>
      <url>/2018/10/24/30/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>你有一个长度为nn的序列$a_1,a_2,…,a_n$，你可以选择一段区间(l,r) (1≤l≤r≤n)，并且把$a_l,a_l+1,…,a_r$这些数字加上一个相同的数字d(−x≤d≤x)。</p><p>你想让加完之后的数字的最长上升子序列尽量长。也就是说找到最大的k满足$t_1&lt;t_2&lt;⋯&lt;t_k$，且$a_{t1}&lt;a_{t2}&lt;⋯&lt;a_{tk}$。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行两个整数n,x，接下来一行n个正整数$a_1,a_2,…,a_n$。</p><p>注意：你可以把数字改成负数。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>输出一个整数，表示答案，即最长的LIS长度。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>7 5<br>7 3 5 2 7 3 4</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>5</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>对于 100% 的数据，有$1≤n≤200000,0≤x≤109,1≤a_i≤10^9$。<br>时间限制：2s<br>空间限制：512MB</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先我们对于要选择的区间l,r考虑，发现以l为起点开始增加，肯定要包含其后的最长上升序列，然后再尽可能贪心的增加最大，使前面有更多满足的。所以我们对于每一个i统计一下它加上x后前面最长的LIS和后面最长的LIS，这样依次取最大就好。</p><p>然后对于求LIS，用二分查找和贪心nlogn求，反向求下降也是一样的，只要理解本质。<br>tips:注意lower_bound和upper_bound两个求&gt;=和&gt;，前者是用于严格上升子序列，而后者是非严格，可以想象一下。举个栗子:3 4 6 现在加入4，如果严格为2，否则为3.</p><p>上代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[maxn],hm[maxn],x;</span><br><span class="line"><span class="keyword">int</span> st[maxn],top=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;x);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">int</span> t=lower_bound(st+<span class="number">1</span>,st+top+<span class="number">1</span>,a[i],cmp)-st;</span><br><span class="line">    <span class="keyword">if</span>(t&gt;top) st[++top]=a[i];<span class="keyword">else</span> st[t]=a[i];<span class="comment">//贪心</span></span><br><span class="line">hm[i]=t; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">top=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> t=lower_bound(st+<span class="number">1</span>,st+top+<span class="number">1</span>,a[i]+x)-st;</span><br><span class="line">    ans=max(ans,t+hm[i]<span class="number">-1</span>);</span><br><span class="line">    t=lower_bound(st+<span class="number">1</span>,st+top+<span class="number">1</span>,a[i])-st;</span><br><span class="line">    <span class="keyword">if</span>(t&gt;top) st[++top]=a[i];<span class="keyword">else</span> st[t]=a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> LIS </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>彩虹糖</title>
      <link href="/2018/10/24/29/"/>
      <url>/2018/10/24/29/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>有1~m之间的整数，A有$tot_a$个，B有$tot_b$个，不会有两个相同的数字出现。有n堆数字，从A开始操作，它能对一堆彩虹糖进行操作当且仅当它有这个数字，并将其分为新的两堆非空的数字。两人都使用最优策略，当一人无法操作时另一人获胜。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>n,m<br>$tot_a$<br>$a_i$<br>$tot_b$<br>$b_i$<br>$p_i$</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>一行表示游戏结果，A胜输出”Pomegranate”,B胜输出”Orange”.</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>$n&lt;=10^6,m&lt;=10^4$</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先，我们要探究性质，了解到每一堆先选后选无关系，因为总会按最优策略一样分解产生相同贡献。然后我们设f(x)表示x这堆对先手造成多走的贡献，那么A肯定想要最大化f(i)，而B则想要最小化f(i)，而恰好这里的每个拥有的数都是唯一的，所以很好处理<del>(抽空了解一下博弈论的SG函数和超现实数，如果这里数会重貌似就要超现实数？？？)</del>.这里的f(i)是拥有可加性的，分解嘛。<br>对于每个A拥有的f(i):<br>$f_i=max(f_i,f_j+f_{i-j}+1)$<br>对于每个B拥有的f(i):<br>$f_i=min(f_i,f_j+f_{i-j}-1)$</p><p>这样对于每一个$p_i$我们将贡献加起来如果最终&lt;=0就B赢，否则A赢，A先走嘛</p><p>上代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxm 10005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,tota,totb,a[maxm],b[maxm],p[maxn];</span><br><span class="line"><span class="keyword">int</span> visa[maxm],f[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tota);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tota;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">visa[a[i]]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;totb);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=totb;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;b[i]);</span><br><span class="line">visa[b[i]]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!visa[i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(visa[i]==<span class="number">1</span>) f[i]=max(f[i],f[i-j]+f[j]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> f[i]=min(f[i],f[i-j]+f[j]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(p[i]&gt;m) <span class="keyword">continue</span>;</span><br><span class="line">ans+=f[p[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans&lt;=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"Orange"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Pomegranate"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
            <tag> 博弈论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分解</title>
      <link href="/2018/10/24/28/"/>
      <url>/2018/10/24/28/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>你有一个数字n，你想把它表达成若干个数字加一的乘积，也就是$n=(x_1+1)∗(x_2+1)∗⋯∗(x_k+1)$。</p><p>问$x_1+x_2+⋯+x_k$有多少种不同的取值。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>一个整数n</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>第一行输出一个整数表示不同取值个数。</p><p>第二行输出若干个用空格隔开的整数，表示不同的取值，从小到大输出。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>12</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>4<br>4 5 6 11</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>对于 100% 的数据，有 $1≤n≤10^9$。<br>时间限制：2s<br>空间限制：512MB</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>不难想到可以爆搜将x不断分解，当然爆搜也有巧妙性，看一下这段代码及注释：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> x,<span class="keyword">int</span> ss)</span></span>&#123;</span><br><span class="line">s.insert(now+ss<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=x;i*i&lt;=now;i++)&#123;<span class="comment">//x使不重复枚举</span></span><br><span class="line"><span class="keyword">if</span>(now%i==<span class="number">0</span>) dfs(now/i,i,ss+i<span class="number">-1</span>);<span class="comment">//ss+i-1使后者的i在统计时先被减过1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">dfs(n,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,s.size());</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=s.begin();it!=s.end();it++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,*it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> set </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>棒棒糖</title>
      <link href="/2018/10/24/27/"/>
      <url>/2018/10/24/27/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>相对于正常求LCA的步骤不同，这里求LCA时$dep_v=dep_u+random(0,1)$（u为v的父亲），然后给你一棵树和m个询问，每组询问两个数x,y，请求出这组询问的LCA求对的概率。<br>对于所有概率要对998244353取模后输出.</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>$1&lt;=n,m&lt;=2 \times 10^5$</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>其实画个图想一下还是挺简单的，对于一组x,y，若y为x祖先，那么他俩之间的dep不能变，所以方案数为$2^{n-1-mv}$mv表示它们的dep差，而$ans=\frac{2^{n-1-mv}}{2^{n-1}}$。</p><p>然后对于其它情况，假设dep大的为x，另者为y，那么只要它们的深度相对相同变化即可，因为dep只会变少，它们最终或许不能立即到最近公共祖先，但最后会升到同一高度，然后往上即可,<br>设x,y到祖先的距离分别为$l_1,l_2$（l1&gt;l2），所以方案数为$\sum_{i=0}^{l_2}C_{l_1}^i \times C_{l_2}^i$再乘上$2^{n-1-mv}$.那么这里强行计算肯定是要T的，可以引用一个组合数公式：</p><p> $\sum_{i=0}^{m}C_{n}^i \times C_{m}^{m-i} = C_{m+n}^m$ (n&gt;=m)</p><p>可以变形成$\sum_{i=0}^{m}C_{n}^i \times C_{m}^{i} = C_{m+n}^m$ (n&gt;=m)</p><p>然后代入本题将那坨组合数变为$C_{l_1+l_2}^{l_1}$。然后O(n)预处理，O(1)就可以求出。</p><p>上代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,x,y;</span><br><span class="line">ll w[maxn],jc[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">0</span>)&#123;x=<span class="number">1</span>;y=<span class="number">0</span>;<span class="keyword">return</span> a;&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ll g=exgcd(b,a%b,x,y);</span><br><span class="line">ll t=x;</span><br><span class="line">x=y;</span><br><span class="line">y=t-a/b*y;</span><br><span class="line"><span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">niy</span><span class="params">(ll k)</span></span>&#123;</span><br><span class="line">ll a=k,b=-mod,x,y;</span><br><span class="line">ll g=exgcd(a,b,x,y);</span><br><span class="line">ll x0=<span class="number">1</span>/g*x;</span><br><span class="line">ll t=b/g;</span><br><span class="line"><span class="keyword">if</span>(t&lt;<span class="number">0</span>) t=-t;</span><br><span class="line">ll ans=(x0%t+t)%t;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span></span>&#123;</span><br><span class="line">w[<span class="number">0</span>]=<span class="number">1l</span>l;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxn<span class="number">-5</span>;i++) w[i]=w[i<span class="number">-1</span>]*<span class="number">2l</span>l%mod;</span><br><span class="line">jc[<span class="number">0</span>]=<span class="number">1l</span>l;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=<span class="number">400000</span>;i++) jc[i]=jc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eage</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next; </span><br><span class="line">&#125;e[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> np=<span class="number">0</span>,first[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">e[++np]=(eage)&#123;v,first[u]&#125;;</span><br><span class="line">first[u]=np;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> dep[maxn],fa[maxn][<span class="number">19</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> f,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">dep[i]=d;</span><br><span class="line">fa[i][<span class="number">0</span>]=f;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">18</span>;j++) fa[i][j]=fa[fa[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> p=first[i];p;p=e[p].next)&#123;</span><br><span class="line"><span class="keyword">int</span> j=e[p].to;</span><br><span class="line"><span class="keyword">if</span>(j==f) <span class="keyword">continue</span>;</span><br><span class="line">dfs(j,i,d+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&lt;dep[v]) swap(u,v);</span><br><span class="line"><span class="keyword">int</span> x=dep[u]-dep[v];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">18</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&amp;x) u=fa[u][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(u==v) <span class="keyword">return</span> u;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">18</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(fa[u][i]!=fa[v][i])</span><br><span class="line">u=fa[u][i],v=fa[v][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fa[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">add(x,y);add(y,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">dfs(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">ll t=w[n<span class="number">-1</span>];</span><br><span class="line">ll inv=niy(t);<span class="comment">//分母 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="keyword">if</span>(dep[x]&lt;dep[y]) swap(x,y);</span><br><span class="line"><span class="keyword">int</span> z=lca(x,y);</span><br><span class="line"><span class="keyword">if</span>(z==y)&#123;</span><br><span class="line">ll k=dep[x]-dep[y];</span><br><span class="line">k=n<span class="number">-1</span>-k;</span><br><span class="line">ll kk=w[k];</span><br><span class="line">    ll ans=kk*inv%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ll k=dep[x]+dep[y]<span class="number">-2</span>*dep[z];</span><br><span class="line">k=n<span class="number">-1</span>-k;</span><br><span class="line">ll t1=w[k];<span class="comment">//后项 </span></span><br><span class="line"><span class="keyword">int</span> l1=dep[x]-dep[z],l2=dep[y]-dep[z];</span><br><span class="line">ll fz=jc[l1+l2],fm=jc[l1]*jc[l2]%mod;</span><br><span class="line">ll niyy=niy(fm);</span><br><span class="line">ll ans1=fz*niyy%mod;</span><br><span class="line">ans1=ans1*t1%mod;</span><br><span class="line">ans1=ans1*inv%mod;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ready();</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> LCA </tag>
            
            <tag> 逆元 </tag>
            
            <tag> 扩展欧几里得 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>重排</title>
      <link href="/2018/10/23/26/"/>
      <url>/2018/10/23/26/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>你拿到了一串可以拯救世界的数，不过这串数字被重新排列过了，你想要把它恢复到原始的样子。</p><p>你现在知道两个很大的数 A 和 B，他们都没有前导0。其中，A是拯救世界的数（也没有前导0）重排后的一个数。拯救世界的数虽然很大，但是也不会超过数 B。现在你想恢复拯救世界的数，求不超过 B 的最大的一个由 A 重新排列的数是什么。</p><p>注意，重新排列指的是 A 的数位重新排列，比如123可以重排成321，并且要保证重排后没有前导0。答案保证有解。</p><p>Input</p><p>第一行一个整数 TT 表示数据组数。</p><p>后面2T行，第2i行表示第i个点的数 A，第2i+1行表示第i个点的数 B。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>共 T行，每行一个数表示答案。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>3<br>1<br>2<br>123<br>123<br>123<br>300</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>1<br>123<br>231</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>对于20%的数据，数 A、B的位数 ≤10。</p><p>对于另外30%的数据，数 A、B的位数 ≤18。</p><p>对于另外10%的数据，数 B 除了第一位非零，其他位都是零。</p><p>对于另外10%的数据，数 A、B的位数 ≤100。</p><p>对于100%的数据，数 A、B的位数≤500，T≤5。</p><p>时间限制：2s<br>空间限制：512MB</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先看A，B的长度，若$len_a&lt;len_b$，那肯定a重排后比b小，所以我们贪心从大到小排后输出。<br>而如果相等，那么我们对于每一位都去枚举它跟谁交换，直到刚好满足小于等于B，当然这里是排了序从大到小枚举的，这样暴力是能过的但是较慢。</p><p>上代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 505</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> a[maxn],b[maxn];</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">char</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;=t;p++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,a+<span class="number">1</span>,b+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> len=<span class="built_in">strlen</span>(a+<span class="number">1</span>),len2=<span class="built_in">strlen</span>(b+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(len&lt;len2)&#123;</span><br><span class="line">sort(a+<span class="number">1</span>,a+len+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,a+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=len;j&gt;=i;j--)&#123;<span class="comment">//枚举每位交换并保证刚刚最大 </span></span><br><span class="line">sort(a+i,a+len+<span class="number">1</span>);</span><br><span class="line">swap(a[i],a[j]);</span><br><span class="line">sort(a+i+<span class="number">1</span>,a+len+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(b+<span class="number">1</span>,a+<span class="number">1</span>)&gt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,a+<span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后是比较快的做法：</p><h4 id="tips-这道题跟以前一道Igra思路相似，先贪心枚举当前选什么，再判断剩下最优能否满足"><a href="#tips-这道题跟以前一道Igra思路相似，先贪心枚举当前选什么，再判断剩下最优能否满足" class="headerlink" title="tips:这道题跟以前一道Igra思路相似，先贪心枚举当前选什么，再判断剩下最优能否满足"></a>tips:这道题跟以前一道Igra思路相似，先贪心枚举当前选什么，再判断剩下最优能否满足</h4><p>对于每一位从大到小枚举，若前面已经小于就不必再判，否则判当前选后剩下最优状态能否满足。按题意模拟即可….</p><p>上代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 505</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">12</span>];</span><br><span class="line"><span class="keyword">char</span> s[maxn],ss[maxn];</span><br><span class="line"><span class="keyword">int</span> ans[maxn],len1,len2;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">char</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">cnt[j]--;</span><br><span class="line"><span class="keyword">int</span> pos=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">9</span>;k++) <span class="keyword">for</span>(<span class="keyword">int</span> kk=<span class="number">1</span>;kk&lt;=cnt[k];kk++) ans[++pos]=k;</span><br><span class="line">cnt[j]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;=len1;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(ss[k]-<span class="string">'0'</span>&gt;ans[k]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(ss[k]-<span class="string">'0'</span>&lt;ans[k]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,s+<span class="number">1</span>,ss+<span class="number">1</span>);</span><br><span class="line">len1=<span class="built_in">strlen</span>(s+<span class="number">1</span>),len2=<span class="built_in">strlen</span>(ss+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len1;i++) cnt[s[i]-<span class="string">'0'</span>]++;</span><br><span class="line"><span class="keyword">if</span>(len1&lt;len2)&#123;</span><br><span class="line">sort(s+<span class="number">1</span>,s+len1+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,s+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">bool</span> same=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len1;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">9</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line"><span class="keyword">if</span>(!cnt[j]||same&amp;&amp;j&gt;ss[i]-<span class="string">'0'</span>) <span class="keyword">continue</span>;</span><br><span class="line">same=(same&amp;(j==ss[i]-<span class="string">'0'</span>));</span><br><span class="line"><span class="keyword">if</span>(same&amp;&amp;!check(i,j)) <span class="keyword">continue</span>;</span><br><span class="line">cnt[j]--;</span><br><span class="line">ans[i]=j;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len1;i++) <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">    init(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>翻转</title>
      <link href="/2018/10/23/25/"/>
      <url>/2018/10/23/25/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>小c有两个长为n的01串A和B。<br>她可以进行下列3种操作，按任意顺序：<br>1.把A循环左移一位<br>2.把A循环右移一位<br>3.选择一个$B_i$=1的i，翻转$A_i$（令$A_i=1-A_i$）<br>求让A串变得和B串相等需要的最少步数。无解输出-1。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>1010<br>1100</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>3</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>1&lt;=n&lt;=2000</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>emmmmmmmm这道题首先判无解情况，即B全为0而A不全为0。</p><p>然后看到2000的数据，O(N)枚举一波最终的位置。然后对于每一个与$B_i$不等的$A_i$看它是往左移还是右移再移回，然后贪心取最大的，边移边翻转，最后ans=变化个数+移动个数+（最大左移+最大右移）$\times$2.注意小于等于移动个数且同向的就不必计入了…移动过程中就换了，详见代码注释。</p><p>这样加上排序复杂度为$n^2logn$，完全能过2333</p><p>上代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> s[maxn],ss[maxn];</span><br><span class="line"><span class="keyword">int</span> n,lm[maxn],rm[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(node a,node b)&#123;</span><br><span class="line"><span class="keyword">return</span> a.l&lt;b.l;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> now=i;</span><br><span class="line"><span class="keyword">while</span>(ss[now]!=<span class="string">'1'</span>) rm[i]++,now=(now+<span class="number">1</span>)%n;</span><br><span class="line">now=i;</span><br><span class="line"><span class="keyword">while</span>(ss[now]!=<span class="string">'1'</span>) lm[i]++,now=(now<span class="number">-1</span>+n)%n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,s,ss);</span><br><span class="line">n=<span class="built_in">strlen</span>(s);                   </span><br><span class="line"><span class="keyword">bool</span> ok1=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(s[i]==<span class="string">'1'</span>)&#123;ok1=<span class="literal">true</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">bool</span> ok2=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(ss[i]==<span class="string">'1'</span>)&#123;ok2=<span class="literal">false</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(ok1&amp;&amp;ok2)&#123;<span class="built_in">printf</span>(<span class="string">"-1"</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line">ready();</span><br><span class="line"><span class="keyword">int</span> cnt,maxx;<span class="keyword">int</span> ans=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> move=-n+<span class="number">1</span>;move&lt;=n<span class="number">-1</span>;move++)&#123;<span class="comment">//左移n-1次，右移n-1次 </span></span><br><span class="line">        <span class="keyword">int</span> maxx=<span class="built_in">abs</span>(move);cnt=<span class="number">0</span>;<span class="comment">//统计要修改的步数</span></span><br><span class="line">        q.clear();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i]==ss[(i+move+n)%n]) <span class="keyword">continue</span>;</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">if</span>(move&lt;=<span class="number">0</span>&amp;&amp;lm[i]&lt;=maxx) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(move&gt;=<span class="number">0</span>&amp;&amp;rm[i]&lt;=maxx) <span class="keyword">continue</span>;<span class="comment">//途中移动翻转</span></span><br><span class="line">q.push_back((node)&#123;lm[i],rm[i]&#125;); </span><br><span class="line">&#125;</span><br><span class="line">sort(q.begin(),q.end());</span><br><span class="line"><span class="keyword">int</span> maxy=<span class="number">0</span>,minn=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=q.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">minn=min(minn,q[i].l+maxy);</span><br><span class="line">maxy=max(maxy,q[i].r);<span class="comment">//后一步更新，使覆盖完 </span></span><br><span class="line">&#125;  </span><br><span class="line">minn=min(minn,maxy);<span class="comment">//还有最后一个没判到</span></span><br><span class="line">ans=min(ans,minn*<span class="number">2</span>+cnt+maxx); <span class="comment">//来回走两遍aQAQ </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();  </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>小W与面试</title>
      <link href="/2018/10/23/24/"/>
      <url>/2018/10/23/24/</url>
      
        <content type="html"><![CDATA[<h1 id="Desciption"><a href="#Desciption" class="headerlink" title="Desciption"></a>Desciption</h1><p>小W因为染色的时候算错了一位数，所以自闭了。他决定不再染布了，去找工作。</p><p>在面试的时候，面试官问了他这样一个问题：</p><p>给定一个长度为 n 的序列 ai，求: </p><script type="math/tex; mode=display">\sum_{i<j,a_i>a_j} a_i xor a_j</script><p>小W发现他不会做，想求助于你。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行一个正整数 n。</p><p>第二行 n 个整数，表示 $a_i$。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>一个整数表示答案。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>2<br>2 1</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>3</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>对于 30% 的数据，满足 n≤5000。</p><p>对于 100% 的数据，满足 1≤n≤105,1≤ai≤105。</p><p>时间限制：1 s</p><p>空间限制：512 MB</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>考虑按位计算贡献，设c{[i]}{[j]}[0/1]表示值在[$x-2^k+1,x$]范围内的第j位为0/1的个数，用树状数组来维护，从后往前依次加入。</p><p>上代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll c[maxn][<span class="number">20</span>][<span class="number">2</span>],w[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> n,a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span></span>&#123;</span><br><span class="line">w[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">17</span>;i++) w[i]=w[i<span class="number">-1</span>]*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(x&lt;=maxn<span class="number">-5</span>)&#123;</span><br><span class="line">c[x][d][f]+=<span class="number">1</span>;</span><br><span class="line">x+=(x&amp;-x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">ll ret=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">ret+=c[x][d][f];</span><br><span class="line">x-=(x&amp;-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret*w[d];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">17</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">ans+=sum(a[i]<span class="number">-1</span>,j,<span class="number">0</span>);</span><br><span class="line">update(a[i],j,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ans+=sum(a[i]<span class="number">-1</span>,j,<span class="number">1</span>);</span><br><span class="line">update(a[i],j,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ready();</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
            <tag> 二进制 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Sirni</title>
      <link href="/2018/10/23/23/"/>
      <url>/2018/10/23/23/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>有 n 个点，每个点有个权值 p1, p2, . . . , pn。这些点之间两两有边，对于点 i, j，这两个点之<br>间的边权为 min($p_imodp_j,p_jmodp_i$)。<br>问把这些点连通的最小代价和是多少，也就是问这个完全图的最小生成树的边权和。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行一个正整数 n，接下来 n 行每行一个整数，表示这些点的权值。<br>30% 的数据- n ≤ 103。<br>40% 的数据- pi ≤ 106。<br>100% 的数据- 1 ≤ n ≤ 105, pi ≤ 106。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>一行表示答案</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>3<br>4<br>9<br>15</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>4</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>时间限制：5s<br>空间限制：768MB</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先会发现每条边边权为$p_imodp_j (p_i&gt;p_j)$，因为小数模大数为小数，大数模小数小于小数。然后先将点排序离散化去重（相同点权两点之间距离为0），然后从小到大对于每个$p_i$，我们设其值为x，那么会从x-2x,2x-3x……选出一个点连边作为最优值（见图，解释在下）：<br><img src="https://i.loli.net/2018/11/06/5be1a230892d8.png" alt=""><br>对于每一段，我们肯定首选第一个大于它的是最小的，如图中x-2x的$p_j$，然后对于$p_k$，我们选择不连边而让$p_j$去连更优，如图中绿色段为$p_j$连$p_k$代价，而蓝色段为x连$p_k$代价，可见前者更优，然后我们一共会连$\sum\lfloor\frac{mx}{p_i}\rfloor$条边，将它放大为调和级数求和$plogp$，所以用kruskal可以$plog^2p$求出….</p><p>然后对于连边直接先预处理每个区间第一个选的，然后O（n）搞好.</p><p>上代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxm 10000005</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n,a[maxn],nxtt[maxm],pos[maxm],fa[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(fa[x]==x) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">int</span> root=find(fa[x]);</span><br><span class="line">fa[x]=root;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fx=find(x),fy=find(y);</span><br><span class="line"><span class="keyword">if</span>(fx!=fy) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fx=find(x),fy=find(y);</span><br><span class="line"><span class="keyword">if</span>(fx!=fy)&#123;</span><br><span class="line">fa[fx]=fy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eage</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> u,v,len;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(eage a,eage b)&#123;</span><br><span class="line"><span class="keyword">return</span> a.len&lt;b.len;</span><br><span class="line">&#125;</span><br><span class="line">&#125;e[maxm*<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> np=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i; </span><br><span class="line">sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> cnt=unique(a+<span class="number">1</span>,a+n+<span class="number">1</span>)-a<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) nxtt[a[i]]=a[i],pos[a[i]]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=maxm<span class="number">-2</span>;i&gt;=<span class="number">1</span>;i--) <span class="keyword">if</span>(!nxtt[i]) nxtt[i]=nxtt[i+<span class="number">1</span>],pos[i]=pos[i+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">e[++np]=(eage)&#123;i,i+<span class="number">1</span>,a[i+<span class="number">1</span>]%a[i]&#125;;<span class="comment">//过掉x </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>*a[i];j&lt;maxm;j+=a[i])&#123;<span class="comment">//从2x开始找 </span></span><br><span class="line"><span class="keyword">if</span>(!nxtt[j]) <span class="keyword">break</span>;<span class="comment">//后面没有了 </span></span><br><span class="line"><span class="keyword">if</span>(nxtt[j]&gt;=j+a[i]) <span class="keyword">continue</span>;</span><br><span class="line">e[++np]=(eage)&#123;i,pos[nxtt[j]],nxtt[j]%a[i]&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(e+<span class="number">1</span>,e+np+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> calc=<span class="number">0</span>;ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=np;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> u=e[i].u,v=e[i].v;ll c=e[i].len;</span><br><span class="line"><span class="keyword">if</span>(check(u,v)) <span class="keyword">continue</span>;</span><br><span class="line">link(u,v);</span><br><span class="line">calc++;</span><br><span class="line">ans+=c;</span><br><span class="line"><span class="keyword">if</span>(calc==cnt<span class="number">-1</span>)&#123;<span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);<span class="keyword">return</span>;&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
            <tag> 调和级数 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Poklon</title>
      <link href="/2018/10/23/22/"/>
      <url>/2018/10/23/22/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>有一个长度为 n 的序列，每个数的范围在 0 到 $10^9$ 之内。<br>你有 Q 个询问，给出 l, r，问这个序列中区间 l 到 r 中恰好出现了两次的数字的个数。序<br>列的下标从 1 开始。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行两个整数 n 和 Q，接下来一行 n 个整数，表示这个序列。<br>接下来 Q 行，每行两个整数 l, r 表示询问的区间。<br>40% 的数据- n, Q ≤ 5000。<br>100% 的数据-1 ≤ n, Q ≤ 500000。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>Q 行，每行一个整数表示答案</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>5 2<br>1 1 2 2 3<br>1 1<br>1 5</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>0<br>2</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>时间限制：5s<br>空间限制：512MB</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>正解貌似是二维树状数组？？？没听懂orz。。。思想跟以前一道很类似，记录每一个数前面一个相同的和后面一个相同的，当区间包含l[i],i或i,r[i]时就会有贡献,从而以l为横轴,r为竖轴建立坐标系，每次修改就是一块矩形的加1，然后查询就对于(l,r)的点值。</p><font color="red">~~有时间一定要了解下qwq~~</font><p>然后貌似用莫队可以随随便便过，直接开始离散化一下，然后莫队一波就欧克了，O($n\sqrt{n}$)还是能过的。</p><p>上代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,q,a[maxn],blog[maxn],t[maxn],c[maxn];</span><br><span class="line"><span class="keyword">int</span> calc=<span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,id,ans;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(node a,node b)&#123;</span><br><span class="line"><span class="keyword">if</span>(blog[a.l]==blog[b.l]) <span class="keyword">return</span> a.r&lt;b.r;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> a.l&lt;b.l;</span><br><span class="line">&#125;</span><br><span class="line">&#125;nd[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update1</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">c[a[i]]--;</span><br><span class="line"><span class="keyword">if</span>(c[a[i]]==<span class="number">1</span>) calc--;</span><br><span class="line"><span class="keyword">if</span>(c[a[i]]==<span class="number">2</span>) calc++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update2</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">c[a[i]]++;</span><br><span class="line"><span class="keyword">if</span>(c[a[i]]==<span class="number">2</span>) calc++;</span><br><span class="line"><span class="keyword">if</span>(c[a[i]]==<span class="number">3</span>) calc--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line"><span class="keyword">int</span> blo=<span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),blog[i]=(i<span class="number">-1</span>)/blo+<span class="number">1</span>,t[i]=a[i];</span><br><span class="line">sort(t+<span class="number">1</span>,t+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> cnt=unique(t+<span class="number">1</span>,t+n+<span class="number">1</span>)-t<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">a[i]=lower_bound(t+<span class="number">1</span>,t+cnt+<span class="number">1</span>,a[i])-t;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;nd[i].l,&amp;nd[i].r),nd[i].id=i;</span><br><span class="line">    sort(nd+<span class="number">1</span>,nd+q+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(l&lt;nd[i].l) update1(l),l++;</span><br><span class="line"><span class="keyword">while</span>(r&gt;nd[i].r) update1(r),r--;</span><br><span class="line"><span class="keyword">while</span>(l&gt;nd[i].l) update2(l<span class="number">-1</span>),l--;</span><br><span class="line"><span class="keyword">while</span>(r&lt;nd[i].r) update2(r+<span class="number">1</span>),r++;</span><br><span class="line">nd[i].ans=calc;</span><br><span class="line">&#125;</span><br><span class="line">sort(nd+<span class="number">1</span>,nd+q+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,nd[i].ans); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二维树状数组 </tag>
            
            <tag> 莫队 </tag>
            
            <tag> 离散化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Igra</title>
      <link href="/2018/10/23/21/"/>
      <url>/2018/10/23/21/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Alice 和 Bob 在玩游戏。 Alice 和 “Bob 各写了一个长度为 n 的由小写字母 abc 构成的串。<br>Alice 想把她的串中的字符打乱，对于任意的 B， Alice 串中的第 i 位和 Bob 串中的对应位置不<br>同。<br>Alice 想要知道字典序最小的这样的串是什么，数据保证有有解.</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行包含一个正整数 n。<br>接下来两行每行一个长度为 n 的字符串，表示 Alice 和 Bob 手中的串。<br>40W 的数据- n ≤ 20。<br>100W 的数据- 1 ≤ n ≤ 5000</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>一行一个串，表示 Alice 想要找的串。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>5<br>baaac<br>abcba</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>baaac</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>时间限制：2s<br>空间限制：512MB</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>这道题…..要用到hall定理，要求字符串A和B完全匹配，所以我们对于A和B中abc字符的量要求满足：<br>$A_a&lt;=B_b+B_c$<br>$A_b&lt;=B_a+B_c$<br>$A_c&lt;=B_a+B_b$<br>简单想一想就会发现如果大于那么a就必须与一个a匹配，所以时刻应满足这个，然后应用贪心策略，在满足条件情况下选字典序最小的（要注意坑点$A_a,A_b,A_c&gt;=0$）</p><p>上代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 5005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> s[maxn],ss[maxn];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">4</span>],b[<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a[<span class="number">1</span>]&lt;=b[<span class="number">2</span>]+b[<span class="number">3</span>]&amp;&amp;a[<span class="number">2</span>]&lt;=b[<span class="number">1</span>]+b[<span class="number">3</span>]&amp;&amp;a[<span class="number">3</span>]&lt;=b[<span class="number">1</span>]+b[<span class="number">2</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[s[i]-<span class="string">'a'</span>+<span class="number">1</span>]++;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,ss+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) b[ss[i]-<span class="string">'a'</span>+<span class="number">1</span>]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(ss[i]==<span class="string">'a'</span>)&#123;</span><br><span class="line">a[<span class="number">2</span>]--;b[<span class="number">1</span>]--;</span><br><span class="line"><span class="keyword">bool</span> ok=check();</span><br><span class="line"><span class="keyword">if</span>(a[<span class="number">2</span>]&lt;<span class="number">0</span>) ok=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(ok) <span class="built_in">printf</span>(<span class="string">"b"</span>);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">a[<span class="number">2</span>]++;a[<span class="number">3</span>]--;<span class="built_in">printf</span>(<span class="string">"c"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ss[i]==<span class="string">'b'</span>)&#123;</span><br><span class="line">    a[<span class="number">1</span>]--;b[<span class="number">2</span>]--;</span><br><span class="line">    <span class="keyword">bool</span> ok=check();</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">1</span>]&lt;<span class="number">0</span>) ok=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(ok) <span class="built_in">printf</span>(<span class="string">"a"</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    a[<span class="number">1</span>]++;a[<span class="number">3</span>]--;<span class="built_in">printf</span>(<span class="string">"c"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ss[i]==<span class="string">'c'</span>)&#123;</span><br><span class="line">     a[<span class="number">1</span>]--;b[<span class="number">3</span>]--;</span><br><span class="line">     <span class="keyword">bool</span> ok=check();</span><br><span class="line">     <span class="keyword">if</span>(a[<span class="number">1</span>]&lt;<span class="number">0</span>) ok=<span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">if</span>(ok) <span class="built_in">printf</span>(<span class="string">"a"</span>);</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">     a[<span class="number">1</span>]++;a[<span class="number">2</span>]--;<span class="built_in">printf</span>(<span class="string">"b"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> Hall定理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>小W与卖酒</title>
      <link href="/2018/10/22/20/"/>
      <url>/2018/10/22/20/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>小W因为没做出上面那题，没能通过面试。他决定改行卖酒。</p><p>他有 n 个容器，每个容器的容积是 ai。他没有其它测量工具，只知道每个容器的容积。</p><p>他还有一个大小无限的容器，他想知道他能否在这个容器中倒出 x 体积的酒。他可能有多次询问。</p><p>例如他有 2 个容器，大小分别是 3,5，那么他能够倒出 2 体积的酒，因为他可以先把第二个容器填满，然后用第二个容器的酒往第一个容器里倒，直到把第一个容器倒满，那么第二个容器剩下的体积就是 2。最后再把这些酒倒进那个大小无限的容器，就倒出了 2 体积的酒。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行两个正整数 n, q。</p><p>第二行 n 个整数，表示 ai。</p><p>接下来 q 行，每行一个整数 x，表示一次询问。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>输出 q 行，每行 YES 或者 NO 表示对应询问的答案。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>2 2<br>4 6<br>1<br>2</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>NO<br>YES</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>对于 10% 的数据，满足 n,q≤5,ai,x≤5。</p><p>对于 20% 的数据，满足 n,q≤10,ai,x≤10。</p><p>对于 50% 的数据，满足 ai,x≤105。</p><p>对于 100% 的数据，满足 1≤n,q≤105,1≤ai,x≤109。</p><p>时间限制：1 s</p><p>空间限制：512 MB</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>我靠大佬们都是一眼秒a…这好像是个啥子结论，用裴蜀定理证明，然鹅不会….<br>主要求出$g=gcd(a_i)​$，然后对于每一个倒的水量x，若g是x的因数（能被x整除）则x可以倒出…记着吧233333</p><p>上代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,g,x;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(y==<span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> gcd(y,x%y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;g);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">g=gcd(g,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">    <span class="keyword">if</span>(x%g==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"NO\n"</span>); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("1.in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("1.out","w",stdout);</span></span><br><span class="line">    init(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 裴蜀定理 </tag>
            
            <tag> 结论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ZJOI2006 书架</title>
      <link href="/2018/10/22/19/"/>
      <url>/2018/10/22/19/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>小T有一个很大的书柜。这个书柜的构造有些独特，即书柜里的书是从上至下堆放成一列。她用1到n的正整数给每本书都编了号。</p><p>小T在看书的时候，每次取出一本书，看完后放回书柜然后再拿下一本。由于这些书太有吸引力了，所以她看完后常常会忘记原来是放在书柜的什么位置。不过小T的记忆力是非常好的，所以每次放书的时候至少能够将那本书放在拿出来时的位置附近，比如说她拿的时候这本书上面有X本书，那么放回去时这本书上面就只可能有X-1、X或X+1本书。</p><p>当然也有特殊情况，比如在看书的时候突然电话响了或者有朋友来访。这时候粗心的小T会随手把书放在书柜里所有书的最上面或者最下面，然后转身离开。</p><p>久而久之，小T的书柜里的书的顺序就会越来越乱，找到特定的编号的书就变得越来越困难。于是她想请你帮她编写一个图书管理程序，处理她看书时的一些操作，以及回答她的两个提问：(1)编号为X的书在书柜的什么位置；(2)从上到下第i本书的编号是多少。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行有两个数n，m，分别表示书的个数以及命令的条数；第二行为n个正整数：第i个数表示初始时从上至下第i个位置放置的书的编号；第三行到m+2行，每行一条命令。命令有5种形式：</p><p>1． Top S——表示把编号为S的书放在最上面。</p><p>2． Bottom S——表示把编号为S的书放在最下面。</p><p>3． Insert S T——T∈{-1，0，1}，若编号为S的书上面有X本书，则这条命令表示把这本书放回去后它的上面有X+T本书；</p><p>4． Ask S——询问编号为S的书的上面目前有多少本书。</p><p>5． Query S——询问从上面数起的第S本书的编号。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>对于每一条Ask或Query语句你应该输出一行，一个数，代表询问的答案。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>10 10<br>1 3 2 7 5 8 10 4 9 6<br>Query 3<br>Top 5<br>Ask 6<br>Bottom 3<br>Ask 3<br>Top 6<br>Insert 4 -1<br>Query 5<br>Query 2<br>Ask 2</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>2<br>9<br>9<br>7<br>5<br>3</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>100%的数据，n,m &lt;= 80000</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>一道裸的线段平衡树题a…..<br>先上一波权值平衡树的板子（实际操作中可以按情况修改）<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000000+5 </span></span><br><span class="line"><span class="keyword">int</span> fa[maxn],ch[maxn][<span class="number">2</span>],sz[maxn],cnt[maxn],val[maxn];</span><br><span class="line"><span class="keyword">int</span> rt=<span class="number">0</span>,np=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>]==x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">bool</span> kind)</span></span>&#123;</span><br><span class="line">fa[x]=y;ch[y][kind]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upload</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">sz[x]=sz[ch[x][<span class="number">0</span>]]+sz[ch[x][<span class="number">1</span>]]+cnt[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> y=fa[x],z=fa[y];</span><br><span class="line"><span class="keyword">bool</span> kind=check(x);</span><br><span class="line"><span class="keyword">int</span> k=ch[x][!kind];</span><br><span class="line">link(k,y,kind);</span><br><span class="line">link(x,z,check(y));</span><br><span class="line">link(y,x,!kind);</span><br><span class="line">upload(y);upload(x); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> goal)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(fa[x]!=goal)&#123;</span><br><span class="line">    <span class="keyword">int</span> y=fa[x],z=fa[y];</span><br><span class="line">    <span class="keyword">if</span>(z!=goal) (check(x)^check(y))?rotate(x):rotate(y);</span><br><span class="line">    rotate(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(fa[x]==<span class="number">0</span>) rt=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> now=rt;</span><br><span class="line"><span class="keyword">while</span>(ch[now][x&gt;val[now]]&amp;&amp;val[now]!=x)</span><br><span class="line">  now=ch[now][x&gt;val[now]];</span><br><span class="line">splay(now,<span class="number">0</span>);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> now=rt,f=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(now&amp;&amp;val[now]!=x) f=now,now=ch[now][x&gt;val[now]];</span><br><span class="line"><span class="keyword">if</span>(now) cnt[now]++;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">now=++np;</span><br><span class="line">val[now]=x;</span><br><span class="line"><span class="keyword">if</span>(f) ch[f][x&gt;val[f]]=now;</span><br><span class="line">fa[now]=f;</span><br><span class="line">cnt[now]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">splay(now,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prnx</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">bool</span> f)</span></span>&#123;</span><br><span class="line">find(x);</span><br><span class="line"><span class="keyword">int</span> now=rt;</span><br><span class="line"><span class="keyword">if</span>(val[now]&gt;x&amp;&amp;f||val[now]&lt;x&amp;&amp;!f) <span class="keyword">return</span> now;</span><br><span class="line">now=ch[now][f];</span><br><span class="line"><span class="keyword">while</span>(ch[now][!f]) now=ch[now][!f];</span><br><span class="line"><span class="keyword">return</span> now; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pre=prnx(x,<span class="number">0</span>),last=prnx(x,<span class="number">1</span>);</span><br><span class="line">splay(pre,<span class="number">0</span>);splay(last,pre);</span><br><span class="line"><span class="keyword">int</span> delt=ch[last][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(cnt[delt])&#123;cnt[delt]--;splay(delt,<span class="number">0</span>);&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ch[last][<span class="number">0</span>]=<span class="number">0</span>;splay(last,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k&lt;=sz[ch[now][<span class="number">0</span>]]) <span class="keyword">return</span> kth(ch[now][<span class="number">0</span>],k);</span><br><span class="line"><span class="keyword">if</span>(sz[ch[now][<span class="number">0</span>]]+cnt[now]&lt;k) <span class="keyword">return</span> kth(ch[now][<span class="number">1</span>],k-sz[ch[now][<span class="number">0</span>]]-cnt[now]);</span><br><span class="line">splay(now,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> val[now];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kth</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> now=rt,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;val[now]) now=ch[now][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ans+=ch[now][<span class="number">0</span>]?sz[ch[now][<span class="number">0</span>]]:<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(val[now]==x)&#123;splay(now,<span class="number">0</span>);<span class="keyword">return</span> ans+<span class="number">1</span>;&#125;</span><br><span class="line">ans+=cnt[now];</span><br><span class="line">now=ch[now][<span class="number">1</span>]; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">insert(INT_MIN);</span><br><span class="line">insert(INT_MAX);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50000</span>;i++) insert(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50000</span>;i++) kth(rt,i); </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这道题是线段平衡树，对于每个操作画下图，想一下就欧克了，没什么好说的…..</p><p>上代码：<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">#define maxn 80005</span></span><br><span class="line">int n,m,np=<span class="number">0</span>,rt=<span class="number">0</span>;</span><br><span class="line">int fa[maxn],ch[maxn][<span class="number">2</span>],sz[maxn];</span><br><span class="line">int val[maxn],rk[maxn];</span><br><span class="line">bool check(int x)&#123;<span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>]==x;&#125;</span><br><span class="line">void link(int x,int y,bool kind)&#123;</span><br><span class="line">    fa[x]=y;ch[y][kind]=x;</span><br><span class="line">&#125;</span><br><span class="line">void upload(int x)&#123;</span><br><span class="line">    sz[x]=sz[ch[x][<span class="number">0</span>]]+sz[ch[x][<span class="number">1</span>]]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">void rotate(int x)&#123;</span><br><span class="line">    int y=fa[x];</span><br><span class="line">    int z=fa[y];</span><br><span class="line">    bool kind=check(x);</span><br><span class="line">    int k=ch[x][!kind];</span><br><span class="line">    link(k,y,kind);</span><br><span class="line">    link(x,z,check(y));</span><br><span class="line">    link(y,x,!kind);</span><br><span class="line">    upload(y);upload(x);</span><br><span class="line">&#125;</span><br><span class="line">void splay(int x,int goal)&#123;</span><br><span class="line">    <span class="keyword">while</span>(fa[x]!=goal)&#123;</span><br><span class="line">        int y=fa[x],z=fa[y];</span><br><span class="line">        <span class="keyword">if</span>(z!=goal) (check(x)^check(y))?rotate(x)<span class="symbol">:rotate</span>(y);</span><br><span class="line">        rotate(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==<span class="number">0</span>) rt=x;</span><br><span class="line">&#125;</span><br><span class="line">void insert(int x)&#123;</span><br><span class="line">    int now=rt,f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(now) f=now,now=ch[now][<span class="number">1</span>];</span><br><span class="line">    now=++np;</span><br><span class="line">    link(now,f,<span class="number">1</span>);</span><br><span class="line">    splay(now,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">int nxt(int x,bool f)&#123;<span class="regexp">//</span>前提要将x旋转到根 </span><br><span class="line">    x=ch[x][f];</span><br><span class="line">    <span class="keyword">while</span>(ch[x][!f]) x=ch[x][!f];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">void del(int x)&#123;</span><br><span class="line">    splay(x,<span class="number">0</span>);</span><br><span class="line">    int pre=nxt(x,<span class="number">0</span>),nxtt=nxt(x,<span class="number">1</span>);</span><br><span class="line">    splay(pre,<span class="number">0</span>);splay(nxtt,pre);</span><br><span class="line">    ch[nxtt][<span class="number">0</span>]=<span class="number">0</span>;splay(nxtt,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">int kth(int now,int k)&#123;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=sz[ch[now][<span class="number">0</span>]]) <span class="keyword">return</span> kth(ch[now][<span class="number">0</span>],k);</span><br><span class="line">    <span class="keyword">if</span>(sz[ch[now][<span class="number">0</span>]]+<span class="number">1</span>&lt;k) <span class="keyword">return</span> kth(ch[now][<span class="number">1</span>],k-sz[ch[now][<span class="number">0</span>]]-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125; </span><br><span class="line">int s,k;</span><br><span class="line">char op[<span class="number">10</span>];</span><br><span class="line">void init()&#123;</span><br><span class="line">    scanf(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">2</span>;i&lt;=n+<span class="number">1</span>;i++) scanf(<span class="string">"%d"</span>,&amp;val[i]),rk[val[i]]=i;</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=n+<span class="number">2</span>;i++) insert(i);</span><br><span class="line">    <span class="keyword">for</span>(int i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        scanf(<span class="string">"%s"</span>,op);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'T'</span>)&#123;</span><br><span class="line">            scanf(<span class="string">"%d"</span>,&amp;s);</span><br><span class="line">            int t=rk[s];</span><br><span class="line">            del(t);</span><br><span class="line">            /*splay(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            int nxtt=nxt(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            splay(nxtt,<span class="number">0</span>);splay(<span class="number">1</span>,nxtt);</span><br><span class="line">            link(t,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            splay(t,<span class="number">0</span>);*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">            splay(1,0);</span></span><br><span class="line"><span class="regexp">            int nxtt=nxt(1,1);</span></span><br><span class="line"><span class="regexp">            splay(nxtt,1);</span></span><br><span class="line"><span class="regexp">            link(t,nxtt,0);</span></span><br><span class="line"><span class="regexp">            splay(t,0); </span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        else if(op[0]=='B')&#123;</span></span><br><span class="line"><span class="regexp">            scanf("%d",&amp;s);</span></span><br><span class="line"><span class="regexp">            int t=rk[s];</span></span><br><span class="line"><span class="regexp">            del(t);</span></span><br><span class="line"><span class="regexp">            /</span>*splay(n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">            int pre=nxt(n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">            splay(pre,<span class="number">0</span>);splay(n+<span class="number">2</span>,pre);</span><br><span class="line">            link(t,n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">            splay(t,<span class="number">0</span>);*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">            splay(n+2,0);</span></span><br><span class="line"><span class="regexp">            int pre=nxt(n+2,0);</span></span><br><span class="line"><span class="regexp">            splay(pre,n+2);</span></span><br><span class="line"><span class="regexp">            link(t,pre,1);</span></span><br><span class="line"><span class="regexp">            splay(t,0);</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        else if(op[0]=='I')&#123;</span></span><br><span class="line"><span class="regexp">            scanf("%d%d",&amp;s,&amp;k);</span></span><br><span class="line"><span class="regexp">            if(k==0) continue;</span></span><br><span class="line"><span class="regexp">            int t=rk[s];</span></span><br><span class="line"><span class="regexp">            splay(t,0);</span></span><br><span class="line"><span class="regexp">            if(k==1)&#123;</span></span><br><span class="line"><span class="regexp">                int nxtt=nxt(t,1);</span></span><br><span class="line"><span class="regexp">                swap(rk[val[t]],rk[val[nxtt]]);</span></span><br><span class="line"><span class="regexp">                swap(val[t],val[nxtt]);</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            else&#123;</span></span><br><span class="line"><span class="regexp">                int nxtt=nxt(t,0);</span></span><br><span class="line"><span class="regexp">                swap(rk[val[t]],rk[val[nxtt]]);</span></span><br><span class="line"><span class="regexp">                swap(val[t],val[nxtt]);</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        else if(op[0]=='A')&#123;</span></span><br><span class="line"><span class="regexp">            scanf("%d",&amp;s);</span></span><br><span class="line"><span class="regexp">            int t=rk[s];</span></span><br><span class="line"><span class="regexp">            splay(t,0);</span></span><br><span class="line"><span class="regexp">            printf("%d\n",sz[ch[t][0]]-1);/</span><span class="regexp">/减去最开始加入的1 </span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        else if(op[0]=='Q')&#123;</span></span><br><span class="line"><span class="regexp">            scanf("%d",&amp;s);</span></span><br><span class="line"><span class="regexp">            printf("%d\n",val[kth(rt,s+1)]);/</span><span class="regexp">/减去1 </span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">int main()&#123;</span></span><br><span class="line"><span class="regexp">    init();</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">    return 0;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> noip模拟赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 平衡树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SCOI2011 糖果</title>
      <link href="/2018/10/22/18/"/>
      <url>/2018/10/22/18/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>幼儿园里有N个小朋友，lxhgww老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。但是小朋友们也有嫉妒心，总是会提出一些要求，比如小明不希望小红分到的糖果比他的多，于是在分配糖果的时候，lxhgww需要满足小朋友们的K个要求。幼儿园的糖果总是有限的，lxhgww想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>输入的第一行是两个整数N，K。接下来K行，表示这些点需要满足的关系，每行3个数字，X，A，B。如果X=1， 表示第A个小朋友分到的糖果必须和第B个小朋友分到的糖果一样多；如果X=2， 表示第A个小朋友分到的糖果必须少于第B个小朋友分到的糖果；如果X=3， 表示第A个小朋友分到的糖果必须不少于第B个小朋友分到的糖果；如果X=4， 表示第A个小朋友分到的糖果必须多于第B个小朋友分到的糖果；如果X=5， 表示第A个小朋友分到的糖果必须不多于第B个小朋友分到的糖果；</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>输出一行，表示lxhgww老师至少需要准备的糖果数，如果不能满足小朋友们的所有要求，就输出-1。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>5 7<br>1 1 2<br>2 3 2<br>4 4 1<br>3 4 5<br>5 4 5<br>2 3 5<br>4 5 1</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>11</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>11<br>说明<br>【数据范围】</p><p>对于30%的数据，保证 N&lt;=100</p><p>对于100%的数据，保证 N&lt;=100000</p><p>对于所有的数据，保证 K&lt;=100000，1&lt;=X&lt;=5，1&lt;=A, B&lt;=N</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先，这道题要看出是一个差分约束系统，而求至少便是求最小值，所以应转化为$d[j]&gt;=d[i]+Wij$，<del>这样跑最长路(只有用spfa)并且判0环就行了</del>，然而发现这样只会有60，<br>因为数据大和毒，导致判0环会炸。然后发现可以强联通分量缩点，那么每个分量的值肯定是一样的，如果边中有1就说明不符合。最后加一个超级起点，从它开始拓扑加dp就能过了。</p><p>上代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 150005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,op,a,b;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eage</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,next,len;</span><br><span class="line">&#125;e[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> np=<span class="number">0</span>,first[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">e[++np]=(eage)&#123;v,first[u],len&#125;;</span><br><span class="line">first[u]=np;</span><br><span class="line">&#125;</span><br><span class="line">ll d[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> st[maxn],top=<span class="number">0</span>,low[maxn],dfn[maxn],clock_=<span class="number">0</span>,belong[maxn],cc=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> ok=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> stt[maxn],topp=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=topp;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> t=stt[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> p=first[t];p;p=e[p].next)&#123;</span><br><span class="line"><span class="keyword">int</span> j=e[p].to,c=e[p].len;</span><br><span class="line"><span class="keyword">if</span>(belong[j]==belong[t]&amp;&amp;c==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">vis[i]=<span class="number">1</span>;</span><br><span class="line">dfn[i]=low[i]=++clock_;</span><br><span class="line">st[++top]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> p=first[i];p;p=e[p].next)&#123;</span><br><span class="line"><span class="keyword">int</span> j=e[p].to;</span><br><span class="line"><span class="keyword">if</span>(vis[j])&#123;</span><br><span class="line"><span class="keyword">if</span>(!belong[j]) low[i]=min(low[i],dfn[j]);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">dfs(j);</span><br><span class="line">low[i]=min(low[i],low[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(low[i]==dfn[i])&#123;</span><br><span class="line">cc++;topp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">int</span> t=st[top--];</span><br><span class="line">belong[t]=cc;</span><br><span class="line">stt[++topp]=t;</span><br><span class="line"><span class="keyword">if</span>(t==i) <span class="keyword">break</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">bool</span> okk=run(); </span><br><span class="line"><span class="keyword">if</span>(okk==<span class="literal">true</span>) ok=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to;ll len;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt;g[maxn];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q; </span><br><span class="line"><span class="keyword">int</span> rd[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> p=first[i];p;p=e[p].next)&#123;</span><br><span class="line"><span class="keyword">int</span> j=e[p].to;ll c=e[p].len;</span><br><span class="line"><span class="keyword">if</span>(belong[j]!=belong[i]) g[belong[i]].push_back((node)&#123;belong[j],c&#125;),rd[belong[j]]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d[belong[n+<span class="number">1</span>]]=<span class="number">0</span>;</span><br><span class="line">q.push(belong[n+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> i=q.front();q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;g[i].size();j++)&#123;</span><br><span class="line">node t=g[i][j];</span><br><span class="line">    <span class="keyword">int</span> kk=t.to;ll c=t.len;</span><br><span class="line">    d[kk]=max(d[kk],d[i]+c);</span><br><span class="line">    rd[kk]--;</span><br><span class="line">    <span class="keyword">if</span>(rd[kk]==<span class="number">0</span>) q.push(kk);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    d[n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;op,&amp;a,&amp;b);</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">add(a,b,<span class="number">0</span>);</span><br><span class="line">add(b,a,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">add(a,b,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>)&#123;</span><br><span class="line">add(b,a,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">4</span>)&#123;</span><br><span class="line">add(b,a,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">5</span>)&#123;</span><br><span class="line">add(a,b,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) add(n+<span class="number">1</span>,i,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[i]) dfs(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ok) <span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">work();</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++) ans+=d[belong[i]];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("in.txt","r",stdin);</span></span><br><span class="line"><span class="comment">//freopen("out.txt","w",stdout); </span></span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> noip模拟赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 缩点 </tag>
            
            <tag> 拓扑 </tag>
            
            <tag> 差分约束系统 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>约束</title>
      <link href="/2018/10/20/17/"/>
      <url>/2018/10/20/17/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>现有 n 个点， n 条有向边。 要求将 n 个点分入两个集合 A， B，使得对于集合<br>A 中的每一个点 x，存在一个集合 B 中的点 y，从 y 到 x 有一条有向边。 问集合<br>A 最多能包含几个点。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行一个整数 n，表示总共有 n 个点。<br>接下来一行 n 个整数，表示一个序列 a， a[i]代表存在一条从第 i 个点到第<br>a[i]个点的有向边。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>一行一个数 ans， ans 是集合 A 最多能包含的点数。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>5<br>2 4 5 3 1</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>2</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>对于 30%的数据， n&lt;=10<br>对于 100%的数据， n&lt;=100000</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>发现一个点最多连向另外一个点，可以想一下发现是环加内向树。<br>那么对于入度为0的点便只能加入B集合，那么a[x]定可以为A集合，所以拓扑排序，将遇到的<br>为标记的或x和a[x]都为B的，将a[x]加入A。<br>最后剩下环，将环上的B集合的标记清空(这样可以更大)，然后以环上的A集合点向没有标记的点<br>蔓延赋值，最后就能得到最佳情况。</p><p>上代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,x,rd[maxn],a[maxn];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="keyword">int</span> color[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> calc;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">a[i]=x;</span><br><span class="line">rd[x]++;</span><br><span class="line">&#125; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(rd[i]==<span class="number">0</span>) q.push(i),color[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">    <span class="keyword">int</span> i=q.front();q.pop();</span><br><span class="line">    <span class="keyword">if</span>(!color[a[i]])&#123;</span><br><span class="line">    color[a[i]]=<span class="number">3</span>-color[i];</span><br><span class="line">    <span class="keyword">if</span>(color[a[i]]==<span class="number">2</span>) ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(color[i]==<span class="number">1</span>&amp;&amp;color[a[i]]==<span class="number">1</span>) color[a[i]]=<span class="number">2</span>,ans++;</span><br><span class="line">rd[a[i]]--;</span><br><span class="line"><span class="keyword">if</span>(rd[a[i]]==<span class="number">0</span>) q.push(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(rd[i]&amp;&amp;color[i]==<span class="number">1</span>) color[i]=<span class="number">0</span>;<span class="comment">//将1清完，从2开始会更多 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(rd[i]&amp;&amp;color[i])&#123;</span><br><span class="line"><span class="keyword">int</span> x=i;</span><br><span class="line"><span class="keyword">while</span>(!color[a[x]])&#123;</span><br><span class="line">color[a[x]]=<span class="number">3</span>-color[x];</span><br><span class="line"><span class="keyword">if</span>(color[a[x]]==<span class="number">2</span>) ans++;</span><br><span class="line">x=a[x];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*for(int i=1;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">   if(!color[i])&#123;</span></span><br><span class="line"><span class="comment">   color[i]=1;</span></span><br><span class="line"><span class="comment">   int x=i;</span></span><br><span class="line"><span class="comment">   while(!color[a[x]])&#123;</span></span><br><span class="line"><span class="comment">   color[a[x]]=3-color[x];</span></span><br><span class="line"><span class="comment">   if(color[a[x]]==2) ans++;</span></span><br><span class="line"><span class="comment">   x=a[x];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 拓扑 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>键盘</title>
      <link href="/2018/10/20/16/"/>
      <url>/2018/10/20/16/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>现在文本框中有一个 x 个字符的字符串,希望在经过一系列操作后得到看到<br>一个长度恰好为 n 的字符串。<br>现可以有 5 种操作:<br>1.敲击 1 次键盘,输入一个字符<br>2.敲击 2 次键盘(Ctrl+A),选中所有已经输入的字符<br>3.敲击 2 次键盘(Ctrl+C),复制所有选中的字符到剪贴板<br>4.敲击 2 次键盘(Ctrl+V),把剪贴板中的所有字符输出(不清空剪贴板)<br>5.敲击 1 次键盘(Backspace),若没有选中字符则删除一个字符否则删除所<br>有选中的字符<br>选中状态仅影响复制操作。<br>问至少敲击几次键盘才能得到一个长度为 n 的字符串。</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>对于 100%的数据 $n,x&lt;=10^6$</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>这道题思路很nice啊，如果不考虑backspace操作的话，那么是可以递推来做的。但如果有的话，那么可以3次清空为0，然后一直乘2大约140步左右可以大于$10^6$，也就是说极限步数是<br>n+143，实际上会远远不到这个上限，那么若x能到y则连一条边，由调和级数算下来(缩放)大约为nlogn，再最短路跑一遍大约$nlog^2n$，因为上限远远没满卡一下常数能过。(主要为这方面题提供一种思路)</p><h3 id="dij代码-会T三个点qwq，可能以为1-5操作距离太近不太友好"><a href="#dij代码-会T三个点qwq，可能以为1-5操作距离太近不太友好" class="headerlink" title="dij代码(会T三个点qwq，可能以为1,5操作距离太近不太友好)"></a>dij代码(会T三个点qwq，可能以为1,5操作距离太近不太友好)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2000305</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,x,dist[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> v,id;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(node a,node b)&#123;</span><br><span class="line"><span class="keyword">return</span> a.v&gt;b.v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt;q; </span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;n);</span><br><span class="line"><span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dist));</span><br><span class="line"><span class="keyword">if</span>(x&gt;n)&#123;</span><br><span class="line">   dist[n]=x-n;</span><br><span class="line">   dist[<span class="number">0</span>]=<span class="number">3</span>;</span><br><span class="line">   q.push((node)&#123;dist[<span class="number">0</span>],<span class="number">0</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">dist[n]=n-x;dist[x]=<span class="number">0</span>;q.push((node)&#123;dist[x],x&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">node t=q.top();q.pop();</span><br><span class="line"><span class="keyword">int</span> i=t.id;<span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">vis[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i&lt;n) <span class="keyword">if</span>(dist[i+<span class="number">1</span>]&gt;dist[i]+<span class="number">1</span>)&#123;dist[i+<span class="number">1</span>]=dist[i]+<span class="number">1</span>;q.push((node)&#123;dist[i+<span class="number">1</span>],i+<span class="number">1</span>&#125;);&#125;;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(dist[i<span class="number">-1</span>]&gt;dist[i]+<span class="number">1</span>)&#123;dist[i<span class="number">-1</span>]=dist[i]+<span class="number">1</span>;q.push((node)&#123;dist[i<span class="number">-1</span>],i<span class="number">-1</span>&#125;);&#125;;</span><br><span class="line"><span class="keyword">int</span> len=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> m=<span class="number">2</span>*i;</span><br><span class="line"><span class="keyword">while</span>(m&lt;=n)&#123;</span><br><span class="line"><span class="keyword">if</span>(dist[m]&gt;dist[i]+len+<span class="number">2</span>)&#123;</span><br><span class="line">dist[m]=dist[i]+len+<span class="number">2</span>;q.push((node)&#123;dist[m],m&#125;);</span><br><span class="line">&#125;</span><br><span class="line">m=m+i;len+=<span class="number">2</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dist[n]&gt;dist[i]+len+<span class="number">2</span>+m-n) dist[n]=dist[i]+len+<span class="number">2</span>+m-n;<span class="comment">//超过的最快方法 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,dist[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="spfa-而spfa由于直接按加的顺序展开所以会好很多…"><a href="#spfa-而spfa由于直接按加的顺序展开所以会好很多…" class="headerlink" title="spfa(而spfa由于直接按加的顺序展开所以会好很多…)"></a>spfa(而spfa由于直接按加的顺序展开所以会好很多…)</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define maxn 2000305</span></span><br><span class="line">using namespace std;</span><br><span class="line">int n,x,dist[maxn];</span><br><span class="line">/*struct node&#123;</span><br><span class="line">int v,id;</span><br><span class="line">friend bool operator &lt;(node a,node b)&#123;</span><br><span class="line"><span class="keyword">return</span> a.v&gt;b.v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;*<span class="regexp">/</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/priority_queue&lt;node&gt;q; </span></span><br><span class="line"><span class="regexp">queue&lt;int&gt;q;</span></span><br><span class="line"><span class="regexp">bool vis[maxn];</span></span><br><span class="line"><span class="regexp">void init()&#123;</span></span><br><span class="line"><span class="regexp">scanf("%d%d",&amp;x,&amp;n);</span></span><br><span class="line"><span class="regexp">memset(dist,0x3f,sizeof(dist));</span></span><br><span class="line"><span class="regexp">if(x&gt;n)&#123;</span></span><br><span class="line"><span class="regexp">   dist[n]=x-n;</span></span><br><span class="line"><span class="regexp">   dist[0]=3;</span></span><br><span class="line"><span class="regexp">   q.push(0);vis[0]=1;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">else&#123;</span></span><br><span class="line"><span class="regexp">dist[n]=n-x;dist[x]=0;q.push(x);vis[x]=1;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">while(!q.empty())&#123;</span></span><br><span class="line"><span class="regexp">int i=q.front();q.pop();</span></span><br><span class="line"><span class="regexp">vis[i]=0;</span></span><br><span class="line"><span class="regexp">if(i&lt;n) if(dist[i+1]&gt;dist[i]+1)&#123;dist[i+1]=dist[i]+1;if(!vis[i+1]) vis[i+1]=1,q.push(i+1);&#125;;</span></span><br><span class="line"><span class="regexp">if(i==0) continue;</span></span><br><span class="line"><span class="regexp">if(dist[i-1]&gt;dist[i]+1)&#123;dist[i-1]=dist[i]+1;if(!vis[i-1]) vis[i-1]=1,q.push(i-1);&#125;;</span></span><br><span class="line"><span class="regexp">int len=4;</span></span><br><span class="line"><span class="regexp">int m=2*i;</span></span><br><span class="line"><span class="regexp">while(m&lt;=n)&#123;</span></span><br><span class="line"><span class="regexp">if(dist[m]&gt;dist[i]+len+2)&#123;</span></span><br><span class="line"><span class="regexp">dist[m]=dist[i]+len+2;if(!vis[m]) vis[m]=1,q.push(m);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">m=m+i;len+=2; </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">if(dist[n]&gt;dist[i]+len+2+m-n) dist[n]=dist[i]+len+2+m-n;/</span><span class="regexp">/超过的最快方法 </span></span><br><span class="line"><span class="regexp">&#125; </span></span><br><span class="line"><span class="regexp">printf("%d",dist[n]);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">int main()&#123;</span></span><br><span class="line"><span class="regexp">init();</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">return 0;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
            <tag> 隐式图 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>祎隋</title>
      <link href="/2018/10/20/15/"/>
      <url>/2018/10/20/15/</url>
      
        <content type="html"><![CDATA[<font size="6" color="pink">生活，靠容忍和退让支撑着前行</font><p>《祎隋》</p><p>年幼时</p><p>你含糊地</p><p>把热情挥洒</p><p>年老时</p><p>你明白地</p><p>将运命呈出</p><p><img src="https://i.loli.net/2018/11/06/5be1a28734ca8.jpg" alt="小鞠"></p>]]></content>
      
      
      <categories>
          
          <category> 杂诗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂诗 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>noip模拟赛2</title>
      <link href="/2018/10/18/13/"/>
      <url>/2018/10/18/13/</url>
      
        <content type="html"><![CDATA[<h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>小 H 最近迷上了名为“石头，剪刀，布”的游戏。<br>游戏规则很简单：比赛双方同时数到三，然后同时出一个手势，代表“石<br>头”、“剪刀”或“布”。“石头”胜“剪刀”，“剪刀”胜“布”，“布”胜“石<br>头”。举个例子， 小 H 出“石头”， 对方出“布”，则对方胜利。当然，也可<br>以“平局”（如果双方手势相同的话）。<br>小 H 对阵小 B。 小 H 作为一个匹托专家，能够预测小 B 未来 N 回合的手<br>势。 但作为具有数学头脑的人， 他又是比较懒的，以至于他只愿意变换固<br>定次数的手势来完成游戏。例如， 他只想变 1 次，则他可能出“石头”几<br>次，剩下的都出“布”；或者其他。<br>现在小 H 与小 B 准备进行 N 回合的比赛，且已经测出小 B 未来 N 回合<br>的手势，小 H 只愿意改变 K 次手势（最开始手势任意）。请你帮小 H 求出他<br>最多能赢多少场</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>输入文件名为 game.in。<br>输入的第一行两个空格隔开的数字 N 和 K，分别表示比赛的回合数和<br>小 H 变换手势的次数。 接下来的 N 行，每行一个字母，表示小 B 的手势： ’H’<br>表示石头、 ’S’表示剪刀、 ’P’表示布</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>输出文件名为 game.out。<br>输出一行一个整数， 小 H 最多能赢的场数</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><p>5 1<br>P P H P S</p><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><p>4</p><h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><p>对于 30%的数据： N≤20<br>对于 100%的数据： N≤100 000， K≤20</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>一道水水的dp啊qwq，刷表和i-1到i转移都可以。注意细节…O($n \ast k$)实现就欧克。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="keyword">int</span> n,k,a[maxn],dp[maxn][<span class="number">22</span>][<span class="number">3</span>];<span class="comment">//0:石头,1：剪刀,2:布 </span></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);<span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'H'</span>)a[i]=<span class="number">0</span>;<span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'S'</span>) a[i]=<span class="number">1</span>;<span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'P'</span>) a[i]=<span class="number">2</span>;&#125;;</span><br><span class="line"><span class="comment">//dp[0][0][0]=dp[0][0][1]=dp[0][0][2]=0;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=min(i,k);j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> kk=<span class="number">0</span>;kk&lt;=<span class="number">2</span>;kk++)&#123;<span class="comment">//枚举上一个的手势 </span></span><br><span class="line"><span class="keyword">int</span> f=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(a[i]==<span class="number">2</span>&amp;&amp;kk==<span class="number">1</span>) f=<span class="number">1</span>; </span><br><span class="line"><span class="keyword">if</span>(a[i]==<span class="number">1</span>&amp;&amp;kk==<span class="number">0</span>) f=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(a[i]==<span class="number">0</span>&amp;&amp;kk==<span class="number">2</span>) f=<span class="number">1</span>;</span><br><span class="line">dp[i][j][kk]=max(dp[i][j][kk],dp[i<span class="number">-1</span>][j][kk]+f);<span class="comment">//不换</span></span><br><span class="line"><span class="keyword">int</span> tt=(a[i]<span class="number">-1</span>+<span class="number">3</span>)%<span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span>(j&gt;=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(tt==kk) <span class="keyword">continue</span>;<span class="comment">//不换..对身体好 </span></span><br><span class="line">dp[i][j][tt]=max(dp[i][j][tt],dp[i<span class="number">-1</span>][j<span class="number">-1</span>][kk]+<span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxx=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>;i++) maxx=max(maxx,dp[n][k][i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,maxx);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("game.in","r",stdin);</span></span><br><span class="line"><span class="comment">//freopen("game.out","w",stdout);</span></span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p>为补贴家用，小 M 终于谋得一份兼职——牛奶销售员。<br>小 M 打算把牛奶销售到 N 个城市，这 N 个城市编号为 1..N。这些城市<br>之间有 R 条高速公路和 P 条泥泞小道连接。每条高速路或泥泞小道连接 N<br>个城市中的 A 和 B， 需要的花费为 C，对于高速路的花费 C， 一定是大于等<br>于 0 的；然而对于泥泞小道，由于边远城市的人民感谢送奶工的辛劳，会<br>额外付更多的奶钱， 所以有些小道的花费可能为负数（表示有收益）。高速<br>公路是双向的，可以从 A 走到 B，也可以从 B 走到 A；然后泥泞小道则不是<br>双向的，只能从 A 走到 B。事实上， 由于泥泞道路经过的都是蛮荒之地，所<br>以政府为了社会和谐，出台了一些政策保证： 如果一条泥泞小道可以从 A<br>到 B，那么保证不可能通过高速路或泥泞小道从 B 再回到 A。<br>小 M 的销售中心在城市 S，现在他想知道，把牛奶从 S 送到每个城市的<br>最小花费的，或者根本就不能送到。</p><h2 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h2><p>输入文件名为 sales.in。<br>输入的第 1 行包含四个空格隔开的整数: N, R, P 和 S，他们的意义如题<br>目描述。 第 2 到 R+1 行每行含三个空格隔开的整数： A, B 和 C，表示一条高<br>速公路双向连接城市 A 和 B，需要的花费为 C。 第 R+2 到 R+P+1 行每行包含<br>三个空格隔开的整数： A, B 和 C，表示一条泥泞小道可以从城市 A 到 B，需<br>要的花费为 C。</p><h2 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h2><p>输出文件名为 sales.out。<br>输出有 N 行，每行一个整数，第 i 行表示从 S 到达城市 i 的最小花费，<br>如果不存在输出”NO PATH”。</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h3><p>6 3 3 4<br>1 2 5<br>3 4 5<br>5 6 10<br>3 5 -100<br>4 6 -100<br>1 3 -10</p><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h3><p>NO PATH<br>NO PATH<br>5<br>0<br>-95<br>-100</p><h2 id="Hint-1"><a href="#Hint-1" class="headerlink" title="Hint"></a>Hint</h2><p>对于 30%的数据： N≤10 000<br>对于 100%的数据： 1≤N≤25,000 , 1≤P,R≤50,000<br>高速公路的 C： 0≤C≤10,000<br>泥泞小道的 C： -10,000≤C≤10,000</p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><p>这道题真的傻缺了啊qwq，别人想的是有负权边不能跑dij，我tm想的是没有负环直接跑dij，感觉复杂度差不多就直接交上去了哇qwq。实际上你的复杂度超乎你想象。<br><strong>开始正经：</strong><br>这道题有两种解法：<br>1.spfa+slf优化，好像勉强过得到？直接用双端队列deque维护一下。slf优化还是能加就加吧，毕竟挺简单的。不过关于spfa，<font color="red"><del>它已经死了.</del></font>所以稳妥一点还是用dij吧，对身体好a.<br>2.dij+缩点+拓扑：woc这个思路真的很nice啊，首先发现可以缩点连成一个DAG图，然后对于每个联通块单独跑dij，这样算下来总复杂度也就nlogn左右（事实证明真的跑得飞快！法1时间几乎是它的十倍）.然后就是注意细节的实现，也为这种<strong>混合图</strong>提供了一种思路。当把所有的入边处理完之后用vector记录入点，就可以队首存入多个起点，一次dij跑完，复杂度被大大减少.（可以回顾noip2017逛公园）.</p><p>上代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 25005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxm 150005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eage</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to,next,len;</span><br><span class="line">&#125;e[maxm];</span><br><span class="line"><span class="keyword">int</span> np=<span class="number">0</span>,first[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">e[++np]=(eage)&#123;v,first[u],len&#125;;</span><br><span class="line">first[u]=np;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,r,p,s,x,y,z,dfn[maxn],low[maxn],belong[maxn],cc=<span class="number">0</span>,clock_=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> st[maxn],top=<span class="number">0</span>,rd[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;g[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">noded</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> from,to,len;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;noded&gt;b[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">vis[i]=<span class="number">1</span>;</span><br><span class="line">st[++top]=i;</span><br><span class="line">low[i]=dfn[i]=++clock_;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> p=first[i];p;p=e[p].next)&#123;</span><br><span class="line"><span class="keyword">int</span> j=e[p].to;</span><br><span class="line"><span class="keyword">if</span>(vis[j])&#123;</span><br><span class="line"><span class="keyword">if</span>(!belong[j]) low[i]=min(low[i],dfn[j]);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">dfs(j,i);</span><br><span class="line">low[i]=min(low[i],low[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(low[i]==dfn[i])&#123;</span><br><span class="line">    cc++;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> t=st[top--];</span><br><span class="line">    belong[t]=cc;</span><br><span class="line">    <span class="keyword">if</span>(t==i) <span class="keyword">break</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dist[maxn];</span><br><span class="line"><span class="keyword">bool</span> viss[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> v,id;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(node a,node b)&#123;</span><br><span class="line"><span class="keyword">return</span> a.v&gt;b.v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dij</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    priority_queue&lt;node&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g[s].size();i++)&#123;</span><br><span class="line"><span class="keyword">int</span> t=g[s][i];</span><br><span class="line">q.push((node)&#123;dist[t],t&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">node t=q.top();q.pop();</span><br><span class="line"><span class="keyword">int</span> i=t.id;</span><br><span class="line"><span class="keyword">if</span>(viss[i]) <span class="keyword">continue</span>;</span><br><span class="line">viss[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> p=first[i];p;p=e[p].next)&#123;</span><br><span class="line"><span class="keyword">int</span> j=e[p].to,c=e[p].len;</span><br><span class="line"><span class="keyword">if</span>(belong[j]!=belong[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(dist[j]&gt;dist[i]+c)&#123;</span><br><span class="line">dist[j]=dist[i]+c;</span><br><span class="line">q.push((node)&#123;dist[j],j&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;qq;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(viss,<span class="number">0</span>,<span class="keyword">sizeof</span>(viss));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dist[i]=<span class="number">1000000007</span>;</span><br><span class="line">g[belong[s]].push_back(s);</span><br><span class="line">dist[s]=<span class="number">0</span>;</span><br><span class="line">qq.push(belong[s]);</span><br><span class="line"><span class="keyword">while</span>(!qq.empty())&#123;</span><br><span class="line">   <span class="keyword">int</span> i=qq.front();qq.pop();</span><br><span class="line">   dij(i);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;b[i].size();j++)&#123;</span><br><span class="line">   noded tt=b[i][j];</span><br><span class="line">   <span class="keyword">int</span> t1=tt.from,t2=tt.to,c=tt.len;</span><br><span class="line">   dist[t2]=min(dist[t2],dist[t1]+c);</span><br><span class="line">   g[belong[t2]].push_back(t2);</span><br><span class="line">   rd[belong[t2]]--;</span><br><span class="line">   <span class="keyword">if</span>(rd[belong[t2]]==<span class="number">0</span>) qq.push(belong[t2]);</span><br><span class="line">   &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dist[i]==<span class="number">1000000007</span>) <span class="built_in">printf</span>(<span class="string">"NO PATH\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dist[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> p=first[i];p;p=e[p].next)&#123;</span><br><span class="line"><span class="keyword">int</span> j=e[p].to;</span><br><span class="line"><span class="keyword">if</span>(belong[j]!=belong[i])&#123;</span><br><span class="line"><span class="comment">//g[belong[i]].push_back(belong[j]);</span></span><br><span class="line">b[belong[i]].push_back((noded)&#123;i,j,e[p].len&#125;);</span><br><span class="line">rd[belong[j]]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">work();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;r,&amp;p,&amp;s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=r;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">add(x,y,z);</span><br><span class="line">add(y,x,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=p;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">add(x,y,z);</span><br><span class="line">&#125;</span><br><span class="line">dfs(s,<span class="number">0</span>);</span><br><span class="line">run();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><h2 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h2><p>小 Y 同学手上有两类线段，分别为 A 线段和 B 线段。<br>A 线段的有n种，第i种有$s_i$条，其左端点和右端点为$a_i$和$b_i$，他们都是109<br>范围内的正整数，且一定有$a_i$ ≤ $b_i$。 B 线段的有m种，第i种有$k_i$条，其左端<br>点和右端点为$l_i$和$r_i$，他们也是109范围内的正整数，且一定有$l_i$ ≤$r_i$。 小 Y<br>还规定，如果一条 A 线段($a_i$, $b_i$)能匹配一条 B 线段($l_i$, $r_i$)，当且仅当$l_i$ ≤ $a_i$≤<br>$b_i$ ≤ $r_i$。<br>现在小 Y 需要你判断能否为所有的 A 线段都指定一条与之匹配的 B 线段。<br>注意，无论是 A 线段还是 B 线段，每条都只能匹配一次，且仅能匹配一次。</p><h2 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h2><p>输入文件名为 machine.in<br>输入的第 1 行是一个整数T，表示数据组数。每组数据的第 1 行有两个<br>整数n, m，分别表 A 类线段和 B 类线段的种类数。接下来n行，每行 3 个整<br>数ai、 bi、 si，描述一种 A 类线段。接下来 m 行，每行三个整数li、 ri、 ki，<br>描述一种 B 类线段。</p><h2 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h2><p>输入文件名为 machine.out<br>仅输出共T行，每行一个字符串，若可以实现则输出 Yes，否则输出<br>No。</p><h2 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>3<br>2 2<br>1 4 2<br>3 5 1<br>1 4 2<br>2 5 1<br>3 2<br>1 3 1<br>2 4 1<br>3 5 1<br>1 3 2<br>2 5 1<br>2 2<br>1 2 2<br>1 2 1<br>1 2 1<br>1 2 2</p><h2 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>Yes<br>No<br>Yes</p><h2 id="Hint-2"><a href="#Hint-2" class="headerlink" title="Hint"></a>Hint</h2><p>对于所有数据保证有：<br>1 ≤ $s_i$, $k_i$ ≤ 109，<br>1 ≤ t≤ 50，<br>1 ≤ n, m ≤ 50000。<br>一个测试点中，所有n的和不超过 4000000，所有m的和也不超过 4000000。</p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><p>还是一道套路题a，用set维护直接nlognA了啊（没办法蒟蒻太蒻了）。稍微注意线段维护的细节，按照左端点排序，相同排右端点。然后用两个指针维护，对于每个i，将l小于等于它的加入到multiset里面（以右端点为关键字）然后每次lower_bound找一下就欧克了啊qwq.<br>(勉哥说对于每个被删掉的指针要查询它的下一个必须要预先处理好)</p><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>线段类的有很多问题可以总结a….上一次居然被那个线段贪心给卡了qwq(处理不重叠的最多线段)就是右端点排个序，左端点大的就可以加进去，贪贪贪</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 50005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r,w;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(node a,node b)&#123;</span><br><span class="line"><span class="keyword">if</span>(a.l!=b.l)<span class="keyword">return</span> a.l&lt;b.l;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> a.r&lt;b.r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;nda[maxn],ndb[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">noded</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> r,w;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(noded a,noded b)&#123;</span><br><span class="line"><span class="keyword">return</span> a.r&lt;b.r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">multiset</span>&lt;noded&gt;s;</span><br><span class="line"><span class="built_in">multiset</span>&lt;noded&gt;::iterator it,itt;</span><br><span class="line"><span class="keyword">int</span> t,n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;nda[i].l,&amp;nda[i].r,&amp;nda[i].w);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;ndb[i].l,&amp;ndb[i].r,&amp;ndb[i].w);</span><br><span class="line">sort(nda+<span class="number">1</span>,nda+n+<span class="number">1</span>);</span><br><span class="line">sort(ndb+<span class="number">1</span>,ndb+m+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">s.clear();</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">1</span>;<span class="comment">//b的序号 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//a的序号 </span></span><br><span class="line"><span class="keyword">while</span>(j&lt;=m&amp;&amp;ndb[j].l&lt;=nda[i].l) s.insert((noded)&#123;ndb[j].r,ndb[j].w&#125;),j++; </span><br><span class="line">noded tt=(noded)&#123;nda[i].r,<span class="number">0</span>&#125;;</span><br><span class="line">    it=s.lower_bound(tt);</span><br><span class="line"><span class="keyword">if</span>(it==s.end()) &#123;<span class="built_in">printf</span>(<span class="string">"No\n"</span>);<span class="keyword">return</span>;&#125; </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">noded t=*it; s.erase(it);</span><br><span class="line"><span class="keyword">if</span>(t.w&gt;=nda[i].w)&#123;t.w-=nda[i].w,nda[i].w=<span class="number">0</span>,s.insert((noded)&#123;t.r,t.w&#125;);<span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">else</span> nda[i].w-=t.w;</span><br><span class="line">it=s.lower_bound(tt);</span><br><span class="line"><span class="keyword">if</span>(it==s.end())  &#123;<span class="built_in">printf</span>(<span class="string">"No\n"</span>);<span class="keyword">return</span>;&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> noip模拟赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> dijsktra </tag>
            
            <tag> spfa </tag>
            
            <tag> slf优化 </tag>
            
            <tag> 缩点 </tag>
            
            <tag> 拓扑 </tag>
            
            <tag> DAG图 </tag>
            
            <tag> set </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>noip模拟赛1</title>
      <link href="/2018/10/17/12/"/>
      <url>/2018/10/17/12/</url>
      
        <content type="html"><![CDATA[<h1 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>每天中午，美丽的重庆一中都会上演一场华丽的千人大竞走。<br>大量人流短时间涌进第二食堂， 食堂班长小 H 表示不淡定了，他必须合<br>理安排饭堂饭菜的价格，来让同学们有愉快的心情就餐。已知第一饭堂饭菜的价格是有 N 位数字的整数，如果一个价格有不小于<br>K（1≤K≤N） 个数位完全相同，那么这个价格就被认为是漂亮的，否则这<br>个价格被认为是不漂亮的。 小 H 想改变其中一个饭菜价格，改变价格中的<br>一位数字需要花费一些钱， 钱数等于改前和改后的数字之差的绝对值。<br>小 H 希望你能把这个价格改地漂亮，求出最小花费，同时给出字典序最<br>小的修改方案。</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>输入文件名为 canteen.in。<br>输入的第一行两个空格隔开的数字 N 和 K(1≤K≤N)。 第二行是一个长<br>度为 N 位的数字， 表示原来的价格。</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>输出文件名为 canteen.out。<br>输出包含两行，第一行一个整数， 表示最小费用。 第二行是字典序最<br>小的方案。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><p>6 5<br>889696</p><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><p>4<br>888688</p><h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><p>对于 30%的数据： N≤10<br>对于 100%的数据： N≤100 000</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>比较水的一道贪心a，只是要注意细节，维护两个东西：最小费用和最小字典序。<br>显然最小费用优先级更大。我们枚举相同的k个数字从0到9，对于每一个确定的st,<br>用i=0~9依次考虑变的数字，注意先执行st+i，再执行st-i以保证字典序最优。<br>然后对于小于st的从后往前改，大于st的从前往后改来保证字典序。</p><h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4><p>（想好细节,think twice,code once）<br>上代码：</p><h2 id="The-Code"><a href="#The-Code" class="headerlink" title="The Code"></a>The Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">char</span> ss[maxn];</span><br><span class="line"><span class="keyword">char</span> tt[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> minn=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> yb[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> calc[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(tt[i]&lt;ss[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(tt[i]&gt;ss[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cnt[s[i]-<span class="string">'0'</span>]++,ss[i]=<span class="string">'9'</span>;<span class="comment">//最大化 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> st=<span class="number">0</span>;st&lt;=<span class="number">9</span>;st++)&#123;</span><br><span class="line"><span class="keyword">int</span> t=k;<span class="comment">//要变的个数 </span></span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;<span class="comment">//要花的钱 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt[st]&gt;=t) <span class="keyword">break</span>;</span><br><span class="line">t-=cnt[st];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> t1=st+i,t2=st-i;</span><br><span class="line"><span class="keyword">if</span>(t1&lt;=<span class="number">9</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt[t1]&gt;=t)&#123;ans+=t*i;<span class="keyword">break</span>;&#125;</span><br><span class="line">t-=cnt[t1];ans+=cnt[t1]*i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t2&gt;=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt[t2]&gt;=t)&#123;ans+=t*i;<span class="keyword">break</span>;&#125;</span><br><span class="line">t-=cnt[t2];ans+=cnt[t2]*i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">minn=min(minn,ans);</span><br><span class="line">    calc[st]=ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> st=<span class="number">0</span>;st&lt;=<span class="number">9</span>;st++)&#123;</span><br><span class="line"><span class="keyword">if</span>(calc[st]==minn)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) tt[i]=s[i];</span><br><span class="line"><span class="built_in">memset</span>(yb,<span class="number">0</span>,<span class="keyword">sizeof</span>(yb));</span><br><span class="line"><span class="keyword">int</span> t=k;<span class="comment">//要变的个数 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt[st]&gt;=t) <span class="keyword">break</span>;</span><br><span class="line">t-=cnt[st];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> t1=st+i,t2=st-i;</span><br><span class="line"><span class="keyword">if</span>(t1&lt;=<span class="number">9</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt[t1]&gt;=t)&#123;yb[t1]=t;<span class="keyword">break</span>;&#125;</span><br><span class="line">t-=cnt[t1];yb[t1]=cnt[t1];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t2&gt;=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt[t2]&gt;=t)&#123;yb[t2]=t;<span class="keyword">break</span>;&#125;</span><br><span class="line">t-=cnt[t2];yb[t2]=cnt[t2];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(yb[i])&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;st)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="keyword">if</span>(s[j]==(i+<span class="string">'0'</span>)) <span class="keyword">if</span>(yb[i])tt[j]=st+<span class="string">'0'</span>,yb[i]--; <span class="keyword">else</span>&#123;<span class="keyword">break</span>;&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=n;j&gt;=<span class="number">1</span>;j--) <span class="keyword">if</span>(s[j]==(i+<span class="string">'0'</span>)) <span class="keyword">if</span>(yb[i])tt[j]=st+<span class="string">'0'</span>,yb[i]--; <span class="keyword">else</span>&#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cmp()) <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ss[i]=tt[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,minn);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%c"</span>,ss[i]);</span><br><span class="line">    <span class="comment">/*memset(dp,0x3f,sizeof(dp));</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;=9;i++) dp[0][i]=0;</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">    for(int j=1;j&lt;=min(i,k);j++)</span></span><br><span class="line"><span class="comment">    for(int kk=1;kk&lt;=9;kk++)&#123;</span></span><br><span class="line"><span class="comment">    dp[j][kk]=min(dp[j][kk],dp[j-1][kk]+abs(s[i]-'0'-kk)); </span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    int minn=0x3f3f3f3f;</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;=9;i++) minn=min(minn,dp[k][i]);</span></span><br><span class="line"><span class="comment">    printf("%d",minn);*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("canteen.in","r",stdin);</span></span><br><span class="line"><span class="comment">//freopen("canteen.out","w",stdout);</span></span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h1><h2 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h2><p>小 M 新设计了一款战略游戏。<br>游戏的地图包含有 N 个阵地（用 1..N 编号），用 N-1 条战略交通线把它<br>们连接起来， 地图中任意两个阵地都能直接或间接地相互到达。 小 M 为每<br>条交通线设定一个名为“战略重要性”的参数，它是一个正整数，且这个<br>数值越大，说明这条交通线的战略重要性越大。 小 M 还设计了一个阵地间<br>的“战略相关性”的度量标准， 那就是两个阵地间路径上“战略重要性”<br>最小的交通线。<br>小 M 已经完成了游戏大多数模块的代码， 还有一个在线查询模块没有完<br>成，即对于用户查询： k， v，表示查询与阵地 v“战略相关性” 不小于 k 的<br>阵地的数目。<br>由于小 M 还要负责游戏的推广， 所以这个查询模块的代码就交给你了。</p><h2 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h2><p>输入文件名为 strategy.in。<br>第一行输入包含 N 和 Q。 接下来的 N-1 行描述地图中的交通线。 每行<br>包括三个整数 pi,qi 和 ri ( 1≤pi,qi≤N， ri&lt;=1000000000 )，表示阵地 pi 和 qi<br>的战略重要性为 ri 。接下来的 Q 行描述了 Q 次查询。 每行包含两个整数，<br>k 和 v (1≤k≤1,000,000,000, 1≤v≤N )，表示一次查询。</p><h2 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h2><p>输出文件名为 strategy.out。<br>输出 Q 行。在第 i 行输出第 i 次查询的的答案。</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h3><p>4 3<br>1 2 3<br>2 3 2<br>2 4 4<br>1 2<br>4 1<br>3 1</p><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h3><p>3<br>0<br>2</p><h2 id="Hint-1"><a href="#Hint-1" class="headerlink" title="Hint"></a>Hint</h2><p>对于 20%的数据： N,Q≤3 00<br>对于 50%的数据： N,Q≤5 000<br>对于 100%的数据： N,Q≤100 000</p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h2><p>首先会想到离线处理，再根据单调性，想到用并查集维护，将大于等于k的边所连接的点加入并查集，<br>这样对于每个联通块，其中任意两点都是符合“战略相关性”大于等于k的，所以对于每个询问，答案<br>就是v所在联通块点个数减1即可。</p><p>上代码：</p><h2 id="The-Code-1"><a href="#The-Code-1" class="headerlink" title="The Code"></a>The Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eage</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> u,v,len;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(eage a,eage b)&#123;</span><br><span class="line"><span class="keyword">return</span> a.len&gt;b.len;</span><br><span class="line">&#125;</span><br><span class="line">&#125;e[maxn];</span><br><span class="line"><span class="keyword">int</span> np=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,q,x,y,z,fa[maxn],sz[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> id,k,v,ans;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(node a,node b)&#123;</span><br><span class="line"><span class="keyword">return</span> a.k&gt;b.k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;nd[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(fa[i]==i) <span class="keyword">return</span> i;</span><br><span class="line"><span class="keyword">int</span> root=find(fa[i]);</span><br><span class="line">fa[i]=root;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fx=find(x),fy=find(y);</span><br><span class="line"><span class="keyword">if</span>(fx!=fy)&#123;</span><br><span class="line">fa[fx]=fy;</span><br><span class="line">sz[fy]+=sz[fx];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fx=find(x),fy=find(y);</span><br><span class="line"><span class="keyword">if</span>(fx!=fy) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i]=i,sz[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">e[++np]=(eage)&#123;x,y,z&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;nd[i].k,&amp;nd[i].v);nd[i].id=i;</span><br><span class="line">&#125;</span><br><span class="line">sort(e+<span class="number">1</span>,e+np+<span class="number">1</span>);sort(nd+<span class="number">1</span>,nd+q+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j&lt;=np&amp;&amp;e[j].len&gt;=nd[i].k)&#123;</span><br><span class="line">link(e[j].u,e[j].v);</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">nd[i].ans=sz[find(nd[i].v)]<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">sort(nd+<span class="number">1</span>,nd+q+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,nd[i].ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h1><h2 id="Description-2"><a href="#Description-2" class="headerlink" title="Description"></a>Description</h2><p>小 Y 正用图章和颜料在草稿纸上乱涂颜色。对于数学敏感的他，突然发<br>现这是一个有意思的数学问题：<br>给出有 N 个格子的纸、宽度为 K 个格子的图章和 M 种不同的颜色，每<br>次用图章把纸上连续的 K 个格子上染任意一种颜色，最后把纸涂满，那么<br>小 Y 想知道最后纸上的颜色序列有多少种不同的情况？</p><h2 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h2><p>输入文件名为 paint.in<br>输入数据仅一行，包含三个整数 N,M,K，他们中间用一个空格分开，分<br>别表示纸张的长度，颜色数目和图章的宽度。</p><h2 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h2><p>输入文件名为 paint.out<br>输出文件仅一行，一个非负整数，表示答案。这个数可能很大，请模<br>1000000007 后输出。</p><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input"></a>Sample Input</h3><p>3 2 2</p><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output"></a>Sample Output</h3><p>6</p><h2 id="Hint-2"><a href="#Hint-2" class="headerlink" title="Hint"></a>Hint</h2><p>对于 20%的数据 N,M,K≤5<br>对于 50%的数据 N,K≤1 000<br>对于 100%的数据 N,M,K≤10 000 000</p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h2><p>真的是数学问题吗？？？首先要明白一点，合法的是要求至少有一个长度为K的相同颜色的块。（这个都没有想出来我好蒻A qwq）<br>然后正难则反，我们只要求出不合法的总个数，然后用总的方法数减去不合法的即为合法的方案数，那么这里用dp,设f[i]为前i个<br>不合法的方案数，那么就不会出现连续k个，所以：<br>$f[i]=f[i-1] \ast m （i&lt;k）​$</p><p>$f[i]=(f[i-1]+f[i-2]+…+f[i-k+1]) \ast (m-1) (i&gt;=k)$  第i个和第i-k个必须不一样<br>再简单加个滑动窗口就可以O(n)过了233333</p><h3 id="tips-1"><a href="#tips-1" class="headerlink" title="tips"></a>tips</h3><p>题目中有mod的话，一般不是dp就是数学（套路！！！）<br>上代码：</p><h2 id="The-Code-2"><a href="#The-Code-2" class="headerlink" title="The Code"></a>The Code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line">ll dp[maxn];</span><br><span class="line"><span class="function">ll <span class="title">qkpow</span><span class="params">(ll t,<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pos==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(pos==<span class="number">1</span>) <span class="keyword">return</span> t%mod;</span><br><span class="line">ll tt=qkpow(t,pos/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(pos&amp;<span class="number">1</span>) <span class="keyword">return</span> tt*tt%mod*t%mod;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> tt*tt%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">ll all=qkpow(m,n);</span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">ll sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;i++) dp[i]=dp[i<span class="number">-1</span>]*m%mod,sum=(sum+dp[i])%mod;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;=n;i++)&#123;</span><br><span class="line">dp[i]=(sum)*(m<span class="number">-1</span>)%mod;</span><br><span class="line">sum=(sum+dp[i]-dp[i-k+<span class="number">1</span>]+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line">ll ans=(all-dp[n]+mod)%mod;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结：总结套路a鸽子，多想想那些大佬是怎么思考的。（think-twice-code-once）"><a href="#小结：总结套路a鸽子，多想想那些大佬是怎么思考的。（think-twice-code-once）" class="headerlink" title="小结：总结套路a鸽子，多想想那些大佬是怎么思考的。（think twice,code once）"></a>小结：总结套路a鸽子，多想想那些大佬是怎么思考的。（think twice,code once）</h3>]]></content>
      
      
      <categories>
          
          <category> noip模拟赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> dp </tag>
            
            <tag> 数学 </tag>
            
            <tag> 离线 </tag>
            
            <tag> 正难则反 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>祎隋</title>
      <link href="/2018/10/16/11/"/>
      <url>/2018/10/16/11/</url>
      
        <content type="html"><![CDATA[<p><font size="6" color="pink">童话，被同化前做过的梦</font><br>《祎隋》</p><p>我们因多少人孤单</p><p>又有多少人为我们不安</p><p>等待是漫长的表演</p><p>相安是莫大的荒诞</p><p>为搏那一瞬笑颜 熹光几点</p><p>我们敢于冒险 心怀本愿</p><p>却屡次三番 无法实现</p><p>使得停滞不前 初心淡暗</p><p>何时起相顾无言 仿佛就从昨天</p><p>再忆那春风不及的笑脸 已是许久以前</p><p>颔首 低眉 轻笑 每个瞬间</p><p>浅唱 微吟 翩舞 总拨心弦</p><p>可我没有华丽诗篇 没有道貌伟岸</p><p>只有痴心一片 闲心几点</p><p>忽而悄然自言 你可曾是我心中的四月天？</p><p>回神漠然 青春已半</p><p>不如数月以前 我们未曾相见</p><p>窗沿 雨 雷电 深夜未眠</p><p>愿初心不变 心境自然</p><p>虽喜忧掺半 往前仍是少年</p><p><img src="https://i.loli.net/2018/11/06/5be1a2867afb7.jpg" alt="小鞠1"></p>]]></content>
      
      
      <categories>
          
          <category> 杂诗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂诗 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CF350E Wrong Floyd</title>
      <link href="/2018/10/16/10/"/>
      <url>/2018/10/16/10/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给定n个点,m条边以及k个标记点，要求进行Floyd时只以标记的点为中间点进行松弛操作（每条边边权为1）要求你造出m条边的数据来hack掉这种程序。</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>3&lt;=n&lt;=300 , 2&lt;=k&lt;=n2&lt;=k&lt;=n , n-1&lt;=m&lt;=n*(n-1)/2;</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>我们只需要任意一点只和非标记点连边就可以了（这样就无法正确更新它到其他点的距离）</p><p>具体一下几个细节：</p><p>1.判k==n或m&gt;最多可以构出的边maxm；</p><p>maxm=(n-1)*(n-2)/2+num;（num:非标记点的数量）</p><p>2.将随便一个标记点与所以非标记点连边；</p><p>3.再随便一个非标记点与未加入图中的点连边来保证图的联通；</p><p>4.最后随便加未加的边使边数凑够m即可；</p><h1 id="The-Code"><a href="#The-Code" class="headerlink" title="The Code"></a>The Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 310</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k,x,num;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn],iss[maxn][maxn],viss[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) iss[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x),vis[x]=<span class="number">1</span>;</span><br><span class="line">    num=n-k;</span><br><span class="line">    <span class="keyword">int</span> maxx=(n<span class="number">-1</span>)*(n<span class="number">-2</span>)/<span class="number">2</span>+num;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;maxx||k==n)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1"</span>);<span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">int</span> t,tt=<span class="number">1</span>;<span class="keyword">int</span> calc=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!vis[tt]) tt++; </span><br><span class="line">    viss[tt]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            t=i;</span><br><span class="line">            viss[t]=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,t,tt);</span><br><span class="line">            iss[t][tt]=iss[tt][t]=<span class="number">1</span>;</span><br><span class="line">            calc++; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//保证联通 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(viss[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,i,t); </span><br><span class="line">        iss[i][t]=iss[t][i]=<span class="number">1</span>;</span><br><span class="line">        calc++;</span><br><span class="line">        <span class="keyword">if</span>(calc==m) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(calc==m) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(i==tt) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==tt) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(iss[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,i,j);</span><br><span class="line">            calc++;</span><br><span class="line">            iss[i][j]=iss[j][i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(calc==m) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>32.Sort</title>
      <link href="/2018/10/16/9/"/>
      <url>/2018/10/16/9/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>众所周知，排序方法有许多种。例如：简单易懂的冒泡排序，平均复杂度较优的快速排序，以及不基于比较的基数排序等等。</p><p>现在，小 DD 得到了一个自然数序列 {a1,a2,⋯,an}{a1,a2,⋯,an}。他想要对其按照从小到大的顺序进行排序（即使得每个元素均严格不大于他的后继元素）。但由于基于比较的排序算法复杂度下界已经被证明为 Θ(nlog2n)Θ(nlog2⁡n)，所以小 DD 决定尝试一种全新的排序算法：翻转排序。</p><p>在翻转排序中，小 DD 在每次操作中，可以选择一个区间 [l,r][l,r] (1≤l≤r≤n)(1≤l≤r≤n)，并翻转 al,al+1,⋯,aral,al+1,⋯,ar。即，在该次操作完后，序列将会变为 a1,a2,⋯,al−1,ar,ar−1,⋯,al+1,al,ar+1,ar+2,⋯,ana1,a2,⋯,al−1,ar,ar−1,⋯,al+1,al,ar+1,ar+2,⋯,an。</p><p>例如，对于序列 [1,6,2,4,3,5][1,6,2,4,3,5]，若选择区间 [2,4][2,4] 进行翻转，则将会得到 [1,4,2,6,3,5][1,4,2,6,3,5]。</p><p>定义一次操作的代价为 r−l+1r−l+1，即翻转的区间长度。定义一个操作序列的代价为每次操作的代价之和。现在，请你帮助小 DD 求出一个代价足够小的操作序列（你并不一定要求出代价最小的操作序列）。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行一个正整数 nn，表示序列长度。</p><p>第二行 nn 个空格隔开的非负整数，表示小 DD 得到的自然数序列 a1,a2,⋯,ana1,a2,⋯,an。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>输出若干行，每行两个空格隔开的正整数 l,rl,r (1≤l≤r≤n)(1≤l≤r≤n)，表示一次翻转区间 [l,r][l,r] 的操作。</p><p>最后输出一行 -1 -1，标志着操作序列的结束。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>4 1 3 2 4</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>2 3 -1 -1</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>1.下发文件中提供了 checker.cpp，该程序将对于其所在目录下的 sort.in，判断其所在目录下的 sort.out 是否为一个正确的操作序列。若正确，将给出该操作序列的代价。若不正确，将给出错误信息。选手可以借助该程序来更好地检查自己的程序是否正确。</p><p>运行时，必须保证 sort.in 为一个合法的输入，且需保证 sort.out 符合题目中描述的输出格式，否则出现任何结果均有可能。</p><p>2.对于所有测试数据，保证 1≤n≤500001≤n≤50000，且 0≤ai≤1090≤ai≤109。</p><p>（附checker.cpp）<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">50005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fin = fopen(<span class="string">"sort.in"</span>, <span class="string">"r"</span>), *fout = fopen(<span class="string">"sort.out"</span>, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fin)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"INVALID : File sort.in not found."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!fout)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"INVALID : File sort.out not found."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">fscanf</span>(fin, <span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">fscanf</span>(fin, <span class="string">"%d"</span>, arr + i);</span><br><span class="line">    <span class="keyword">int</span> l, r, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">fscanf</span>(fout, <span class="string">"%d%d"</span>, &amp;l, &amp;r))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="number">-1</span> &amp;&amp; r == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        sum += r - l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= <span class="number">0</span> || l &gt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"INVALID : l = %d is not in range [1, %d].\n"</span>, l, n);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &lt;= <span class="number">0</span> || r &gt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"INVALID : r = %d is not in range [1, %d].\n"</span>, r, n);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"INVALID : %d = l &gt; r = %d.\n"</span>, l, r);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; <span class="number">20000000</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"INVALID : Too much cost."</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::reverse(arr + --l, arr + r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> f = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        f &amp;= arr[i] &gt;= arr[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (!f)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"INVALID : Not sorted."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"VALID : Total cost is %d.\n"</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checker</span><br></pre></td></tr></table></figure></p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>本题算是一个比较新颖的题目，实际上是用这种翻转来模拟实现归并排序:</p><p>先将给定数列进行离散化，每次选定一个中间的数，将小于等于它的排在左边，大于它的排在右边，再依次递归两边就可以了；</p><p>主要是复杂度（进行操作的次数）证明a….    排一遍要n，由于其非01性，所以进行log2n次的n排，故排一遍将l到r以stdd为标准换为左边小于等于stdd，右边大于等于stdd的操作数为Θ(nlog2n) ；</p><p>T(n) = 2T(n/2) + Θ(nlog2n),可以解得 T(n) = Θ(nlog22n) ； tql%%%<br>上代码。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 50005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,pos[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,id;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(node a,node b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.v&lt;b.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;nd[maxn];</span><br><span class="line"><span class="keyword">int</span> stdd;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    run(l,mid);run(mid+<span class="number">1</span>,r);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> L,R;<span class="comment">//要翻转的区间 </span></span><br><span class="line">    L=R=mid;<span class="comment">//L和R的初值 </span></span><br><span class="line">    <span class="keyword">int</span> i=mid,j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=l&amp;&amp;pos[i]&gt;stdd) L=i--;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r&amp;&amp;pos[j]&lt;=stdd) R=j++;</span><br><span class="line">    <span class="keyword">if</span>(L!=R)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,L,R);</span><br><span class="line">        reverse(pos+L,pos+R+<span class="number">1</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid=stdd=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    run(l,r);<span class="comment">//将l到r以stdd为标准换为左边小于等于stdd，右边大于等于stdd</span></span><br><span class="line"> </span><br><span class="line">    msort(l,mid);msort(mid+<span class="number">1</span>,r);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;nd[i].v);nd[i].id=i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(nd+<span class="number">1</span>,nd+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) pos[nd[i].id]=i;<span class="comment">//离散化位置确定 </span></span><br><span class="line">    </span><br><span class="line">    msort(<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-1 -1\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen("sort.in","r",stdin);</span></span><br><span class="line">    <span class="comment">//freopen("sort.out","w",stdout);</span></span><br><span class="line">    init();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Noi.ac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
            <tag> 离散化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数对子</title>
      <link href="/2018/10/16/8/"/>
      <url>/2018/10/16/8/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>我们定义一个数对 (x,y) 是好的，当且仅当 x≤y，且 x xor y的二进制表示下有奇数个 1</p><p>现在给定 nn 个区间 [li,ri]，你需要对于每个 i∈[1,n]，输出有几对好的数 (x,y)满足 x 和 y 都在 [l1,r1]∪[l2,r2]…∪[li,ri]，即两个数都在前 i 个区间的并里</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行一个正整数 n</p><p>接下来 n 行每行两个整数 [li,ri]，表示第 i个区间，保证 li≤ri</p><h1 id="Ouput"><a href="#Ouput" class="headerlink" title="Ouput"></a>Ouput</h1><p>输出 n 行，第 i行一个整数表示有几对好的数 (x,y) 满足 x,y 都在前 i 个区间的并里</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>3</p><p>1 7</p><p>3 10</p><p>9 20</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>12</p><p>25</p><p>100</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>对于 30%30% 的数据，有 1≤n≤1001≤n≤100，1≤li≤ri≤1001≤li≤ri≤100</p><p>对于 50%50% 的数据，有 1≤n≤10001≤n≤1000，1≤li≤ri≤232−11≤li≤ri≤232−1</p><p>对于 100%100% 的数据，有 1≤n≤1051≤n≤105, 1≤li≤ri≤232−11≤li≤ri≤232−1</p><p>时间限制：2s</p><p>空间限制：512MB</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>先补充几个小知识点（快速求出一个数的二进制中有多少个1）:</p><p>x=x&amp;(x-1)（递归求法，适用于单个数）</p><p>表达式的意思就是:把x的二进制表示 从低位开始，将遇到的第一个为1的 二进制位 置0。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> calc=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x) x=x&amp;(x<span class="number">-1</span>),calc++;</span><br><span class="line">calc即为所求值</span><br></pre></td></tr></table></figure><p>求0到x中有多少二进制含1个数为奇数的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">calc</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmp=x,tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp&amp;<span class="number">1</span>)tot++;</span><br><span class="line">        tmp&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (x&gt;&gt;<span class="number">1</span>)+((x&amp;<span class="number">1</span>) || (tot&amp;<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">证明：<span class="number">00</span> <span class="number">01</span> <span class="number">10</span> <span class="number">11</span> <span class="number">100</span> <span class="number">101</span> <span class="number">110</span> <span class="number">111.</span>...继续下去可以发现规律是偶奇奇偶奇偶偶奇....</span><br><span class="line">所以x&gt;&gt;<span class="number">1</span>之前一半的，如果x为奇数（会少算一个）或其本身有奇数个<span class="number">1</span>得加上</span><br></pre></td></tr></table></figure><p>所以说探究性质a老哥(这个性质也可以记住)</p><p>p.s.当线段树叶子节点有n个时，应开总共2^(log2n+1)个点，即2*n个点</p><h2 id="正经题解开始："><a href="#正经题解开始：" class="headerlink" title="正经题解开始："></a>正经题解开始：</h2><p>首先，对于每个数对（x,y）, 若要x xor y的二进制表示下有奇数个 1，则必定一者含奇数个1，一者含偶数个。</p><p>证明：若两个都为奇数，1.则奇减奇等于偶（重叠个数为奇个）2.奇减偶先为奇（重叠个数为偶数个），奇加奇等于偶</p><p>​           若两个都为偶数，则可同上证明</p><p>​           一奇一偶，1.奇减奇等于偶，偶减奇等于奇，奇加偶等于奇2.奇减偶等于奇，偶减偶等于偶，偶加奇等于奇</p><p>所以我们采取线段树来维护区间含奇数个1和含偶数个1的个数，对于区间l,r，则用上述中所介绍的calc函数，来calc(r)-calc(l-1)得到奇数个1个数以及r-l+1-（calc(r)-calc(l-1)）得到偶数个1个数</p><p>每次输入一个区间加进去统计一个区间，然后输出总的相乘即可。p.s.线段树很好的解决了区间相交的问题，在以及统计过的区间标记vis[now]=1;</p><p>上代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll num[maxn&lt;&lt;<span class="number">4</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> lc[maxn&lt;&lt;<span class="number">4</span>],rc[maxn&lt;&lt;<span class="number">4</span>],rt=<span class="number">0</span>,np=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn&lt;&lt;<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upload</span><span class="params">(<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    num[now][<span class="number">0</span>]=num[lc[now]][<span class="number">0</span>]+num[rc[now]][<span class="number">0</span>];</span><br><span class="line">    num[now][<span class="number">1</span>]=num[lc[now]][<span class="number">1</span>]+num[rc[now]][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll t=x,tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t&amp;<span class="number">1</span>)tot++;</span><br><span class="line">        t&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (x&gt;&gt;<span class="number">1</span>)+((x&amp;<span class="number">1</span>) || (tot&amp;<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;now,ll l,ll r,ll x,ll y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!now) now=++np;</span><br><span class="line">    <span class="keyword">if</span>(vis[now]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=x&amp;&amp;r&lt;=y)&#123;</span><br><span class="line">        num[now][<span class="number">1</span>]=calc(r)-calc(l<span class="number">-1</span>);</span><br><span class="line">        num[now][<span class="number">0</span>]=r-l+<span class="number">1</span>-num[now][<span class="number">1</span>];</span><br><span class="line">        vis[now]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(y&lt;=m)update(lc[now],l,m,x,y);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;m)update(rc[now],m+<span class="number">1</span>,r,x,y);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        update(lc[now],l,m,x,y);</span><br><span class="line">        update(rc[now],m+<span class="number">1</span>,r,x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    upload(now);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    ll L,R,mx=<span class="number">1l</span>l&lt;&lt;<span class="number">32</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;L,&amp;R);</span><br><span class="line">        update(rt,<span class="number">1</span>,mx,L,R);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,num[<span class="number">1</span>][<span class="number">0</span>]*num[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二进制 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>祎隋</title>
      <link href="/2018/10/16/7/"/>
      <url>/2018/10/16/7/</url>
      
        <content type="html"><![CDATA[<font size="6" color="pink">愿你像个孩子，愿你心生双翼</font><p>《祎隋》</p><p>青涩</p><p>带着年少初识的忐忑</p><p>我们相遇了</p><p>传奇</p><p>三年来我们所追寻的词字</p><p>一段故事 从这里轻启</p><p>回忆</p><p>忘不却从前往事</p><p>追不上白驹过隙</p><p>再聚</p><p>仿佛多年往复 传奇已铸</p><p>但我们的故事未完待续</p><p>我们的航船才起征途</p><p>愿</p><p>愿相框里的我们永远闪闪发光</p><p>愿你仍是原般模样 </p><p><img src="https://i.loli.net/2018/11/06/5be1a1a390dda.jpg" alt="小鞠"></p>]]></content>
      
      
      <categories>
          
          <category> 杂诗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂诗 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CF351B Jeff and Furik</title>
      <link href="/2018/10/16/6/"/>
      <url>/2018/10/16/6/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给一个1~n的排列p[i]，Jeff先手可以交换任意两个相邻元素，而Furik会有0.5的几率把任意满足p[i] &lt; p[i+1]的p[i]和p[i+1]交换，有0.5的几率把任意满足p[i] &gt; p[i+1]的p[i]和p[i+1]交换，问将整个序列变成升序所需的最小期望步数 </p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行一整数n表示序列长度，之后一个1~n的排列p[i] (1&lt;=n&lt;=3000) </p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>输出把整个序列变成升序所需的最小期望步数 </p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>5<br>3 5 2 4 1</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>13.000000 </p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>考虑E[i]（i为逆序对个数）的最小期望步数，则E[0]=0,E[1]=1;那么每一次Jeff肯定是交换使逆序对减少一个而Furik则有50%减少一个50%增加一个，故$E[i]=1/2<em>(E[i-2]+1)+1/2</em>(E[i-1+1]+1)$;化简得$E[i]=E[i-2]+4$;</p><p>故模拟归并排序求一次逆序对个数便可实现。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 3005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[maxn],t[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> m=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> t1=msort(l,m);</span><br><span class="line">    <span class="keyword">int</span> t2=msort(m+<span class="number">1</span>,r);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t3=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i=l,j=m+<span class="number">1</span>,k=l;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=m&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;a[j])&#123;</span><br><span class="line">            t3+=m-i+<span class="number">1</span>;</span><br><span class="line">            t[k++]=a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            t[k++]=a[i++];<span class="comment">//本来就应该小于 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=m) t[k++]=a[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r) t[k++]=a[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=l;p&lt;=r;p++) a[p]=t[p];<span class="comment">//调整</span></span><br><span class="line">    <span class="keyword">return</span> t1+t2+t3; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">int</span> nd=msort(<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">if</span>(nd&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lf"</span>,(<span class="keyword">double</span>)(<span class="number">2</span>*nd<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lf"</span>,(<span class="keyword">double</span>)<span class="number">2</span>*nd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率期望 </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>卡常数</title>
      <link href="/2018/10/16/5/"/>
      <url>/2018/10/16/5/</url>
      
        <content type="html"><![CDATA[<h1 id="Decription"><a href="#Decription" class="headerlink" title="Decription"></a>Decription</h1><p>（在十进制下）定义 mn(i) 表示把 i 的各位数字从小到大排序得到的数，mx(i) 表示从大到小得到的数。这里的数是允许有前导零的，比如mn(10000)=00001=1 ， mx(132)=321 等。定义 f(i)=mx(i)−mn(i) 。当然，这里 mx(i) 的定义是要在某个整数 k 位十进制数下的。</p><p>卡常数指印度数学家Kaprekar发现的常数 6174 。他发现，任取一个各位数字不全相同的四位数 x，不断地使 x=f(x) ，最终总能得到 6174 。</p><p>现在Fizzydavid学习了高级的卡常数技巧，他想知道对于五位数的情况。他每次会给你一个带前导零的五位数x，要让你求出操作 x=f(x) 进行 c 次之后的结果。他每次给你的 c 都是一样的。此时 f 定义中的 k=5。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行两个整数 T,c 。T 表示询问次数，c 的含义如题面。</p><p>接下来 T 行每行一个五位数 x ，不足五位会加前导零补到五位。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>对于每个询问输出一行表示答案。不足五位需要补到五位。</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>1≤T≤105,1≤c≤109,0≤x&lt;105 。</p><p>20%的数据保证 c≤10 。</p><p>另外20%的数据保证 T≤10 。</p><p>另外30%的数据保证 c≥105 。</p><p>时间限制： 2s</p><p>空间限制： 512MB</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>woc这道题思路很Nice啊。<br>首先会想到肯定每个数进行一定次数之后会循环(不然就没法做了a)。<br>然后这里应该要想到我们对当前的数求循环的时候，我们事实上已经对所有经过的数求出来<br>了，这样稍微处理一下就可以保证每个数只被访问一次。<br>但这样还是会T a。。。<br>于是探究性质：发现对于一个x进行a+b次操作等于先将x进行a次操作，再进行b次操作，或者反过来，再进一步想到可以倍增预处理(Nice啊).这样就欧克了a(注意倍增不要写错a在刷状态的时候QAQ)</p><h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4><p>1.以后遇到这种性质都可以考虑倍增(LCA也有这种性质嘛)<br>2.补充一下姿势（雾<br>%nd 输出的整型宽度至少为n位，右对齐，%5d即宽度至少为5位，位数大于5则输出实际位数<br>%0nd 用得比较多，表示输出的整型宽度至少为n位，不足n位用0填充<br>printf（”%05d”,1）输出：00001<br>printf（”%5d”,1）输出：<em>**</em>1（$*$为空格）</p><h1 id="The-Code"><a href="#The-Code" class="headerlink" title="The Code"></a>The Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,x,c;</span><br><span class="line"><span class="keyword">int</span> g[<span class="number">100005</span>][<span class="number">31</span>],mx,mn,a[<span class="number">7</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&gt;y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">int</span> pos=<span class="number">6</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">    a[--pos]=x%<span class="number">10</span>;x/=<span class="number">10</span>;</span><br><span class="line">&#125; </span><br><span class="line">sort(a+<span class="number">1</span>,a+<span class="number">6</span>);mn=a[<span class="number">1</span>]*<span class="number">10000</span>+a[<span class="number">2</span>]*<span class="number">1000</span>+a[<span class="number">3</span>]*<span class="number">100</span>+a[<span class="number">4</span>]*<span class="number">10</span>+a[<span class="number">5</span>];</span><br><span class="line">sort(a+<span class="number">1</span>,a+<span class="number">6</span>,cmp);mx=a[<span class="number">1</span>]*<span class="number">10000</span>+a[<span class="number">2</span>]*<span class="number">1000</span>+a[<span class="number">3</span>]*<span class="number">100</span>+a[<span class="number">4</span>]*<span class="number">10</span>+a[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">return</span> mx-mn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">99999</span>;i++) g[i][<span class="number">0</span>]=f(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">30</span>;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">99999</span>;i++) g[i][j]=g[g[i][j<span class="number">-1</span>]][j<span class="number">-1</span>]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">31</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;c);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">30</span>;i++) <span class="keyword">if</span>(c&amp;(<span class="number">1</span>&lt;&lt;i)) vis[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">30</span>;j++) <span class="keyword">if</span>(vis[j]) x=g[x][j];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%05d\n"</span>,x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">pre();</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 倍增 </tag>
            
            <tag> 预处理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>树</title>
      <link href="/2018/10/16/4/"/>
      <url>/2018/10/16/4/</url>
      
        <content type="html"><![CDATA[<h1 id="The-Solution"><a href="#The-Solution" class="headerlink" title="The Solution"></a>The Solution</h1><p>emmmmmmmm，这道题题意读错了a，有点难受…很考细节的一道题，同时告诉我们细节题要对拍。<br>首先我们要维护的是最大的剩余空间，但实质上是最大的最近距离，比如区间所剩为5和4，实际上它们的最近距离都为2。在设定友好函数时要注意。<br>在处理好一般操作之后是特判，主要就是对于两端的处理，因为它们是独立成段的(图中红色部分)，所以只要红色长度大于最近距离即更优。<br><del><font color="green">垃圾贴图库炸了，已换图床不会再出现此种情况</font></del><br>最后要注意标号尽可能小的细节。</p><h1 id="The-Code"><a href="#The-Code" class="headerlink" title="The Code"></a>The Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(node a,node b)&#123;</span><br><span class="line"><span class="keyword">if</span>((a.r-a.l)/<span class="number">2</span>!=(b.r-b.l)/<span class="number">2</span>)<span class="keyword">return</span> (a.r-a.l)/<span class="number">2</span>&gt;(b.r-b.l)/<span class="number">2</span>;</span><br><span class="line">  <span class="comment">//排得是这个最近距离aQAQ 并且不能将2免去，因为奇偶 </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> a.l&lt;b.l;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">set</span>&lt;node&gt;s;</span><br><span class="line"><span class="built_in">set</span>&lt;node&gt;::iterator it;</span><br><span class="line"><span class="keyword">int</span> n,m,x,y;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;mp;</span><br><span class="line"><span class="keyword">int</span> pre[maxn],next[maxn],st[maxn],rk[maxn];</span><br><span class="line"><span class="keyword">int</span> np=<span class="number">0</span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">s.insert((node)&#123;<span class="number">0</span>,n+<span class="number">1</span>&#125;);</span><br><span class="line">pre[<span class="number">0</span>]=<span class="number">0</span>;next[<span class="number">0</span>]=n+<span class="number">1</span>;pre[n+<span class="number">1</span>]=<span class="number">0</span>;next[n+<span class="number">1</span>]=n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="comment">/*if(x==1)&#123;</span></span><br><span class="line"><span class="comment">if(t.l==0&amp;&amp;t.r==n+1)&#123;</span></span><br><span class="line"><span class="comment">st[np]=1;</span></span><br><span class="line"><span class="comment">rk[1]=np;</span></span><br><span class="line"><span class="comment">next[0]=1;</span></span><br><span class="line"><span class="comment">next[1]=n+1;</span></span><br><span class="line"><span class="comment">pre[n+1]=1;</span></span><br><span class="line"><span class="comment">s.erase((node)&#123;0,n+1&#125;);</span></span><br><span class="line"><span class="comment">s.insert((node)&#123;0,1&#125;);s.insert((node)&#123;1,n+1&#125;);</span></span><br><span class="line"><span class="comment">printf("1\n");continue;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">if(t.l==1&amp;&amp;t.r==n+1)&#123;</span></span><br><span class="line"><span class="comment">st[np]=n;</span></span><br><span class="line"><span class="comment">rk[n]=np;</span></span><br><span class="line"><span class="comment">pre[n]=1;</span></span><br><span class="line"><span class="comment">next[n]=n+1;</span></span><br><span class="line"><span class="comment">pre[n+1]=n;</span></span><br><span class="line"><span class="comment">next[0]=1;</span></span><br><span class="line"><span class="comment">s.erase((node)&#123;1,n+1&#125;);</span></span><br><span class="line"><span class="comment">s.insert((node)&#123;1,n&#125;);s.insert((node)&#123;n,n+1&#125;);</span></span><br><span class="line"><span class="comment">printf("%d\n",n);continue;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">1</span>)&#123;</span><br><span class="line">mp[y]=++np;</span><br><span class="line">it=s.begin();</span><br><span class="line">node t=*it;</span><br><span class="line"><span class="keyword">int</span> len=(t.r-t.l)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">bool</span> ok1=<span class="literal">false</span>,ok2=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> len1=<span class="number">0</span>,len2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!rk[<span class="number">1</span>]) len1=next[<span class="number">0</span>]<span class="number">-1</span>;<span class="keyword">if</span>(!rk[n]) len2=n-pre[n+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(len2&gt;len1) ok2=<span class="literal">true</span>;<span class="keyword">else</span> ok1=<span class="literal">true</span>;<span class="comment">//标号 </span></span><br><span class="line"><span class="keyword">if</span>(!rk[<span class="number">1</span>]&amp;&amp;ok1)&#123;<span class="comment">//要考虑两端点的问题</span></span><br><span class="line"><span class="keyword">if</span>(next[<span class="number">0</span>]<span class="number">-1</span>&gt;=len)&#123;<span class="comment">//标号优先 </span></span><br><span class="line">st[np]=<span class="number">1</span>;</span><br><span class="line">    rk[<span class="number">1</span>]=np;</span><br><span class="line">    next[<span class="number">1</span>]=next[<span class="number">0</span>];pre[next[<span class="number">0</span>]]=<span class="number">1</span>;next[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    s.erase((node)&#123;<span class="number">0</span>,next[<span class="number">1</span>]&#125;);</span><br><span class="line">    s.insert((node)&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    s.insert((node)&#123;<span class="number">1</span>,next[<span class="number">1</span>]&#125;);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1\n"</span>);<span class="keyword">continue</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!rk[n]&amp;&amp;ok2)&#123;</span><br><span class="line"><span class="keyword">if</span>(n-pre[n+<span class="number">1</span>]&gt;len)&#123;</span><br><span class="line">st[np]=n;</span><br><span class="line">    rk[n]=np;</span><br><span class="line">    pre[n]=pre[n+<span class="number">1</span>];next[pre[n+<span class="number">1</span>]]=n;pre[n+<span class="number">1</span>]=n;</span><br><span class="line">    s.erase((node)&#123;pre[n],n+<span class="number">1</span>&#125;);</span><br><span class="line">    s.insert((node)&#123;n,n+<span class="number">1</span>&#125;);</span><br><span class="line">    s.insert((node)&#123;pre[n],n&#125;);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n);<span class="keyword">continue</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> position=t.l+len;rk[position]=np;st[np]=position;</span><br><span class="line">    pre[position]=t.l;next[position]=t.r;pre[t.r]=position;</span><br><span class="line">  next[t.l]=position;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,position);</span><br><span class="line">s.erase((node)&#123;pre[position],next[position]&#125;); </span><br><span class="line">s.insert((node)&#123;pre[position],position&#125;);</span><br><span class="line">    s.insert((node)&#123;position,next[position]&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> t=st[mp[y]];</span><br><span class="line">s.erase((node)&#123;pre[t],t&#125;);</span><br><span class="line">s.erase((node)&#123;t,next[t]&#125;);</span><br><span class="line">s.insert((node)&#123;pre[t],next[t]&#125;);</span><br><span class="line">rk[t]=<span class="number">0</span>;</span><br><span class="line">next[pre[t]]=next[t];</span><br><span class="line">pre[next[t]]=pre[t];</span><br><span class="line">pre[t]=next[t]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> set </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>减肥计划</title>
      <link href="/2018/10/15/3/"/>
      <url>/2018/10/15/3/</url>
      
        <content type="html"><![CDATA[<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>哇，这道题还是太急了，探究出个性质就直接溜了。<br>首先当$\sum{a_i}$一定时，$\sum{b_i}$越大肯定越优，那么可以dp[i]表示$\sum{a_i}$为i时最大的$\sum{b_i}$之值。<br>由于a的和为$n \ast max({a_i})$，所以总的复杂度会是$n^2 \ast max({a_i})$。显然会超时。<br>所以我们来探求性质，发现当答案为$\frac{\sum{a_i}}{\sum{b_i}}$，若此时有$\frac{a_i}{b_i}$大于它时，那么加入一定会增大，反之加入小于的会减小，所以我们对于一个答案，不断删去小于它的$\frac{a_i}{b_i}$，直到$\sum{a_i}$&lt;m后停下来，那么过程中不会减小，此时再加入大于的即可，所以最多只用dp到$max({a_i})+m$，因此时间复杂度也降为$n \ast (m+max({a_i}))$ ，即可通过此题。</p><p>上代码：</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">ll dp[maxn&lt;&lt;<span class="number">1</span>],a[maxn],b[maxn];</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll x,ll y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(y==<span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> gcd(y,x%y);</span><br><span class="line">&#125;</span><br><span class="line">ll maxx=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a[i],&amp;b[i]),maxx=max(maxx,a[i]),sum+=a[i];</span><br><span class="line"><span class="keyword">if</span>(sum&lt;m)&#123;<span class="built_in">printf</span>(<span class="string">"-1"</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m+maxx;i++) dp[i]=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=maxx+m;j&gt;=a[i];j--) dp[j]=max(dp[j],dp[j-a[i]]+b[i]);</span><br><span class="line"></span><br><span class="line">ll fz=<span class="number">-1</span>,fm=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=m;i&lt;=maxx+m;i++) <span class="keyword">if</span>(fz*i&lt;dp[i]*fm) fz=dp[i],fm=i;</span><br><span class="line">ll g=gcd(fz,fm);</span><br><span class="line">fz/=g;fm/=g;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d/%d"</span>,fz,fm); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> dp </tag>
            
            <tag> 正睿 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>正睿普转提9.16</title>
      <link href="/2018/10/15/14/"/>
      <url>/2018/10/15/14/</url>
      
        <content type="html"><![CDATA[<h2 id="代码记录…"><a href="#代码记录…" class="headerlink" title="代码记录…"></a>代码记录…</h2><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n,fa[maxn],ch[maxn][<span class="number">2</span>],x;</span><br><span class="line">ll st[maxn],a[maxn];</span><br><span class="line"><span class="keyword">int</span> top=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ch[i][<span class="number">0</span>]) dfs(ch[i][<span class="number">0</span>]);</span><br><span class="line">    st[++top]=a[i];</span><br><span class="line">    <span class="keyword">if</span>(ch[i][<span class="number">1</span>]) dfs(ch[i][<span class="number">1</span>]);</span><br><span class="line">&#125; </span><br><span class="line">ll q[maxn];</span><br><span class="line"><span class="keyword">int</span> rear=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*if(x&gt;=q[rear])&#123;</span></span><br><span class="line"><span class="comment">        q[++rear]=x;</span></span><br><span class="line"><span class="comment">        return;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    int l=1,r=rear,mid;</span></span><br><span class="line"><span class="comment">    while(l&lt;=r)&#123;</span></span><br><span class="line"><span class="comment">        mid=(l+r)&gt;&gt;1;</span></span><br><span class="line"><span class="comment">        if(q[mid-1]&lt;=x&amp;&amp;x&lt;q[mid])&#123;q[mid]=x;return;&#125;</span></span><br><span class="line"><span class="comment">        if(x&lt;q[mid-1]) r=mid-1;</span></span><br><span class="line"><span class="comment">        else l=mid+1; </span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="keyword">int</span> t=upper_bound(q+<span class="number">1</span>,q+rear+<span class="number">1</span>,x)-q;</span><br><span class="line">    <span class="keyword">if</span>(t==rear+<span class="number">1</span>) q[++rear]=x;</span><br><span class="line">    <span class="keyword">else</span> q[t]=x;<span class="comment">//将刚好大于它的代替，这里是运用了贪心思想a</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;fa[i],&amp;x);</span><br><span class="line">        ch[fa[i]][x]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=top;i++) st[i]=st[i]-i;</span><br><span class="line">    </span><br><span class="line">    q[<span class="number">0</span>]=<span class="number">-10000000000</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=top;i++) run(st[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans=n-rear;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[maxn],np=<span class="number">0</span>,rt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(y,x%y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> minv[maxn][<span class="number">20</span>],gcdd[maxn][<span class="number">20</span>],logg[maxn],w[<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span></span>&#123;</span><br><span class="line">    w[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    logg[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;i++) w[i]=w[i<span class="number">-1</span>]*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxn<span class="number">-5</span>;i++) logg[i]=logg[i/<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        minv[i][<span class="number">0</span>]=gcdd[i][<span class="number">0</span>]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=logg[n];i++)<span class="comment">//加个1保个险 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    <span class="keyword">if</span>(j+w[i]<span class="number">-1</span>&lt;=n)&#123;</span><br><span class="line">        minv[j][i]=min(minv[j][i<span class="number">-1</span>],minv[j+w[i<span class="number">-1</span>]][i<span class="number">-1</span>]);<span class="comment">//本来是j+(1&lt;&lt;(i-1))-1+1</span></span><br><span class="line">        gcdd[j][i]=gcd(gcdd[j][i<span class="number">-1</span>],gcdd[j+w[i<span class="number">-1</span>]][i<span class="number">-1</span>]);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cd1</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=j-i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> t=logg[len];</span><br><span class="line">    <span class="keyword">return</span> min(minv[i][t],minv[j-w[t]+<span class="number">1</span>][t]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cd2</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=j-i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> t=logg[len];</span><br><span class="line">    <span class="keyword">return</span> gcd(gcdd[i][t],gcdd[j-w[t]+<span class="number">1</span>][t]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> st[maxn],top=<span class="number">0</span>,yb[maxn],topp=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span></span>&#123;</span><br><span class="line">    topp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> ok=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-mid+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j=i+mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(cd1(i,j)==cd2(i,j))&#123;</span><br><span class="line">            ok=<span class="literal">true</span>;</span><br><span class="line">            yb[++topp]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ok)&#123;</span><br><span class="line">        top=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=topp;i++) st[++top]=yb[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A=<span class="number">1</span>,B=n,mid,ans;</span><br><span class="line">    <span class="keyword">while</span>(A&lt;=B)&#123;</span><br><span class="line">        mid=A+B&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid))</span><br><span class="line">        ans=mid,A=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> B=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,top,ans<span class="number">-1</span>);<span class="comment">//L-R</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=top;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,st[i]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    ready(); </span><br><span class="line">    run(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 55</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll c[maxn][maxn],dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> p[maxn],n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">50</span>;i++)&#123;</span><br><span class="line">        c[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">        c[i][j]=(c[i<span class="number">-1</span>][j<span class="number">-1</span>]+c[i<span class="number">-1</span>][j])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> len,<span class="keyword">int</span> now)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[len][now]!=<span class="number">-1</span>) <span class="keyword">return</span> dp[len][now];</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">1</span>) <span class="keyword">return</span> dp[len][now]=<span class="number">1</span>;</span><br><span class="line">    ll ans=<span class="number">0</span>;<span class="keyword">int</span> j,k,pos=<span class="number">0</span>,t[maxn];<span class="comment">//pos和t只有内定了给，不然要重 函数递归时会改变 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(p[i]&gt;=now&amp;&amp;p[i]&lt;now+len) t[++pos]=p[i];<span class="comment">//pos==len</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;pos;i++)&#123;</span><br><span class="line">        swap(t[i],t[i+<span class="number">1</span>]);<span class="comment">//枚举交换的位置</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=i;j++)<span class="comment">//判断是否满足</span></span><br><span class="line">        <span class="keyword">if</span>(t[j]&gt;=now+i) <span class="keyword">break</span>;<span class="comment">//最多为now+i-1;</span></span><br><span class="line">        <span class="keyword">for</span>(k=i+<span class="number">1</span>;k&lt;=pos;k++)</span><br><span class="line">        <span class="keyword">if</span>(t[k]&lt;now+i)  <span class="keyword">break</span>;<span class="comment">//最小为now+i; </span></span><br><span class="line">        <span class="keyword">if</span>(j&gt;i&amp;&amp;k&gt;pos)&#123;</span><br><span class="line">            ll t1=dfs(i,now);</span><br><span class="line">            ll t2=dfs(pos-i,now+i);</span><br><span class="line">            ans=(ans+t1*t2%mod*c[pos<span class="number">-2</span>][i<span class="number">-1</span>]%mod)%mod;<span class="comment">//第一个:now~now+i-1 第二个now+i~now+len-1; </span></span><br><span class="line">                                    <span class="comment">//在这之前进行n-2次交换,前i-1次选择前面来处理前面的i个 </span></span><br><span class="line">        &#125;</span><br><span class="line">        swap(t[i],t[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len][now]=ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p[i]);</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dfs(n,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(dp[n][<span class="number">0</span>]==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"%d"</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld"</span>,dp[n][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ready();</span><br><span class="line">    init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 305</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">double</span> a[maxn],b[maxn*maxn];<span class="comment">//b:(k-x,m-x)/(k,m) 而x最多为n^2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a[<span class="number">0</span>]=<span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=a[i<span class="number">-1</span>]*(n-i+<span class="number">1</span>)*<span class="number">1.0</span>/i;</span><br><span class="line">    b[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*n;i++) b[i]=b[i<span class="number">-1</span>]*(k-i+<span class="number">1</span>)*<span class="number">1.0</span>/(m-i+<span class="number">1</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">99</span>;i++) <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    ready();</span><br><span class="line">    <span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=(i+j)*n-i*j;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;k) <span class="keyword">break</span>;<span class="comment">//再加只会更多 </span></span><br><span class="line">        ans+=a[i]*a[j]*b[x];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(ans&gt;<span class="number">1e99</span>) outt();</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lf"</span>,ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率期望 </tag>
            
            <tag> dp </tag>
            
            <tag> LIS </tag>
            
            <tag> ST表 </tag>
            
            <tag> 二分答案 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最小瓶颈生成树</title>
      <link href="/2018/10/15/2/"/>
      <url>/2018/10/15/2/</url>
      
        <content type="html"><![CDATA[<h1 id="所谓最小瓶颈生成树…-就是使得生成树树上最大边权值最小。"><a href="#所谓最小瓶颈生成树…-就是使得生成树树上最大边权值最小。" class="headerlink" title="所谓最小瓶颈生成树….就是使得生成树树上最大边权值最小。"></a>所谓最小瓶颈生成树….就是使得生成树树上最大边权值最小。</h1><p>这里主要介绍一种期望O（M）（线性）的求法，其实主要就是二分，具体思路如下：</p><p>类比找第k大值的方法，首先随机一个边权w。</p><p>然后将不超过这个边权的边加入，遍历这张图。</p><p>如果图连通，那么瓶颈不超过w，于是只需考虑边权不超过w的边。</p><p>否则将这些连通点缩起来，考虑边权大于w的边。</p><p>每次将问题的规模缩小至一半。</p><p>期望时间复杂度O(m)。</p><h2 id="相关例题有两道："><a href="#相关例题有两道：" class="headerlink" title="相关例题有两道："></a>相关例题有两道：</h2><p>A.Hangar Hurdles (CERC 16)</p><p>有一个n*n的网格图，上面有些格子可行，有些格子是障碍。 有Q个询问，想把一个正方形箱子从(r1,c1)推到(r2,c2)，问箱子最大的大小。（起点终点是正方形箱子的中点） N&lt;=1000 Q&lt;=300000</p><p>B.洪蛤吨有一个宽度为L的管道，我们可以视其为一条y=L的直线与X轴所夹的部分。</p><p>（所以这根管道的长度可以视为正无穷）</p><p>这个管道中有个N个障碍点，第i个障碍点的坐标为(Xi,Yi)。</p><p>已知有一个球体，能在不碰到障碍点的前提下，从管道的最左端走到最右端。（即从管道内横坐标负无穷的地方走到横坐标正无穷的地方）。</p><p>求这个球体的直径最大是多少。为了避免精度误差，请输出答案保留三位小数的结果。</p><h3 id="两题有异曲同工之妙a…（-滑稽，思路差不多…）都可以用最小瓶颈树实现复杂度最小"><a href="#两题有异曲同工之妙a…（-滑稽，思路差不多…）都可以用最小瓶颈树实现复杂度最小" class="headerlink" title="两题有异曲同工之妙a…（/滑稽，思路差不多…）都可以用最小瓶颈树实现复杂度最小"></a>两题有异曲同工之妙a…（/滑稽，思路差不多…）都可以用最小瓶颈树实现复杂度最小</h3><p>下面上一下t2的代码：（没有用最小瓶颈树优化，逃）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 505</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eage</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="keyword">double</span> dist;</span><br><span class="line">&#125;e[maxn*maxn/<span class="number">2</span>+maxn*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(eage a,eage b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.dist&lt;b.dist;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="number">1.0</span>*(x1-x2)*(x1-x2)+<span class="number">1.0</span>*(y1-y2)*(y1-y2)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fa[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">int</span> root=find(fa[x]);</span><br><span class="line">    fa[x]=root;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx=find(x),fy=find(y);</span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)&#123;</span><br><span class="line">        fa[fx]=fy;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx=find(x),fy=find(y);</span><br><span class="line">    <span class="keyword">if</span>(fx!=fy) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> l,n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;nd[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">2</span>;i++) fa[i]=i;<span class="comment">//n+1是上，n+2是下 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;nd[i].x,&amp;nd[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        e[++pos]=(eage)&#123;i,n+<span class="number">1</span>,l-nd[i].y&#125;;</span><br><span class="line">        e[++pos]=(eage)&#123;i,n+<span class="number">2</span>,nd[i].y&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">        e[++pos]=(eage)&#123;i,j,dis(nd[i].x,nd[i].y,nd[j].x,nd[j].y)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    sort(e+<span class="number">1</span>,e+pos+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=pos;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=e[i].u,v=e[i].v;</span><br><span class="line">        <span class="keyword">if</span>(check(u,v)) <span class="keyword">continue</span>;</span><br><span class="line">        link(u,v);</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span>(find(n+<span class="number">1</span>)==find(n+<span class="number">2</span>))&#123;<span class="comment">//只要上底和下底连接了就行 这样才能保证极大值可以通过，如果后面更大，那这里是过不了的 </span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.3f"</span>,e[i].dist);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正睿 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小瓶颈生成树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>UpdateAfterEvent</title>
      <link href="/2018/10/15/1/"/>
      <url>/2018/10/15/1/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>​       小松鼠打了10个小时的游戏，一脸满足。却发现周围再次围满了游客，逃！</p><p>　　她发现整个西湖内的松鼠都以相同的速度在树之间跳跃。每跳跃一次花费一个单位的时间。我们可以把西湖抽象为一张n个点的无向图，初始时每个点上都有若干只松鼠，它们每单位时间都可以沿着一条无向边进行跳跃。</p><p>　　对于一只当前在点i的松鼠，它在接下来的一个单位时间内等概率向相邻的点跳跃。更具体地讲，我们称与点i通过一条无向边直接相连的点为与i相邻的点，假设这样的点有p个，那么对于每一个与i相邻的点，在下一时刻都有1/p的概率跳到它。</p><p>　　超萌小松鼠已知初始时刻（0时刻）每棵树上的松鼠分布情况，她想知道在T时刻，在同一棵树上的松鼠对数的期望。关于“松鼠对数”的解释：假设有4只松鼠在同一棵树上，那么我们称有6对在同一棵树上的松鼠。为了避免精度误差，我们将答案模10^9 + 7输出。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>​          第一行三个数n，T。意义如题面中所述。接下来一行n个数，第i个数ai表示第i个点初始时刻有ai只松鼠。接下来n行，每行n个数，第i行第j个数如果为1表示点i与点j间有无向边相连，为0则表示没有。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>​            输出一行一个数，表示T时刻在同一棵树上的松鼠对数的期望在模10^9 +7意义下的答案。</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>这道题考察了许多知识点，考察综合能力。</p><p>首先，题目总体是考察概率期望，但切忌陷入思路死角，去求每棵树上的最终期望松鼠对数。实际上，我们对于每只松鼠，去求它到某点的概率p,那么每两只松鼠在某点的期望便是p1<em>p2</em>1（还有很多可转化为概率来做的期望题）由于要除法取模，要预先递推求出逆元，复习一下公式：inv[1]=1;inv[i]=(mod-mod/i)*inv[mod%i]%mod. </p><p>那么对于松鼠到某点的概率求取，我们先O(N^2)求出最开始互相连点之间的概率，然后每一时刻，枚举中间点，进行概率传递，由于t比较大，可以用矩阵快速幂思想来将其优化到log2n级别。</p><p>最后，由于我们计算期望是O（n^3）的，无法过n&lt;=1000的点，发现如下式子：</p><p>设p(i,j)为i到j点的概率。假设计算终点在1，则ans=p(1,1)<em>p(2,1)+p(1,1)</em>p(3,1)<em>…..+p(1,1)</em>p(n,1)+p(2,1)<em>p(3,1)+p(2,1)</em>p(4,1)+…….发现可以转化为p(1,1)<em>(p(2,1)+p(3,1)+p(4,1)+….+p(n,1))+p(2,1)</em>(p(3,1)+p(4,1)+…..+p(n,1)).由此发现是可以前缀和优化的，由此只用枚举一点和终点，从而变成O(N^2).当然可以每个统计一次，然后最后除以2.貌似更方便哈…..</p><h1 id="The-Code"><a href="#The-Code" class="headerlink" title="The Code"></a>The Code</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span>&#123;</span></span><br><span class="line">    ll a[maxn][maxn];</span><br><span class="line">&#125;nd,ans;</span><br><span class="line"><span class="keyword">int</span> n,t,e[maxn][maxn];</span><br><span class="line">matrix <span class="keyword">operator</span> *(matrix &amp;x,matrix &amp;y)&#123;</span><br><span class="line">    matrix c;</span><br><span class="line">    <span class="built_in">memset</span>(c.a,<span class="number">0</span>,<span class="keyword">sizeof</span>(c.a));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        c.a[i][j]=(c.a[i][j]+(x.a[i][k]*y.a[k][j])%mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans.a[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t&amp;<span class="number">1</span>) ans=ans*nd;<span class="comment">//最后为1 </span></span><br><span class="line">        nd=nd*nd;</span><br><span class="line">        t/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll p[maxn][maxn],inv[maxn],v[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;v[i]);</span><br><span class="line">    inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">1000</span>;i++) inv[i]=(mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;e[i][j]);</span><br><span class="line">    <span class="built_in">memset</span>(nd.a,<span class="number">0</span>,<span class="keyword">sizeof</span>(nd.a));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)  res+=e[i][j];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)  nd.a[i][j]=inv[res]*e[i][j];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(t&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">pow</span>(t);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) p[i][j]=ans.a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) p[i][j]=nd.a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ll calc=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ll t1=<span class="number">0</span>,t2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            ll tt=(p[j][i]*v[j])%mod;</span><br><span class="line">            t1=(t1+tt)%mod;</span><br><span class="line">            t2=(t2+tt*p[j][i])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        calc=(calc+(t1*t1%mod-t2+mod)%mod*inv[<span class="number">2</span>]%mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,calc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> noip模拟赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率期望 </tag>
            
            <tag> 前缀和优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>祎隋</title>
      <link href="/2018/10/14/kk/"/>
      <url>/2018/10/14/kk/</url>
      
        <content type="html"><![CDATA[<h2 id="祎隋如你，春风十里不及你"><a href="#祎隋如你，春风十里不及你" class="headerlink" title="祎隋如你，春风十里不及你"></a>祎隋如你，春风十里不及你</h2><p>《祎隋》</p><p>无需仰首，我已知晓</p><p>那阳光濡缕，和风轻挠</p><p>不用回头，我已知晓</p><p>那鲜艳裙摆 ，恬然一笑</p><p>……</p><p>因你自嘲，为你歌声倾倒</p><font size="5" color="pink" face="微软雅黑">附上小鞠美图一张</font><p><img src="https://i.loli.net/2018/11/06/5be1a337bf614.jpg" alt="小鞠"></p>]]></content>
      
      
      <categories>
          
          <category> 杂诗 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂诗 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>gallery</title>
      <link href="/gallery/index.html"/>
      <url>/gallery/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>timeline</title>
      <link href="/timeline/index.html"/>
      <url>/timeline/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>links</title>
      <link href="/links/index.html"/>
      <url>/links/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>文章分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
  
</search>
