<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[划分物品]]></title>
    <url>%2F2018%2F11%2F08%2F55%2F</url>
    <content type="text"><![CDATA[Description你有 n 个物品，第 i 个物品的重量是$w_i$。 你需要把这些物品划分成若干组，满足每一组的重量和都是质数。 两个方案是不同的当且仅当存在两个物品 i 和 j，在第一个方案里他们处在同一组，第二个方案里他们不处在同一组。（对998244353取模） Hint$n&lt;=16,w_i&lt;=100$ Sample Input102 3 4 5 6 7 8 9 10 11 Sample Output1177 Solution一道经典的状压dp题，我们可以用$sum_i$来表示状态为i的集合所表示的重量和(类似思路也可以搞其他的)设$dp_i$表示状态为i的集合所能容纳的方案数，那么$dp_i=\sum_{(j属于i且j为素数)}dp_{i-j}$。显然这样是不正确的，因为有重复的，所以我们便固定一个x属于i，然后可以正确dp。 上代码: #include&lt;bits/stdc++.h&gt; #define maxv 1605 using namespace std; typedef long long ll; const ll mod=998244353; ll dp[1&lt;&lt;18]; int sum[1&lt;&lt;18]; int n,w[20]; bool vis[maxv]; int prime[maxv&gt;&gt;1],top=0; void ready(){ vis[0]=vis[1]=1; for(int i=1;i&lt;=maxv-5;i++){ if(!vis[i]) prime[++top]=i; for(int j=1;j&lt;=top&amp;&amp;prime[j]*i&lt;=maxv-5;j++){ vis[prime[j]*i]=1; if(i%prime[j]==0) break; } } } void init(){ scanf(&quot;%d&quot;,&amp;n); int all=(1&lt;&lt;n)-1; for(int i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;w[i]);sum[1&lt;&lt;i-1]=w[i]; } dp[0]=1; for(int i=1;i&lt;=all;i++) for(int j=1;j&lt;=n;j++){ if((i|(1&lt;&lt;j-1))!=i) continue; if((1&lt;&lt;j-1)==i) continue; sum[i]=sum[i-(1&lt;&lt;j-1)]+w[j];//可用如此方式来记录每个状态代表的值 } for(int i=1;i&lt;=all;i++){ int x=i&amp;(-i);//固定一个 注意i&amp;-i的值是1&lt;&lt;后的 for(int j=i;j;j=i&amp;(j-1)){ if((x|j)!=j) continue; if(vis[sum[j]]) continue; dp[i]=(dp[i]+dp[i-j])%mod; } } printf(&quot;%lld&quot;,dp[all]); } int main(){ ready(); init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计数]]></title>
    <url>%2F2018%2F11%2F07%2F54%2F</url>
    <content type="text"><![CDATA[Description既然是萌萌哒 visit_world 的比赛，那必然会有一道计数题啦！考虑一个N个节点的二叉树，它的节点被标上了$1-N$的编号. 并且，编号为i的节点在二叉树的前序遍历中恰好是第i个出现.我们定义$A_i$表示编号为i的点在二叉树的中序遍历中出现的位置.现在，给出m个限制条件，第i个限制条件给出了$u_i,v_i$,表示$A_{u_i}&lt;A_{v_i}$，也即中序遍历中$u_i$在$v_i$之前出现.你需要计算有多少种不同的带标号二叉树满足上述全部限制条件，答案对$1e9+7$取模. Hint$T&lt;=5,N&lt;=400,M&lt;=10^3$ Sample Input3 503 21 22 33 31 22 33 1 Sample Output4210 Solution首先M=0可以看出是个卡特兰数。然后我们知道先序遍历，根据其特性来枚举出合法的中序遍历，每次找到一个根，枚举它左边有多少个，右边有多少个，然后判断是否合法，合法的话方案数乘起来累加。见图：首先枚举后有三个大小关系：根的中序遍历大于任意左子树的，任意右子树的大于根的，任意右子树的大于左子树的。然后发现check是$n^2$的，而dp又是$n^3$的，这样就$n^5$了，这里有个很nice的思路，用二维前缀和优化，如果要求i的中序遍历小于j的，那么$a[i][j]=1$，然后sum求一波二维前缀和，对于$sum[i][j]$其含义便是1-i中小于1-j中的个数和，那么我们询问$[l1,r1]小于[l2,r2]$就为$sum[r1,r2]-sum[l1-1,r2]-sum[r1,l2-1]+sum[l1-1,l2-1]$然后就优化成$O(1)$的check了，整体复杂度就被优化至了$O(n^3)$，真的TQL%%% 上代码： #include&lt;bits/stdc++.h&gt; #define maxn 405 using namespace std; typedef long long ll; const ll mod=1e9+7; int a[maxn][maxn],n,t,m,x,y,sum[maxn][maxn]; ll dp[maxn][maxn]; int calc(int l1,int r1,int l2,int r2){//如果返回值说l1~r1有小于l2~r2的 return sum[r1][r2]-sum[l1-1][r2]-sum[r1][l2-1]+sum[l1-1][l2-1]; } bool check(int now,int l1,int r1,int l2,int r2){ if(calc(l2,r2,l1,r1))return false; if(calc(now,now,l1,r1))return false; if(calc(l2,r2,now,now))return false; return true; } void init(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); memset(a,0,sizeof(a)); memset(sum,0,sizeof(sum)); memset(dp,0,sizeof(dp)); for(int i=1;i&lt;=m;i++){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y); a[x][y]=1; } for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++){ sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j]; } for(int i=1;i&lt;=n;i++) dp[i][i]=1; for(int len=1;len&lt;=n;len++) for(int i=1;i&lt;=n;i++){ int j=i+len; if(j&gt;n) break; //其实这余下三坨是可以归在一起算的 if(!calc(i,i,i+1,j))dp[i][j]=(dp[i][j]+dp[i+1][j])%mod;//如果没有限制 if(!calc(i+1,j,i,i))dp[i][j]=(dp[i][j]+dp[i+1][j])%mod; for(int k=i+1;k&lt;j;k++){ if(check(i,i+1,k,k+1,j)) dp[i][j]=(dp[i][j]+dp[i+1][k]*dp[k+1][j])%mod; } } printf(&quot;%lld\n&quot;,dp[1][n]); } int main(){ scanf(&quot;%d&quot;,&amp;t); for(int i=1;i&lt;=t;i++) init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>二维前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[购物]]></title>
    <url>%2F2018%2F11%2F07%2F53%2F</url>
    <content type="text"><![CDATA[Descriptionvisit_world 有一个商店，商店里卖 个商品，第 i 个的价格为$a_i$我们称一个正整数 K 是美妙的，当且仅当我们可以在商店里选购若干个商品，使得价格之和落在区间$ [K, 2K]$ 中。问：有多少个美妙的数。 Hint$N&lt;=10^5,a_i&lt;=10^9$时空限制：1s / 512MB Sample Input31 2 3 Sample Output6 Solution我们将$a_i$从小到大排序，对于前i个，假设它们和为sum,那么k能去到的范围即为$[\frac{sum+1}{2},sum]$，那么对于$\frac{sum-1}{2}$开始是覆盖的不到，我们便会减去一些来使覆盖，所以肯定是逐渐拿小的来，到最后剩下$a_i$，那么设前i-1个的和为sum’，则$[sum’+1,\frac{a_i-1}{2}]$是覆盖不到，所以最终把这些空隙减掉即可。 上代码： #include&lt;bits/stdc++.h&gt; #define maxn 100005 using namespace std; typedef long long ll; int n; ll a[maxn]; void init(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]); ll sum=0,del=0; sort(a+1,a+n+1); for(int i=1;i&lt;=n;i++){ del+=max((a[i]+1)/2-sum-1,0ll); sum+=a[i]; } printf(&quot;%lld&quot;,sum-del); } int main(){ init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[physics]]></title>
    <url>%2F2018%2F11%2F06%2F52%2F</url>
    <content type="text"><![CDATA[Description一个n行m列的矩阵，每个为0或1，如果一个边长为K的正方形包含的所有数都为1，那么会形成一个强度为K的电场，有q次询问，每次询问会把1个1变做0，求每次询问的最大电场强度值。 Hint$n,m&lt;=2 \ast 10^3 ,1&lt;=q&lt;=10^4$ Sample Input5 5 5+-++++++++++++++++++++++-1 52 25 32 31 1 Sample Output43322 Solution首先会想到用单调栈$n^2$计算最大1正方形，然后发现每改一个只会影响一列的up数组，然后发现如果答案递减不好维护，那么正难则反，我们先将所有的改动加进来，然后倒序考虑所有操作。那么答案是会依次递增的，我们维护一个up和一个down数组来记录每个格子向上和向下最多多少格，对于每次询问，O(N)更新那一列的up和down，再O(n)单调队列扫一遍那一行，类似滑动窗口的来查询长度为k的序列的$min(up_i)和min(down_i)$，看它们加起来是否大于等于k，如果满足继续扩大k，否则标记答案。 上代码： #include&lt;bits/stdc++.h&gt; #define maxn 2005 #define maxq 10005 #define inf 0x3f3f3f3f using namespace std; struct node{ int x,y,ans; }nd[maxq]; int n,m,a[maxn][maxn],q,st[maxn],top=0,up[maxn][maxn],down[maxn][maxn]; char s[maxn]; int maxx=0; void calc(){ for(int j=1;j&lt;=m;j++) for(int i=1;i&lt;=n;i++) up[i][j]=(a[i][j]==0?0:up[i-1][j]+1); for(int j=1;j&lt;=m;j++) for(int i=n;i&gt;=1;i--) down[i][j]=(a[i][j]==0?0:down[i+1][j]+1); st[0]=0; for(int i=1;i&lt;=n;i++){ top=0; for(int j=1;j&lt;=m;j++){ while(top&amp;&amp;up[i][j]&lt;=up[i][st[top]]){//单调栈 maxx=max(maxx,min(up[i][st[top]],j-1-st[top-1])); top--; } st[++top]=j; } while(top){ maxx=max(maxx,min(up[i][st[top]],m-st[top-1])); top--; } } } void calcc(int j){ for(int i=1;i&lt;=n;i++) up[i][j]=(a[i][j]==0?0:up[i-1][j]+1); for(int i=n;i&gt;=1;i--) down[i][j]=(a[i][j]==0?0:down[i+1][j]+1); } int q1[maxn],q2[maxn],front1,front2,rear1,rear2; bool check(int i,int len){ if(len&gt;min(n,m)) return false; front1=front2=rear1=rear2=0; for(int j=1;j&lt;=m;j++){ while(front1&lt;rear1&amp;&amp;j-q1[front1]&gt;=len)front1++; while(front1&lt;rear1&amp;&amp;up[i][q1[rear1-1]]&gt;=up[i][j])rear1--; q1[rear1++]=j; while(front2&lt;rear2&amp;&amp;j-q2[front2]&gt;=len)front2++; while(front2&lt;rear2&amp;&amp;down[i][q2[rear2-1]]&gt;=down[i][j])rear2--; q2[rear2++]=j; if(j&gt;=len&amp;&amp;up[i][q1[front1]]+down[i][q2[front2]]-1&gt;=len)return true; } return false; } void init(){ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q); for(int i=1;i&lt;=n;i++){ scanf(&quot;%s&quot;,s+1); for(int j=1;j&lt;=m;j++) a[i][j]=(s[j]==&#39;+&#39;?1:0); } for(int i=1;i&lt;=q;i++){ scanf(&quot;%d%d&quot;,&amp;nd[i].x,&amp;nd[i].y);a[nd[i].x][nd[i].y]=0; } calc(); nd[q].ans=maxx; for(int i=q;i&gt;=2;i--){ a[nd[i].x][nd[i].y]=1; calcc(nd[i].y);//更新 nd[i-1].ans=nd[i].ans; while(check(nd[i].x,maxx+1)) maxx++,nd[i-1].ans=maxx;//只改动了这一行 } for(int i=1;i&lt;=q;i++) printf(&quot;%d\n&quot;,nd[i].ans); } int main(){ init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>正难则反</tag>
        <tag>单调队列</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chinese]]></title>
    <url>%2F2018%2F11%2F06%2F51%2F</url>
    <content type="text"><![CDATA[Description一个n行m列的矩阵，每个格子可以填一个$1~k$的整数，矩阵中的一个格子为炼字当且仅当其值比其所在行和列的其它数都大，定义一个矩阵的精彩度为炼字的个数。设$f_i$为精彩度为i的方案数，显然:$\sum_{i=0}^{n \ast m} f_i=k^{n \ast m}$。现在你需要求出$\sum_{i=0}^{n \ast m} f_i \ast i mod (1e9+7)$ Hint$n,m&lt;=10^9,k&lt;=10^6$ Sample Input2 2 2 Sample Output8 Solution首先，对$\sum_{i=0}^{n \ast m} f_i \ast i$的理解为所有方案中炼字的个数和，那么考虑对每个格子单独计算贡献，如图：那么每个格子产生的贡献即为 \sum_{i=1}^{k} k^{(n-1) \ast (m-1)} \ast (i-1)^{n-1} \ast (i-1)^{m-1}因为相应性质，我们只要再乘上$n \ast m$即为最终答案。 上代码： #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const ll mod=1e9+7; ll n,m,k; ll qkpow(ll t,ll pos){ ll ans=1,base=t; while(pos){ if(pos&amp;1) ans=ans*base%mod; base=base*base%mod; pos&gt;&gt;=1; } return ans; } void init(){ scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;k); ll t1=qkpow(k,(n-1)*(m-1)); ll ans=0; for(int i=1;i&lt;k;i++) ans=(ans+qkpow(i,n-1)*qkpow(i,m-1)%mod*t1%mod)%mod; ans=ans*n%mod*m%mod; printf(&quot;%lld&quot;,ans); } int main(){ init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Certificate]]></title>
    <url>%2F2018%2F11%2F05%2F50%2F</url>
    <content type="text"><![CDATA[Description已知有$N(N≤14)$个变量，变量取值0或1。已知$f(0,0,⋯,0)，⋯，f(1,1,⋯,1)$的函数值。对于每种输入$x=(x_0,x_1,⋯,x_n)$，求最少需要知道几个变量的值即可确定函数值。举个例子：假设有两个变量，函数$f(a,b)=a\&amp;b$，那么对于$f(x)=0$，我们只要知道其中一个变量为0即可确定函数值为0，否则我们需要知道两个变量是否都为1，才能确定函数值为1。 Solution可以先$2^N$枚举选出的t个关键问题，再$2^N$判断，复杂度为$4^N$，可以勉强卡过。 上代码： #include&lt;bits/stdc++.h&gt; #define maxn 16 using namespace std; int ans[1&lt;&lt;maxn],check[1&lt;&lt;maxn],n,a[1&lt;&lt;maxn]; char s[1&lt;&lt;maxn]; int calc(int x){ int cnt=0; while(x){ cnt++; x-=x&amp;(-x); } return cnt; } void init(){ scanf(&quot;%d&quot;,&amp;n); int all=1&lt;&lt;n; scanf(&quot;%s&quot;,s); memset(ans,0x3f,sizeof(ans)); for(int i=0;s[i];i++) a[i]=(s[i]==&#39;0&#39;?0:1); for(int i=0;i&lt;all;i++){ memset(check,-1,sizeof(check)); for(int j=0;j&lt;all;j++){ if(check[i&amp;j]==-1) check[i&amp;j]=a[j]; else if(check[i&amp;j]!=a[j]) check[i&amp;j]=2; } int len=calc(i); for(int j=0;j&lt;all;j++) if(check[i&amp;j]==a[j]) ans[j]=min(ans[j],len); } for(int i=0;i&lt;all;i++) printf(&quot;%d &quot;,ans[i]); } int main(){ init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数位dp总结]]></title>
    <url>%2F2018%2F11%2F04%2F49%2F</url>
    <content type="text"><![CDATA[首先，数位动态规划主要用于在一个整数区间寻找满足条件的一些数。 一般分为两个步骤：dp计算符合题目条件的信息和计算答案。 例如我们求(l,r)中不含数字3的数的个数。设dp(i)表示位数为i的所有整数中(含前导0)不含3的个数，代码如下： dp[0]=1; for(int i=1;i&lt;=19;i++) for(int j=0;j&lt;10;j++)//枚举前一位的数字 if(j!=3) dp[i]+=dp[i-1]; 接着是计算答案，我们设f(i)表示小于i的所有整数中，不含3的个数，那么(l,r)即为f(r+1)-f(l).代码如下: ll f(ll x){ int st[20],top=0; while(x) st[++top]=x%10,x/=10; ll calc=0; for(int i=top;i&gt;0;i--){ for(int j=0;j&lt;st[i];j++)//枚举当前位的数字 if(j!=3) calc+=dp[i-1]; if(st[i]==3) break; } return calc; } （留坑23333]]></content>
      <categories>
        <category>复习</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树的距离]]></title>
    <url>%2F2018%2F11%2F03%2F48%2F</url>
    <content type="text"><![CDATA[Description开始有一个空的集合S，进行Q次操作： 1.插入一个数x（如果已存在就忽略）2.删除一个数x（如果不存在就忽略）3.询问点集中数与x的最短距离定义两个数a,b的距离为，每次将a乘一个质数或除以一个质数因子，使a变成b的最小步数。$（Q≤50000,x≤1000000，时限2秒）$ Solution对于两个数A,B: A=p_1^{a_1}+p_2^{a_2}+.....p_n^{a_n}B=p_1^{b_1}+p_2^{b_2}+.....p_n^{b_n}(如果某些$p_i$，相应的次数为0)那么A,B的距离即为 \sum_{i=1}^n abs(a_i-b_i)设gcd(A,B)为g，那么dis可以化为$num(\frac a{g})+num(\frac b{g})$，其中num(x)表示x包含的质数个数。然后我们发现枚举B的话复杂度无法承受，那么转过来枚举A的因数来作为GCD，然后统计相应步数即可。当然这里可以用set或map来维护以谁为gcd的最小B. 上代码： #include&lt;bits/stdc++.h&gt; #define maxn 1000005 using namespace std; int prime[maxn&gt;&gt;1],top=0,s[maxn]; typedef long long ll; bool vis[maxn]; void ready(){ vis[0]=vis[1]=1; for(int i=2;i&lt;=maxn-5;i++){ if(!vis[i]) prime[++top]=i,s[i]=1; for(int j=1;j&lt;=top&amp;&amp;i*prime[j]&lt;=maxn-5;j++){ vis[prime[j]*i]=1;s[prime[j]*i]=s[i]+1; if(i%prime[j]==0) break; } } } int q,op,x; int c[maxn][20]; void init(){ scanf(&quot;%d&quot;,&amp;q); memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=q;i++){ scanf(&quot;%d%d&quot;,&amp;op,&amp;x); if(op==1&amp;&amp;!vis[x]){ vis[x]=1; for(int j=1;1ll*j*j&lt;=x;j++) if(x%j==0){ c[j][s[x]-s[j]]++; c[x/j][s[j]]++; } } if(op==2&amp;&amp;vis[x]){ vis[x]=0; for(int j=1;1ll*j*j&lt;=x;j++) if(x%j==0){ c[j][s[x]-s[j]]--; c[x/j][s[j]]--; } } if(op==3){ int ans=1e9; for(int j=1;1ll*j*j&lt;=x;j++) if(x%j==0){ for(int k=0;k&lt;20;k++) if(c[j][k]) ans=min(ans,k+s[x]-s[j]); for(int k=0;k&lt;20;k++) if(c[x/j][k]) ans=min(ans,k+s[j]); } if(ans==1e9) printf(&quot;-1\n&quot;); else printf(&quot;%d\n&quot;,ans); } } } int main(){ ready(); init(); return 0; } 滔滔的map代码： #include&lt;map&gt; #include&lt;cmath&gt; #include&lt;vector&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; const int maxn=1000000+5,inf=0x3f3f3f3f; int n,f[maxn]; bool vis[maxn]; vector&lt;int&gt;primes; map&lt;int,int&gt;mp[maxn]; void init(){ for(int i=2;i&lt;=maxn-5;i++){ if(!f[i])f[i]=1,primes.push_back(i); for(int k=0;k&lt;primes.size()&amp;&amp;i*primes[k]&lt;=maxn-5;k++){ f[i*primes[k]]=f[i]+1; if(i%primes[k]==0)break; } } } void ins(int x){ if(vis[x])return;vis[x]=1; int sq=sqrt(x+0.5); for(int i=1;i&lt;=sq;i++){ if(x%i==0)mp[i][f[x]]++; if(x%i==0&amp;&amp;i*i!=x)mp[x/i][f[x]]++; } } void del(int x){ if(!vis[x])return;vis[x]=0; int sq=sqrt(x+0.5); for(int i=1;i&lt;=sq;i++){ if(x%i==0)if(--mp[i][f[x]]==0)mp[i].erase(f[x]); if(x%i==0&amp;&amp;i*i!=x)if(--mp[x/i][f[x]]==0)mp[x/i].erase(f[x]); } } int Find(int i){ if(!mp[i].size())return inf*2; return mp[i].begin()-&gt;first; } void solve(int x){ int sq=sqrt(x+0.5),ans=inf; for(int i=1;i&lt;=sq;i++){ if(x%i==0)ans=min(ans,f[x]+Find(i)-2*f[i]); if(x%i==0&amp;&amp;i*i!=x)ans=min(ans,f[x]+Find(x/i)-2*f[x/i]); } if(ans&gt;=inf)printf(&quot;-1\n&quot;); else printf(&quot;%d\n&quot;,ans); } int main(){ init(); scanf(&quot;%d&quot;,&amp;n); for(int i=1,op,x;i&lt;=n;i++){ scanf(&quot;%d%d&quot;,&amp;op,&amp;x); if(op==1)ins(x); if(op==2)del(x); if(op==3)solve(x); } return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>枚举</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小G的树]]></title>
    <url>%2F2018%2F11%2F03%2F47%2F</url>
    <content type="text"><![CDATA[Description给出n个点的树，每条边长会等概率是1或2，求树的直径的期望。（$n≤60$） Solution只要会树型dp求树的直径，然后枚举就可以$O(n^4)$过了 上代码： #include&lt;bits/stdc++.h&gt; #define maxn 70 using namespace std; typedef long long ll; ll g[maxn&lt;&lt;1][maxn&lt;&lt;1],ff[maxn][maxn&lt;&lt;1][maxn&lt;&lt;1]; int n,x,y; struct eage{ int to,next; }e[maxn&lt;&lt;1]; int np=0,first[maxn]; void add(int u,int v){ e[++np]=(eage){v,first[u]}; first[u]=np; } int sz[maxn]; void dfs(int i,int f){ ff[i][0][0]=sz[i]=1; for(int p=first[i];p;p=e[p].next){ int j=e[p].to; if(j==f) continue; dfs(j,i); memset(g,0,sizeof(g)); for(int l1=0;l1&lt;=sz[i]*2;l1++) for(int z1=l1;z1&lt;=sz[i]*2;z1++)if(ff[i][l1][z1]) for(int l2=0;l2&lt;=sz[j]*2;l2++) for(int z2=l2;z2&lt;=sz[j]*2;z2++) if(ff[j][l2][z2]){ for(int len=1;len&lt;=2;len++){ int t=max(z1,z2); t=max(t,l1+l2+len); g[max(l1,l2+len)][t]+=ff[i][l1][z1]*ff[j][l2][z2];; } } sz[i]+=sz[j]; for(int l=0;l&lt;=sz[i]*2;l++) for(int z=l;z&lt;=sz[i]*2;z++) ff[i][l][z]=g[l][z]; } } void init(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;n;i++){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y);add(x,y);add(y,x); } dfs(1,0); double ans=0; for(int l=0;l&lt;=n*2;l++) for(int z=l;z&lt;=n*2;z++){ ans+=ff[1][l][z]*z; } printf(&quot;%lf&quot;,ans/(1ll&lt;&lt;(n-1))); } int main(){ init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>概率期望</tag>
        <tag>树型dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[郁闷的小G]]></title>
    <url>%2F2018%2F11%2F03%2F46%2F</url>
    <content type="text"><![CDATA[Description有5种类型的题E,EM,M,MH,H若干，其中E,EM可用来出第一题，EM,M,MH可用来出第二题，MH,H可用来出第三题，求最多可出多少场模拟赛。（设N为最大数，$1≤N≤10^18$） Solution我干考试时懵了直接上了个大模拟，结果用二分简单到爆炸！！！ 模拟： #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; ll e,em,m,mh,h,a,b,c,x=1,y=1; int main(){ scanf(&quot;%lld%lld%lld%lld%lld&quot;,&amp;e,&amp;em,&amp;m,&amp;mh,&amp;h); a=e+em,b=m,c=mh+h; if(a&lt;=b) x=0; if(c&lt;=b) y=0; if(!x&amp;&amp;!y){ ll ans=min(a,min(b,c)); printf(&quot;%lld&quot;,ans); } else if(!x){ ll mid=(b+c)/2; if(mid-b&lt;=mh) y=mid-b; else y=mh; ll minn=y+b; ll ans=min(a,minn); printf(&quot;%lld&quot;,ans); } else if(!y){ ll mid=(a+b)/2; if(mid-b&lt;=em) x=mid-b; else x=em; ll minn=b+x; ll ans=min(minn,c); printf(&quot;%lld&quot;,ans); } else{ if(a&gt;c){ ll mv=a-c; if(mv&gt;em) mv=em; a=a-mv; if(b+mv&gt;=c){ printf(&quot;%lld&quot;,c); } else{ if(mv==em){ b+=mv; ll mid=(b+c)/2; if(mid-b&lt;=mh) y=mid-b; else y=mh; ll minn=y+b; printf(&quot;%lld&quot;,minn); } else{ b+=mv; em-=mv;//还剩的步数 ll mvv=min(em,mh); ll cnt=(c-b)/3; if(cnt&gt;mvv) cnt=mvv; ll minn=b+cnt*2; c=c-cnt,a=a-cnt;em-=mvv;mh-=mvv; if(minn&lt;c){ if(em){ ll mid=(minn+c)/2; if(mid-minn&lt;=em) y=mid-minn; else y=em; minn=minn+y; } if(mh){ ll mid=(minn+c)/2; if(mid-minn&lt;=mh) y=mid-minn; else y=mh; minn=minn+y; } } printf(&quot;%lld&quot;,minn); } } } else{ ll mv=c-a; if(mv&gt;mh) mv=mh; c=c-mv; if(b+mv&gt;=a){ printf(&quot;%lld&quot;,a); } else{ if(mv==mh){ b+=mv; ll mid=(a+b)/2; if(mid-b&lt;=em) x=mid-b; else x=em; ll minn=b+x; printf(&quot;%lld&quot;,minn); } else{ b+=mv; mh-=mv;//还剩的步数 ll mvv=min(em,mh); ll cnt=(c-b)/3; if(cnt&gt;mvv) cnt=mvv; ll minn=b+cnt*2; c=c-cnt,a=a-cnt;em-=mvv;mh-=mvv; if(minn&lt;c){ if(em){ ll mid=(minn+c)/2; if(mid-minn&lt;=em) y=mid-minn; else y=em; minn=minn+y; } if(mh){ ll mid=(minn+c)/2; if(mid-minn&lt;=mh) y=mid-minn; else y=mh; minn=minn+y; } } printf(&quot;%lld&quot;,minn); } } } } return 0; } 滔滔的二分： #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; typedef long long LL; bool check(LL mid,LL A,LL B,LL C,LL A_B,LL B_C){ if(A&lt;mid){if(A+A_B&lt;mid)return false;A_B-=mid-A;}B+=A_B; if(B&lt;mid){if(B+B_C&lt;mid)return false;B_C-=mid-B;} C+=B_C;if(C&lt;mid)return false; return true; } int main(){ LL A,B,C,A_B,B_C; scanf(&quot;%lld%lld%lld%lld%lld&quot;,&amp;A,&amp;A_B,&amp;B,&amp;B_C,&amp;C); LL L=min({A,B,C}),R=max({A+A_B,B+A_B+B_C,B_C+C}),ans; while(L&lt;=R){ LL mid=(L+R)&gt;&gt;1; if(check(mid,A,B,C,A_B,B_C))ans=mid,L=mid+1; else R=mid-1; } printf(&quot;%lld&quot;,ans); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[取数游戏]]></title>
    <url>%2F2018%2F11%2F01%2F45%2F</url>
    <content type="text"><![CDATA[Description有一个$N \ast M$的矩阵，你需要进行恰好K次操作，每次可以选择其中一行或者其中一列，将其中的元素全部累加到ans里去，然后把全中的这些数全部减去P，问ans最大是多少 Sample Input2 2 2 21 32 4 Sample Output11 Hint$N,M&lt;=1000,K&lt;=10^5,0&lt;=P&lt;=100,1&lt;A_{ij}&lt;1000$ Solution首先探究性质发现取行或取列只分别对列和行整体造成影响，贪心还是要取大的，所以只考虑对自身的影响。再发现取行或取列都是分别对以后的取列或取行造成-p的影响，所以先后是没有关系的。那么先预处理出去行k次和取列k次最大值，再O(n)枚举行列分别取多少，再减去$i \ast (k-i) \ast p$即可。 上代码： #include&lt;bits/stdc++.h&gt; #define maxn 100005 using namespace std; typedef long long ll; ll h[maxn],l[maxn],sh[maxn],sl[maxn]; int n,m,k,p,x; priority_queue&lt;ll&gt;q,qq; void init(){ scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;k,&amp;p); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++){ scanf(&quot;%d&quot;,&amp;x); h[i]+=x;l[j]+=x; } for(int i=1;i&lt;=n;i++) q.push(h[i]); for(int i=1;i&lt;=k;i++){ ll t=q.top();q.pop(); sh[i]=sh[i-1]+t;t-=m*p; q.push(t); } for(int i=1;i&lt;=m;i++) qq.push(l[i]); for(int i=1;i&lt;=k;i++){ ll t=qq.top();qq.pop(); sl[i]=sl[i-1]+t;t-=n*p; qq.push(t); } ll ans=-1000000000000; for(int i=0;i&lt;=k;i++){ ans=max(ans,sh[i]+sl[k-i]-1ll*i*(k-i)*p); } printf(&quot;%lld&quot;,ans); } int main(){ init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串]]></title>
    <url>%2F2018%2F11%2F01%2F44%2F</url>
    <content type="text"><![CDATA[Description要求用m种字母构造一个长度为n的字符串，使得该字符串的所有长度为k的子串均为回文串，问方案数 Input三个整数$n,m,k(1≤n,m,k≤2000)$ Output输出满足条件的字符串数量，结果模$10^9+7$ Sample Input5 2 4 Sample Output2 Solution对于每个位置，考虑它在一个回文串中的位置，与它相应的与它用并查集相连(回文串必须一样)，最后剩下若干集合，有cnt个，那么答案即为$m^{cnt}$，当然也可以直接分k,n关系讨论 并查集代码： #include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;map&gt; #include&lt;set&gt; #include&lt;ctime&gt; using namespace std; typedef long long ll; typedef pair&lt;int,int&gt;P; const int INF=0x3f3f3f3f,maxn=100001; #define mod 1000000007 int Pow(int a,int b) { int ans=1; while(b) { if(b&amp;1)ans=(ll)ans*a%mod; a=(ll)a*a%mod; b&gt;&gt;=1; } return ans; } int n,m,k,fa[maxn]; int find(int x) { if(fa[x]==x)return x; return fa[x]=find(fa[x]); } void unite(int x,int y) { x=find(x),y=find(y); if(x==y)return ; fa[x]=y; } int main() { int n,m,k; while(~scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k)) { for(int i=1;i&lt;=n;i++)fa[i]=i; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;k&amp;&amp;i+k-j&lt;=n;j+=2) unite(i,i+k-j); int ans=0; for(int i=1;i&lt;=n;i++) if(fa[i]==i)ans++; ans=Pow(m,ans); printf(&quot;%d\n&quot;,ans); } return 0; } nk关系代码： #include&lt;bits/stdc++.h&gt; #define maxn 2005 using namespace std; typedef long long ll; const ll mod=1e9+7; int n,m,k; ll qkpow(ll t,int pos){ ll ans=1,base=t; while(pos){ if(pos&amp;1) ans=ans*base%mod; base=base*base%mod; pos=pos&gt;&gt;1; } return ans; } void init(){ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); if(k==1){ printf(&quot;%lld&quot;,qkpow(m,n)); } else if(k==n) printf(&quot;%lld&quot;,qkpow(m,(k+1)/2)); else if(k&amp;1) printf(&quot;%lld&quot;,m*m%mod); else if(k&gt;n) printf(&quot;%lld&quot;,qkpow(m,n)); else printf(&quot;%d&quot;,m); } int main(){ init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coin]]></title>
    <url>%2F2018%2F10%2F31%2F43%2F</url>
    <content type="text"><![CDATA[Description小M有个n行m列的棋盘，每个格子都包含了至多一枚硬币，硬币正面或者反面朝上。小M和小D轮流操作，小M先手。每个人可以选择棋盘中没在之前被选择过的一行或者一列，然后将所选的行或列上的硬币全部翻转，即正面变成反面，反面变成正面。当所有硬币都正面朝上或者所有的行列都被选择，游戏结束。最后一次操作的玩家将会获得1分。如果当前局面所有的硬币都正面朝上，小M和小D都将获得2分的额外收益。问两个人如果都按最优策略操作，即最大化自己的分数，那么小M最后的得分是多少。（T组数据，1≤T,n,m≤100）保证每列至少有一个硬币，每行至少有一个反面朝上的硬币。 Sample Input12 5exexexeoex Sample Output3 Solution首先如果能构成全向上的局面，那么两人肯定是要构成的。否则就按照n+m奇偶来决定最后谁走。我们假设向上为0，向下为1，那么对于每一个$a_{ij}$，要求满足$h_i xor l_j xor a_{ij}==0$，变化一下即为$h_i xor l_j==a_{i-j}$，所以我们设$a_{ij}$为边权，然后可以连边维护，用类似二分图染色的方法扫一遍以判断是否合法(本可以用并查集维护，但貌似方式不对，联系不紧密)那么我们现在就会有诸多联通块，对每个联通块是个独立游戏，我们开始讨论：如果是奇-奇那么先手在这一块必定赢，而偶偶先手必输但是没影响因为如果有奇奇的话，先手最后是多下一步的，这是第一部分。第二部分就是奇偶，如果只有奇数个奇偶，那么最终先手可以多选一个奇偶的奇而获胜，否则后手选到奇偶的偶获胜。注意细节实现就行了。 上代码： #include&lt;bits/stdc++.h&gt; using namespace std; #define maxn 105 struct eage{ int to,next,len; }e[maxn*maxn*2]; int np=0,first[maxn&lt;&lt;1]; void add(int u,int v,int len){ e[++np]=(eage){v,first[u],len}; first[u]=np; } int t,n,m; char op[maxn]; bool ok; int base; int cnt[3]; int color[maxn&lt;&lt;1]; void dfs(int i){ cnt[color[i]]++; for(int p=first[i];p;p=e[p].next){ int j=e[p].to,c=e[p].len; if(c==0){ if(color[j]){ if(color[j]!=color[i]) ok=false; continue; } else{ color[j]=color[i]; dfs(j); } } else{ if(color[j]){ if(color[i]==color[j]) ok=false; continue; } else{ color[j]=3-color[i]; dfs(j); } } } } void run(){ for(int i=1;i&lt;=n+m;i++){ if(!color[i]){ cnt[1]=cnt[2]=0; color[i]=1; ok=true; dfs(i); if(!ok) return; if(cnt[1]&amp;1&amp;&amp;cnt[2]&amp;1) base^=1; else if(!(cnt[1]&amp;1)&amp;&amp;!(cnt[2]&amp;1)) ; else base^=2; } } } void init(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); memset(color,0,sizeof(color)); memset(first,0,sizeof(first)); np=0; ok=true; base=0; for(int i=1;i&lt;=n;i++){ scanf(&quot;%s&quot;,op+1); for(int j=1;j&lt;=m;j++){ if(op[j]==&#39;x&#39;){ add(i,j+n,1); add(j+n,i,1); } if(op[j]==&#39;o&#39;){ add(i,j+n,0); add(j+n,i,0); } } } run(); if(!ok){ int calc=n+m; if(calc&amp;1){ printf(&quot;1\n&quot;); } else{ printf(&quot;0\n&quot;); } } else{ if(base) printf(&quot;3\n&quot;); else printf(&quot;2\n&quot;); } } int main(){ scanf(&quot;%d&quot;,&amp;t); for(int i=1;i&lt;=t;i++) init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>隐式图</tag>
        <tag>博弈论</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Poker]]></title>
    <url>%2F2018%2F10%2F31%2F42%2F</url>
    <content type="text"><![CDATA[Description一共有n张扑克牌，第i张扑克牌的编号为$a_i$，这里保证n为偶数。先将n张牌随机的分成两堆大小为$\frac{n}{2}$的牌，一人拿一堆，随机为均匀随机。将n张牌随机打乱，两人开始比大小，按顺序翻各自的牌，如果前者大于后者，那么前者得一分，否则后者得一分，问前者和后者得分的期望，输出答案乘上n!然后对1e9+7取模的值。 Sample Input41 2 3 2 Sample Output20 28 Hint$n&lt;=10^5$ Solution其实是个假期望题。发现总方案数是n!，所以实际上是找全排列并统计得分。然后发现是排列，所以每次可以固定两个不同的数，然后乘上(n-2)! 上代码： #include&lt;bits/stdc++.h&gt; #define maxn 100005 using namespace std; typedef long long ll; const ll mod=1e9+7; int n,a[maxn]; ll jc; void init(){ scanf(&quot;%d&quot;,&amp;n); jc=1ll; for(int i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]); if(i&lt;=n-2) jc=jc*(ll)i%mod; } sort(a+1,a+n+1); ll ans1=0; ll cnt=0; ll len=n/2; ll ans2=0; for(int i=1;i&lt;=n;i++){ if(a[i]==a[i+1]){ cnt++; } else{ cnt++; ans1=(ans1+cnt*jc%mod*(ll)(n-i)%mod)%mod; ans2=(ans2+cnt*jc%mod*(ll)(n-i+cnt-1)%mod)%mod; cnt=0; } } ans1=ans1*len%mod; ans2=ans2*len%mod; printf(&quot;%lld &quot;,ans1); printf(&quot;%lld&quot;,ans2); } int main(){ init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>概率期望</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当那一天来临]]></title>
    <url>%2F2018%2F10%2F30%2F41%2F</url>
    <content type="text"><![CDATA[Description一条线段上有n个点，每个点有一个权值，要是一个人经过一个权值为w的点，那么他的金钱就增加w（w可以为负数）。现在Jack最开始在1号点，Rose最开始在n号点（此时Jack只有1号点的金钱，Rose只有n号点的金钱），他们要走到某个站点相会，整个过程中只能相向而行，并且每一次走一个点。首先是Jack选择自己向右走一个点或者让Rose向左做一个点；接着是Rose选择让Jack向右走一个点或者自己向左走一个点；接着又是Jack选择，直到两个人相遇。现在两人都采用最优策略，问相遇之后他们谁金钱多。如果Jack比Rose的金钱多，输出“win”，相等输出“tie”，少则输出“lose”。（T组数据，T≤10,1≤n≤10000） Sample Input341 3 2 341 2 2 35-1 -2 -1 -1 -1 Sample Outputwintielose Hint对于100%的数据，1&lt;=N&lt;=10000. Solution首先我们可以将题目的选项实际化，让自己走就是正常，让别人走就是让终点往自己这边移动，然后我们发现答案只与最终相遇位置有关。那么举几个例子，发现在n为偶数时，先手能够决定终点是在n/2+1或者n/2.而在n为奇数时，若先手先让自己走，那么后手能决定终点在n/2+1或n/2+1+1;若先手先让对面走，那么后手能决定终点在n/2+1或n/2。(所以大力分情况讨论即可)实际上n为奇数就是-1变成n为偶数然后交换先手权罢了。 上代码： #include&lt;bits/stdc++.h&gt; #define maxn 10005 using namespace std; int t,n,a[maxn],sum1,sum2; void init(){ sum1=sum2=0; scanf(&quot;%d&quot;,&amp;n); int z=n/2+1; for(int i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]); if(i&lt;=z) sum1+=a[i]; if(i&gt;=z) sum2+=a[i]; } if(n&amp;1){ int t=sum1-sum2; int changez=-a[z]-a[z-1]; int changey=a[z]+a[z+1]; int change=max(changey,changez);//由先手决定 t=min(t,t+change);//由后手决定 if(t&gt;0) printf(&quot;win\n&quot;); if(t==0) printf(&quot;tie\n&quot;); if(t&lt;0) printf(&quot;lose\n&quot;); } else{ int t=sum1-sum2; int change=-a[z]-a[z-1]; if(change&gt;0) t+=change; if(t&gt;0) printf(&quot;win\n&quot;); if(t==0) printf(&quot;tie\n&quot;); if(t&lt;0) printf(&quot;lose\n&quot;); } } int main(){ scanf(&quot;%d&quot;,&amp;t); for(int i=1;i&lt;=t;i++) init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[假如战争今天爆发]]></title>
    <url>%2F2018%2F10%2F30%2F40%2F</url>
    <content type="text"><![CDATA[假如战争今天爆发生活欺骗了你 Description有n件物品，每件物品要被三个机器一次加工（即是说，只有被第一个机器加工后才能被第二个机器加工，被第二个机器加工后才能被第三个机器加工）。第i件物品被三个机器加工所需要的时间分别为$A_i,B_i,C_i$，保证 $min(C_i)≥max(B_i)$。每个机器同一时刻只能加工一件物品，求让每件物品都被三个机器加工完所需要的最少时间。$（1≤n≤100000,0&lt;A_i,B_i,C_i&lt;106）$ Sample Input35 3 43 2 93 4 8 Sample Output26 Solution首先可以假设已经排好了顺序，那么计算最终时间，设dp(i,j)表示第i个被第j个机器加完工的时间，那么:$dp[i][j]=max(dp[i][j-1],dp[i-1][j])+a_{ij}$，那我们把它转移到图上面即从(1,1)到(n,3)，每次可以从左边或上边转移过来，实际上就发现是求最长路，如图：那么对于绿色和黄色的我们交换其间任意两个是没有影响的，而对于蓝色和黄色处便会有影响，这便是决定排列顺序的，所以当i要排在j前面的条件如下： max(a_{i1}+a_{i2}+a_{i3}+a_{j3},a_{i1}+a_{j1}+a_{j2}+a_{j3})]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>dp</tag>
        <tag>最长路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强军战歌]]></title>
    <url>%2F2018%2F10%2F30%2F39%2F</url>
    <content type="text"><![CDATA[Description给出一个数列A，当这个数列不是不下降的时候我们删除其中一个数，直到它是不下降的。求不同的删除方案总数，答案对1000000007取模。我们定义删除方案不同有两种情况： 删掉的数构成的集合不同 删掉的数构成的集合相同，但删除顺序不同 Sample Input31 7 5 Sample Output4 Hint$1&lt;=n&lt;=2000,1&lt;=A_i&lt;=2000$ Solution探究问题本质，发现是删掉数后刚好(首次)是个非严格LIS，那么我们如果去掉刚好这个限制，总方案数就会是$\sum_{i=1}^{n} cnt_i \ast (n-i)!$，其中$cnt_i$为长度为i的LIS个数，那么显然这样是不行的，因为有很多不合法的计入了。那么什么样的是不合法的呢，即已经是LIS之后还继续删除，这样的数即为$\sum_{i=2}^{n} cnt_i \ast i \ast (n-i)!$，注意这里1的没有计入，因为1删完之后就没了a23333.综上，$ans=\sum_{i=1}^{n} cnt_i \ast (n-i)!-\sum_{i=2}^{n} cnt_i \ast i \ast (n-i)!$.然后是对于$cnt_i$的计算，我们设dp(i,j)表示以i结尾长度为j的LIS个数，那么：(tips:可以了解一下这个思路，以后统计找结尾和长度以便于统计，因为LIS结尾要求递增，可以dp)$dp[i][j]+=dp[k][j-1] k在j前面且a[k]&lt;=a[j]$由于范围限制，我们使用树状数组来维护将其优化到$n^2logn$，那么这里需要离散化来确定哪些比它小。(详见代码注释) 上代码： #include&lt;bits/stdc++.h&gt; #define maxn 2005 using namespace std; typedef long long ll; const ll mod=1000000007; int n,a[maxn],aa[maxn]; ll dp[maxn][maxn];//以i结尾,长度为j ll cnt[maxn]; ll jc[maxn]; ll c[maxn][maxn];//c[i][j]：长度为i，在j前面(lowbit长度)的方案数 void ready(){ jc[0]=1; for(ll i=1;i&lt;=2000;i++) jc[i]=jc[i-1]*i%mod; } void update(int w,int i,ll d){ while(i&lt;=n){ c[w][i]=(c[w][i]+d)%mod; i+=(i&amp;-i); } } ll sum(int w,int i){ ll res=0; while(i&gt;0){ res=(res+c[w][i])%mod; i-=(i&amp;-i); } return res; } void init(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); /*for(int i=1;i&lt;=n;i++){ rear=0; for(int j=i;j&lt;=n;j++){ int t=upper_bound(q+1,q+rear+1,a[j])-q; if(t==rear+1) q[++rear]=a[j];else{ if(t==1) continue;//头不能更换 来保证独立性，以当前为开头 q[t]=a[j]; } cnt[t]++; for(int k=t-1;k&gt;=2;k--) cnt[k]++; } }*///干！不行aaaaaaaaaaaa memcpy(aa,a,sizeof(a)); sort(aa+1,aa+n+1); int cntt=unique(aa+1,aa+n+1)-aa-1; /*for(int i=1;i&lt;=n;i++){//枚举开头 memset(c,0,sizeof(c)); dp[i][1]=1; int pos=lower_bound(aa+1,aa+n+1,a[i])-aa; update(1,pos,1); for(int j=2;j&lt;=n;j++){ ll calc=0; for(int k=i+1;k&lt;=n;k++){ pos=lower_bound(aa+1,aa+n+1,a[k])-aa; int tt=sum(j-1,pos-1); calc+=tt; update(j,pos,tt); } dp[i][j]=calc; } }*/ for(int i=1;i&lt;=n;i++){ dp[i][1]=1; for(int j=2;j&lt;=i;j++){ int pos=lower_bound(aa+1,aa+cntt+1,a[i])-aa; dp[i][j]=sum(j-1,pos);//等于长度为j-1的 } for(int k=1;k&lt;=i;k++){ int pos=lower_bound(aa+1,aa+cntt+1,a[i])-aa; update(k,pos,dp[i][k]); } } for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) cnt[j]=(cnt[j]+dp[i][j])%mod; ll all=0; for(int i=1;i&lt;=n;i++){ all=(all+cnt[i]*jc[n-i]%mod)%mod; } ll del=0; for(int i=2;i&lt;=n;i++){ del=(del+cnt[i]*i%mod*jc[n-i]%mod)%mod; } ll ans=(all-del+mod)%mod; printf(&quot;%lld&quot;,ans); } int main(){ ready(); init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>LIS</tag>
        <tag>离散化</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[已经没有什么好害怕的了]]></title>
    <url>%2F2018%2F10%2F29%2F38%2F</url>
    <content type="text"><![CDATA[Description给定一个长度为n只包含左括号和右括号的序列，现在小R想要知道经过每一个位置的合法子串有多少个（空串是一个合法的串，如果A和B都是合法的串，那么(A)和AB都是合法的串）。 共T组数据，对于每组数据，输出一个整数表示答案，令$ans_i$为经过第i个位置的子串个数，那么你需要输出$\sum^{n}_{i=1}(i×ans_i mod 1e9+7)$。$（1≤T≤10,n≤10^6）$ Solution首先对于每一个合法的串内部扩起来的，我们对它所涵盖的加1，那么会想到差分，如图:即为差分的方式:在左端点加1，在右端点+1的地方减1.首先是可以暴力维护的，但是肯定会超时，那么我使用递推来将其优化到O(n). 上代码： #include&lt;bits/stdc++.h&gt; #define maxn 1000005 using namespace std; typedef long long ll; const ll mod=1000000007; int t; char s[maxn]; int st[maxn],top=0,q[maxn],h[maxn],pre[maxn],next[maxn]; ll val[maxn];//q,h:前后括号 void init(){ memset(h,0,sizeof(h)); memset(q,0,sizeof(q)); memset(pre,0,sizeof(pre)); memset(next,0,sizeof(next)); scanf(&quot;%s&quot;,s+1); int len=strlen(s+1); top=0; for(int i=1;s[i];i++){ if(s[i]==&#39;(&#39;) st[++top]=i; else if(top) h[st[top]]=i+1,q[i+1]=st[top],top--;//标记后一个括号和前一个括号 } int i; for(i=len+1;i&gt;=1;i--){next[i]++;next[q[i]]+=next[i];} //对前面括号造成贡献 for(i=1;s[i];i++){pre[i]--;pre[h[i]]+=pre[i];} //对后面括号造成贡献 for(i=1;s[i];i++) val[i]=pre[i]+next[i]; for(i=1;s[i];i++) val[i]+=val[i-1];//差分 ll ans=0; for(i=1;s[i];i++) ans=(ans+val[i]*1ll*i%mod); printf(&quot;%lld\n&quot;,ans); } int main(){ scanf(&quot;%d&quot;,&amp;t); for(int i=1;i&lt;=t;i++) init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>差分</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树什么的最讨厌了]]></title>
    <url>%2F2018%2F10%2F29%2F37%2F</url>
    <content type="text"><![CDATA[Description这是小R写的线段树的一段建树代码： void buildtree(int k1,int l,int r){ if(l==r)return; int mid=(l+r)/2; buildtree(k1*2,l,mid);buildtree(k1*2+1,mid+1,r); } 只要调用buildtree(1,0,n)就可以得到一颗线段树了。显然，一颗线段树一共有O(n)个节点，因为每一个节点都代表了一个不同的区间，所以线段树上一共出现了O(n)个不同的区间。 现在小R给了你一个区间[L,R]，他想要你告诉他一个最小的不超过lim的n使得区间[L,R]出现在了用buildtree(1,0,n)建出来的线段树中，若无解输出−1。（T组数据，$T≤100,lim≤2×10^9,0≤L≤R≤10^9,\frac{L}{R−L+1}≤2×10^3$） Solution实际上就是以子区间回溯到根区间，那么对于一个自区间(l,r)它有可能变为$(l-(r-l+1),r) (l-(r-l+2),r) (l,r+r-l+1) (l,r+r-l)$，由于$\frac{L}{R−L+1}≤2×10^3$，所以极限40几次，加上剪枝可以过掉。这里注意第4个转换要特判l!=r否则会陷入循环。另外考场傻了没注意$l-(r-l+1)&lt;0$也要返回，因为如果这个都小于0，那么向左会小于0，而向右后再向左会更小于0 上代码： #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int t; ll l,r,lim; ll ans; void dfs(ll l,ll r){ if(l==0){ ans=min(ans,r); return; } if(l&lt;0) return; if(r&gt;lim) return; if(r&gt;ans) return; if(l&gt;r) return; if(l-(r-l+1)&lt;0) return;//剪枝要给够，要不然一个二个跑到lim+1那要得a，因为如果这里 //不满足，那么像左会小于0，而向右后再向左会更小于0 dfs(l-(r-l+1),r);//右子树 dfs(l-(r-l+2),r);//右子树 左边比右边多一个 先找到0先约束 dfs(l,r+r-l+1);//左子树 if(l!=r)dfs(l,r+r-l);//左子树 } void init(){ scanf(&quot;%lld%lld%lld&quot;,&amp;l,&amp;r,&amp;lim); ans=lim+1;//将限制降低 //if(l==r){printf(&quot;%d\n&quot;,l);return;} dfs(l,r); if(ans==lim+1) printf(&quot;-1\n&quot;); else printf(&quot;%lld\n&quot;,ans); } int main(){ scanf(&quot;%d&quot;,&amp;t); for(int i=1;i&lt;=t;i++) init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择难题]]></title>
    <url>%2F2018%2F10%2F29%2F36%2F</url>
    <content type="text"><![CDATA[DescriptionZZr经过努力奋斗终于考入了UKP University！ 初来乍到的ZZr很快发现自己的智商水平是远超同学的，于是他选了三门极具难度的数学课：离散数学、数学分析、高等代数。学习数学是一定要通过做练习来提高成绩的，于是ZZr购买了一套奇怪的练习题，这套练习题被分为了p节。每节都有三道难题，分别是关于离散数学、数学分析和高等代数的。第ii节中的三道题的难度分别为$a_i,b_i,c_i$。其中ai表示离散数学对应题目的难度，bi表示数学分析对应题目的难度，ci表示高等代数对应题目的难度，ai,bi,ci都是非负整数。 然而ZZr毕竟才艺出众，丰富的社团活动让他并没有多少时间做练习，于是他决定只从每节中选且仅选一道题来完成。但ZZr发现自己竟然忙到选择题目的时间都没有，于是他委托作为舍友的你帮他选择。 经过研究发现，完成这套奇怪的练习题获得的总能力提高度D有一个奇怪的计算方式：总能力提高度为三门学科各自的能力提高度之和，而每门学科的能力提高度为所做的该学科难题中的难度的最大值，如果该学科没有做题，则其能力提高度为0。为了避免被ZZr远远甩下，你决定好好研究一下帮ZZr如何选择题目，使得ZZr能获得的总能力提高度最小，并计算出这个最小值。 Input输入的第一行包含一个正整数n，表示这套练习题共有n节。 接下来共n行，每行包含三个非负整数ai,bi,ci，其含义如上文所述。 Output输出包含一个正整数D，表示ZZr能获得的最小总能力提高度。 Sample Input31 2 1001 100 3100 4 5 Sample Output5 Hint全部测试点：$n&lt;=10^6,a_i,b_i,c_i&lt;=10^8$。 时空限制：2s/1GB Solution首先观察这题数据范围，会发现特别限制$diff(a_i)$，在考场上就想着用$diff(a_i) \ast n$的算法，结果思路是正确的！那么我们发现这道题是一个三元组，不太好搞，所以枚举maxa来限制一维，所以小于等于maxa的三元组就被干掉了。剩下便是二元组，那么对于两个二元组$(b_i,c_i)(b_j,c_j)$如果$b_i&lt;=b_j\&amp;c_i&lt;=c_j$那么前者就是无用的，因为后者将它覆盖，那么我们若将二元组按b_i为第一关键字从小到大排序，就会发现第二维是单减的(要不然它就无用了). 所以我们可以一边遍历n来找出$min(b_i+c_{i+1})​$即为最佳的maxb和maxc选项，可以想象一下，两侧都比它们小。 那么这样我们就能达到$diff(a_i) \ast n$的复杂度，但这对于$n=10^6$还远远不够，那么不是O(n)就是$nlog_n$了。那么我们用set来将后面的n尽量降到$log_n$： 用lower_bound来找到第一个大于等于$b_i$的点，如果$c_i$小于它的话那么i无用，所以不加入，否则向前找无用的删除，再用另一个multiset来维护最小值，要注意细节实现. 这样的话每个点都最多加入一次，删除一次，所以复杂度是logn的。 (p.s更新:实际上对minn的维护并不是logn的因为最坏会出现$n^2$个最小值，然而这种上界很不满，所以只会t一个点) 上代码： #include&lt;bits/stdc++.h&gt; using namespace std; #define maxn 1000006 #define inf 0x3f3f3f3f struct node{ int a,b,c; friend bool operator&lt;(node x,node y){ if(x.a!=y.a) return x.a&gt;y.a; else return x.b&lt;y.b; } }nd[maxn]; int n; void _scanf(int &amp;x){ x=0; char c=getchar(); while(c&gt;&#39;9&#39;||c&lt;&#39;0&#39;) c=getchar(); while(c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;){x=x*10+c-&#39;0&#39;;c=getchar();} } struct nd1{ int b,c; friend bool operator&lt;(nd1 x,nd1 y){ if(x.b!=y.b)return x.b&lt;y.b; else return x.c&gt;y.c; } }; set&lt;nd1&gt;s; set&lt;nd1&gt;::iterator it,itt,kk; multiset&lt;int&gt;minn; int ans=0x3f3f3f3f; void init(){ _scanf(n); for(int i=1;i&lt;=n;i++){ _scanf(nd[i].a);_scanf(nd[i].b);_scanf(nd[i].c); } sort(nd+1,nd+n+1); s.insert((nd1){0,inf});s.insert((nd1){inf,0}); minn.insert(0); for(int i=1;i&lt;=n;i++){//枚举maxa是多少 if(nd[i].a!=nd[i-1].a) ans=min(ans,nd[i].a+*minn.begin()); nd1 t=(nd1){nd[i].b,nd[i].c}; it=s.lower_bound(t); kk=it;it--; //printf(&quot;%d %d&quot;,it-&gt;b,it-&gt;c); if(nd[i].c&lt;kk-&gt;c) continue;//不要加入 int tmp=nd[i].c,pre=kk-&gt;c; while(it-&gt;c&lt;tmp){ minn.erase(minn.find(pre+it-&gt;b)); pre=it-&gt;c; itt=it; it--; s.erase(itt); } minn.erase(minn.find(pre+it-&gt;b)); s.insert(t); minn.insert(it-&gt;b+nd[i].c); minn.insert(nd[i].b+kk-&gt;c); } //在外面判a不选 ans=min(ans,*minn.begin()); printf(&quot;%d&quot;,ans); } int main(){ //freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;2.txt&quot;,&quot;w&quot;,stdout); init(); return 0; }]]></content>
      <categories>
        <category>noip模拟赛</category>
      </categories>
      <tags>
        <tag>set</tag>
        <tag>二元组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[squirrel]]></title>
    <url>%2F2018%2F10%2F29%2F35%2F</url>
    <content type="text"><![CDATA[Description小B在University of Stupid Aliens玩耍时目睹了一群松鼠传话的一幕！ 作为一个杰出的语言学家，小B发现了松鼠传话时有如下规律：有nn只松鼠站在一条直线上，从左到右依次编号为1,2,3,…,n。每只松鼠所说的话可以被看作是一个整数。设编号为ii的松鼠说的话为$s_i$。编号为1,2的松鼠要说的话可以被分别认为是某一常数a的某次幂（即分别为$a^{m_1}和a^{m_2}$）。 但松鼠们的大脑容量有限，所以在一切计算过程中它们会将所计算的结果取除以某一正整数pp的余数（即modp）。注意，编号为1,21,2的松鼠在计算幂时也会取余数（即$s_1, s_2$分别为$a^{m_1}modp和a^{m_2}modp$）。 接下来，编号为i(i≥3)的松鼠要说的话是站在它左边的第二只松鼠的话α次方乘左边的第一只松鼠的话β次方。也就是说，有$s_i=s^α_{i−2}⋅s^β_{i−1}modp(i≥3)$。小B对松鼠们传话的方式十分痴迷，他现在已经知道前两只松鼠说话的内容，他想让你告诉他任意一只他指定的松鼠将会说什么。（你可以认为这里的松鼠有足够多只。） Input输入的第一行包含六个正整数$a,m_1,m_2,α,β,p$。各字母的含义如上文所述。 第二行包含一个正整数K，表示小B的问题个数。接下来K行每行一个正整数$b_1,b_2,…,b_K$，表示小B想知道编号为$b_i$的松鼠所说的话。 Output输出包含K行。每行一个整数，第ii行表示编号为$b_i$的松鼠所说的话。 Sample Input2 1 1 1 1 107523456 Sample Output2483242 Hint对于全部数据，$a&lt;p&lt;=5∗10^3,K&lt;=10^3$。 时空限制：1s/512MB Solution首先给出两个降幂公式:欧拉降幂公式：$a^{x}mod p = a^{x \mod \phi_{p}+\phi_{p} }mod p (x ≥ \phi_{p})$。其中$\phi_{p}$为欧拉函数，其意义是小于等于p且与p互质的数的个数。请注意该公式的成立条件：x≥$\phi_{p}$。 当p是质数时，该公式可简化为费马小定理：$a^x \mod p = a^{x \mod (p−1) }mod p$。此公式对任意的x均成立，不需要满足x≥p−1。 首先我们发现p是在5000以内的，那么跑一遍欧拉函数即可。然后分别动用两个公式可以将幂降到很小，然后用快速幂只需几十次就可以计算出。这里给出快速幂非递归写法. ll qkpow(ll k,int pos){ ll ans=1,base=k; while(pos){ if(pos&amp;1)ans=ans*base%mod; base=base*base%mod; pos=pos&gt;&gt;1; } return ans; } 发现$b_i$很大，肯定就tm想到循环节，事实上只要m1和m2再次出现就会循环，而由于p&lt;=5000，所以最多有$5000^2$种，所以可以很短时间求出，再一次输出即可，注意细节实现，比如前面的一些q可能还没开始循环，要单独输出比如4 3 7 4 3，对于1的询问就不能再mod。 上代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; #include&lt;cctype&gt; #include&lt;queue&gt; #include&lt;set&gt; #include&lt;map&gt; using namespace std; typedef long long ll; int phi[5005]; bool isp[5005]; void ready(int n){ memset(isp,1,sizeof(isp)); for(int i=1;i&lt;=n;i++) phi[i]=i; isp[0]=isp[1]=0 ; for(int i=2;i&lt;=n;i++)if(isp[i]){ phi[i]=phi[i]/i*(i-1); for(int k=2;k*i&lt;=n;k++) { isp[i*k]=0; phi[i*k]=phi[i*k]/i*(i-1); } } } ll a,mod,m1,m2,alpha,beita; int k;ll q[1005]; struct node{ int x,y; friend bool operator&lt;(node a,node b){ if(a.x!=b.x) return a.x&lt;b.x; else return a.y&lt;b.y; } }; ll qkpow(ll t,int pos){ if(pos==0) return 1; if(pos==1) return t; ll tt=qkpow(t,pos/2); if(pos&amp;1) return tt*tt%mod*t%mod; else return tt*tt%mod; } int zq,qd; ll t1,t2; map&lt;node,int&gt;mp; map&lt;int,ll&gt;mpv; void solve1(){//费马小定理 m1=m1%(mod-1);m2=m2%(mod-1); alpha=alpha%(mod-1);beita=beita%(mod-1); t1=qkpow(a,m1);t2=qkpow(a,m2);mpv[1]=t1; int pos=3;int ans; while(1){ node t=(node){m1,m2}; if(!mp.count(t)) mp[t]=pos-1,mpv[pos-1]=qkpow(a,m2); else{ zq=pos-1-mp[t],qd=mp[t]-1;//哥哥a,眼睛好点吧 break; } ans=(m1*alpha+m2*beita)%(mod-1); m1=m2;m2=ans; pos++; } } int px; int calc(ll x){ if(x&gt;=px) return x%px+px; return x; } void solve2(){//欧拉函数 px=phi[mod]; m1=calc(m1),m2=calc(m2); alpha=calc(alpha);beita=calc(beita); t1=qkpow(a,m1);mpv[1]=t1; int pos=3;int ans; while(1){ node t=(node){m1,m2}; if(!mp.count(t)) mp[t]=pos-1,mpv[pos-1]=qkpow(a,m2); else{ zq=pos-1-mp[t],qd=mp[t]-1;//哥哥a,眼睛好点吧 break; } ans=calc(m1*alpha+m2*beita); m1=m2;m2=ans; //printf(&quot;%d %d %lld\n&quot;,m1,m2,qkpow(a,m2)); pos++; } } void init(){ scanf(&quot;%lld%lld%lld%lld%lld%lld&quot;,&amp;a,&amp;m1,&amp;m2,&amp;alpha,&amp;beita,&amp;mod); scanf(&quot;%d&quot;,&amp;k); for(int i=1;i&lt;=k;i++) scanf(&quot;%lld&quot;,&amp;q[i]); if(isp[mod]) solve1(); else solve2(); for(int i=1;i&lt;=k;i++){ if(q[i]&gt;=qd){ int kk=(q[i]-qd+1)%zq; if(kk==0) kk=zq; kk=qd+kk-1; printf(&quot;%lld\n&quot;,mpv[kk]); } else printf(&quot;%lld\n&quot;,mpv[q[i]]); } } int main(){ //freopen(&quot;squirrel.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;squirrel.out&quot;,&quot;w&quot;,stdout); ready(5000); init(); return 0; }]]></content>
      <categories>
        <category>noip模拟赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>欧拉函数</tag>
        <tag>费马小定理</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[密码锁]]></title>
    <url>%2F2018%2F10%2F29%2F34%2F</url>
    <content type="text"><![CDATA[Description小M有一把密码锁，由NN个开关组成。 一开始的时候，所有开关都是关上的。当且仅当其中指定的K个开关：$x_1,x_2,x_3,…,x_k$为开，其他开关为关时，密码锁才会打开。 你可以进行SS种的操作，每种操作有一个参数$size_i$，表示假如你选择了第i种的操作的话，你可以任意选择连续的$size_i$个开关，把它们全部取反（原来是开的变为关，原来是关的变为开）。 你的任务很简单，帮助小M计算最少需要多少步才能打开密码锁，或者如果无解的话，请输出−1。 Input输入的第一行有三个正整数N,K,S，他们的意义如题目所述。 第二行有K个正整数，表示开关$x_1,x_2,x_3,…,x_k$必须为开，保证$x_i$两两不同。 第三行有S个正整数，其中第ii个表示$size_i$，可能有重复的$size_i$可能有重复。 Output输出文件仅一行一个整数，表示答案。 Sample Input10 8 21 2 3 5 6 7 8 93 5 Sample Output2 Hint对于50%的数据，1≤N≤20，1≤K≤5，1≤S≤3； 对于另外20%的数据，1≤N≤10000，1≤K≤5，1≤S≤30； 对于100%的数据，1≤N≤10000，1≤K≤10，1≤S≤100。 时空限制：1s/512MB Solution首先会注意到这题的数据范围，前50%用撞鸭dp就可以过但要注意群体异或避免逐个修改。(考试时真的傻了)即$(1&lt;&lt;sz_i)&lt;&lt;j$这样可以刚好异或一段。 其次观察到k最大只有10，那么撞鸭上限是20，随后又会想到这里每覆盖一段实际上是加1，而又要mod2，发现是个01差分。那我们先将其中要开的开关在段中绘好，那么最终就是要将其变为全0.将其转化为差分数组，最多就会有20个1，每赋一段l,r，会在l处+1,r+1处+1，相当于将l处的1转化到r+1,若r+1也为1就消为了0，实际上我们将所有1匹配即可。然后可以bfs记录一遍dist{i,j}，只需要O(n)跑。最后用一个撞鸭dp来记录所有点全部匹配的最小步数即可。 注意这里裸的dp是$总状态数\ast(2\ast k)^2$，所以我们先固定一个新增加的元素，然后枚举与它匹配的元素来达到最小，从而变成了$总状态数\ast2\ast k$. 上代码： #include&lt;bits/stdc++.h&gt; #define maxk 10005 #define maxs 10005 #define maxn 10005 using namespace std; int n,k,s,x[maxk],sz[maxs]; int a[maxn]; int e[35][35]; int dist[maxn]; bool vis[maxn]; int pos[maxn],np=0; void bfs(int s){ queue&lt;int&gt;q; memset(dist,0x3f,sizeof(dist)); memset(vis,0,sizeof(vis)); q.push(s); dist[s]=0;vis[s]=1; while(!q.empty()){ int t=q.front();q.pop(); for(int i=1;i&lt;=s;i++){ int tt=t+sz[i]; if(tt&lt;=n+1&amp;&amp;!vis[tt]){ dist[tt]=dist[t]+1; vis[tt]=1; q.push(tt); } } for(int i=1;i&lt;=s;i++){ int tt=t-sz[i]; if(tt&gt;=1&amp;&amp;!vis[tt]){ vis[tt]=1; dist[tt]=dist[t]+1; q.push(tt); } } } for(int i=1;i&lt;=n+1;i++){ if(!a[i]) continue; e[pos[s]][pos[i]]=dist[i]; } } int dp[1&lt;&lt;22]; void init(){ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;k,&amp;s); for(int i=1;i&lt;=k;i++) scanf(&quot;%d&quot;,&amp;x[i]),a[x[i]]=1; for(int i=1;i&lt;=s;i++) scanf(&quot;%d&quot;,&amp;sz[i]); sort(sz+1,sz+s+1);s=unique(sz+1,sz+s+1)-sz-1; for(int i=n+1;i&gt;=1;i--) a[i]^=a[i-1];//不会影响前面 for(int i=1;i&lt;=n+1;i++) if(a[i]) pos[i]=++np; for(int i=1;i&lt;=n+1;i++) if(a[i]) bfs(i); memset(dp,0x3f,sizeof(dp)); dp[0]=0; int all=(1&lt;&lt;np)-1; for(int i=0;i&lt;=all;i++){ int pre=-1; for(int j=1;j&lt;=np;j++){ if(!(i&amp;(1&lt;&lt;(j-1))))continue; if(pre==-1) pre=j; else dp[i]=min(dp[i],dp[i-(1&lt;&lt;(j-1))-(1&lt;&lt;(pre-1))]+e[j][pre]); } } if(dp[all]==0x3f3f3f3f) printf(&quot;-1&quot;); else printf(&quot;%d&quot;,dp[all]); } int main(){ init(); return 0; }]]></content>
      <categories>
        <category>noip模拟赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>差分</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逃脱]]></title>
    <url>%2F2018%2F10%2F28%2F33%2F</url>
    <content type="text"><![CDATA[Description小 M 的宠物猫 CC 昨天干了背叛主人的事，于是她逃到一个远方的迷宫躲藏了起来。这个迷宫包含 N（用 1..N 编号） 个路口和 N-1 条连接两个路口的双向隧道。 所以每两个路口之间都有唯一的路径。每个只与一条隧道相连的路口都是迷宫的出口。小 M 非常生气， 决定派出一些小狗从不同的出口出发尝试抓住 CC。 小狗和 CC 的移动速度相同（在每个单位时间内，每个小狗都可以从一个路口移动到相邻的一个路口，同时 CC 也可以这么做，当然他们在任意单位时间都可以不移动，停留在原来的路口上）。 小狗们和 CC 总是知道对方在哪里。如果在任意时刻，某个小狗和 CC 处于同一个路口或在穿过同一个隧道， 小狗就可以抓住 CC。反过来，如果 CC 在小狗们抓住她之前到达一个出口， 于是 CC 就逃脱了。CC 不确定她能否成功逃脱，这取决于小狗的数量。给定 CC 当前所在的路口 S，帮助小 M 确定为了抓住 CC 所需要的小狗的最小数量。假定小狗们会自己选择最佳的方案来安排他们出发的出口。 Input输入的第一行包含 N 和 S，分别表示路口数目和 CC 当前所在路口的编号。接下来的 N–1 行，每行有两个整数（在 1~N 范围内）描述连接两个路口的一条隧道。 Output输出为了确保抓住 CC 所需的小狗的最小数量 Sample Input7 11 21 33 43 54 65 7 Sample Output3 Hint对于 20%的数据： N≤3 00对于 50%的数据： N≤5 000对于 100%的数据： N≤100 000 Solution首先对于起点即为出口的特判，当且仅当起点只有一个儿子，这时只需一只狗即可。然后发现最坏情况是每个叶子节点都要一只狗，但狗可以跑过去拦截，所以将顶点与叶子节点路程割半，然后可以颜色染上下半段部分（使用树上倍增精准定位）当发现遍历到染过的时可以减1（用这次染色代替那次）如此下来便最优。而由于是触碰返回，所以复杂度实际上是O（n）的。 上代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;cctype&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;set&gt; #define maxn 100005 using namespace std; struct eage{ int to,next; }e[maxn&lt;&lt;1]; int np=0,first[maxn]; void add(int u,int v){ e[++np]=(eage){v,first[u]}; first[u]=np; } int n,s,x,y,dep[maxn],fa[maxn][18]; int st[maxn],top=0; bool ok=false; void dfs(int i,int f,int d){ dep[i]=d;fa[i][0]=f; for(int j=1;j&lt;=17;j++) fa[i][j]=fa[fa[i][j-1]][j-1]; int chd=0; for(int p=first[i];p;p=e[p].next){ int j=e[p].to; if(j==f) continue; chd++; dfs(j,i,d+1); } if(i==s&amp;&amp;chd==1) ok=true; if(chd==0) st[++top]=i; } /*int lca(int u,int v){ if(dep[u]&lt;dep[v]) swap(u,v); int x=dep[u]-dep[v]; for(int i=0;i&lt;=17;i++){ if((1&lt;&lt;i)&amp;x) u=fa[u][i]; } if(u==v) return u; for(int i=17;i&gt;=0;i--){ if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i]; } return fa[u][0]; }*/ bool color[maxn]; int ans=0; void dfss(int i){ if(color[i]){ans--;return;} color[i]=1; for(int p=first[i];p;p=e[p].next){ int j=e[p].to; if(j==fa[i][0])continue; dfss(j); } } void init(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;s); for(int i=1;i&lt;n;i++){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y);add(y,x); } dfs(s,0,0); if(ok==true) printf(&quot;1&quot;); else{ for(int i=1;i&lt;=top;i++){ int x=dep[st[i]]-dep[s]; x=x/2; int u=st[i]; for(int j=0;j&lt;=17;j++){ if(x&amp;(1&lt;&lt;j)) u=fa[u][j]; } ans++; dfss(u); } printf(&quot;%d&quot;,ans); } } int main(){//实际复杂度只要O(n) 因为触碰返回 //freopen(&quot;escaping.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;escaping.out&quot;,&quot;w&quot;,stdout); init(); return 0; }]]></content>
      <categories>
        <category>noip模拟赛</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>树上倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红绿灯]]></title>
    <url>%2F2018%2F10%2F25%2F32%2F</url>
    <content type="text"><![CDATA[Description小R最近感觉很不开心，所以他打算去炸了一所和他距离906.5公里的高中。 现在小R打算出发前往他的目的地，和他的方案有关的交通网可以抽象为一张nn个点mm条无向边的无向图，小R要从1号点到达nn号点。现在经过事先的资料收集，小R已经拿到了这张无向图：第ii条边连接着uiui和vivi，长度为didi。 小R根据这些资料，很快便规划出了最短路径，然而很快，小R便发现他忽略一个至关重要的东西：红绿灯。 为了简化为题，我们假定每一条边上都有一个红绿灯，每一个红绿灯都可以用ki,li,riki,li,ri来定义，即只有在时刻数模kiki的值在区间[li,ri][li,ri]的时刻，小R才能在这条边上移动（每一时刻小R能前进1单位长度）。 举个例子，现在有一条长度为7的边，小R到达它其中一个端点的时刻是3，k=3,l=1,r=2k=3,l=1,r=2，小R想要通过这条边。首先他等到了时刻4，然后再这条边上前进了2单位长度，然后他又必须停下1单位时间，然后再前进两个单位…最终小R到达另一个端点的时刻为14。 现在小R打算知道从1到这张图的每一个顶点最少要花多少时间，你可以告诉他吗？（假设小R在第0时刻出发） Input第一行输入两个整数n,m。 接下来m行每行6个整数$u_i,v_i,d_i,k_i,l_i,r_i$描述了一条边。保证存在一种方案可以在有限的时间内到达每一个节点。 Output输出n行，第i行表示到达第i个点的最少时间。 Sample Input3 21 2 3 3 0 22 3 7 3 1 2 Sample Output0314 Hint对于100%的数据，$n≤5\times10^5,m≤10^6,0≤l_i≤r_i&lt;k_i≤20,1≤d≤106$时间限制： 3s空间限制： 512MB Solution因为每天边权都是正的，先到等红绿灯总不比后到更差，所以可以跑一遍dij，主要处理一下每条边的耗费时间，注意细节。p.s.代码中计算长度时有小技巧，巧妙的避免了求刚好走完时的多走的路程，而将其转化为和其他一样的最后走一段l+len，妙a。（这种减1的小技巧在其他题也适用） 上代码: #include&lt;bits/stdc++.h&gt; #define maxn 500005 #define maxm 1000005 using namespace std; typedef long long ll; struct eage{ int to,next;ll len;int k,l,r; }e[maxm&lt;&lt;1]; int np=0,first[maxn]; void add(int u,int v,ll len,int k,int l,int r){ e[++np]=(eage){v,first[u],len,k,l,r}; first[u]=np; } int n,m,x,y,a1,a2,a3;ll z; struct node{ ll v;int id; friend bool operator&lt;(node a,node b){ return a.v&gt;b.v; } }; priority_queue&lt;node&gt;q; ll dist[maxn]; bool vis[maxn]; ll calc(int k,int l,int r,ll len,ll now){ ll dis=0; now=now%k; if(now&lt;l) dis+=(l-now),now=l; if(now&lt;=r){ int mv=r-now+1; if(mv&gt;=len) return len+dis;//直接走达 dis+=mv; len-=mv;now=r+1; } if(now!=k){ dis+=k-now; } int d=r-l+1; int cnt=(len-1)/d; len=(len-1)%d+1; dis+=(ll)1ll*cnt*k; dis+=(l+len); return dis; } void dij(){ memset(dist,0x3f,sizeof(dist)); memset(vis,0,sizeof(vis)); dist[1]=0; q.push((node){dist[1],1}); while(!q.empty()){ node t=q.top();q.pop(); int i=t.id; if(vis[i]) continue; vis[i]=1; for(int p=first[i];p;p=e[p].next){ int j=e[p].to; ll dis=calc(e[p].k,e[p].l,e[p].r,e[p].len,t.v); if(dist[j]&gt;dis+dist[i]){ dist[j]=dis+dist[i]; q.push((node){dist[j],j}); } } } } void init(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++){ scanf(&quot;%d%d%lld%d%d%d&quot;,&amp;x,&amp;y,&amp;z,&amp;a1,&amp;a2,&amp;a3); add(x,y,z,a1,a2,a3); add(y,x,z,a1,a2,a3); } dij(); for(int i=1;i&lt;=n;i++) printf(&quot;%lld\n&quot;,dist[i]); } int main(){ init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>dijsktra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[祎隋]]></title>
    <url>%2F2018%2F10%2F24%2F31%2F</url>
    <content type="text"><![CDATA[相框里的那些闪闪发光的我们啊 在夏天发生的事，你忘了吗 多年之后，他是否还走在这条路上想起那欲擒故纵实是欲纵故擒….忙里偷闲你恬然一笑使时间一止阳光下，被放大的灰尘光阴里，被遗忘的我们]]></content>
      <categories>
        <category>杂诗</category>
      </categories>
      <tags>
        <tag>杂诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列]]></title>
    <url>%2F2018%2F10%2F24%2F30%2F</url>
    <content type="text"><![CDATA[Description你有一个长度为nn的序列$a_1,a_2,…,a_n$，你可以选择一段区间(l,r) (1≤l≤r≤n)，并且把$a_l,a_l+1,…,a_r$这些数字加上一个相同的数字d(−x≤d≤x)。 你想让加完之后的数字的最长上升子序列尽量长。也就是说找到最大的k满足$t_1&lt;t_2&lt;⋯&lt;t_k$，且$a_{t1}&lt;a_{t2}&lt;⋯&lt;a_{tk}$。 Input第一行两个整数n,x，接下来一行n个正整数$a_1,a_2,…,a_n$。 注意：你可以把数字改成负数。 Output输出一个整数，表示答案，即最长的LIS长度。 Sample Input7 57 3 5 2 7 3 4 Sample Output5 Hint对于 100% 的数据，有$1≤n≤200000,0≤x≤109,1≤a_i≤10^9$。时间限制：2s空间限制：512MB Solution首先我们对于要选择的区间l,r考虑，发现以l为起点开始增加，肯定要包含其后的最长上升序列，然后再尽可能贪心的增加最大，使前面有更多满足的。所以我们对于每一个i统计一下它加上x后前面最长的LIS和后面最长的LIS，这样依次取最大就好。 然后对于求LIS，用二分查找和贪心nlogn求，反向求下降也是一样的，只要理解本质。tips:注意lower_bound和upper_bound两个求&gt;=和&gt;，前者是用于严格上升子序列，而后者是非严格，可以想象一下。举个栗子:3 4 6 现在加入4，如果严格为2，否则为3. 上代码： #include&lt;bits/stdc++.h&gt; #define maxn 200005 using namespace std; int n,a[maxn],hm[maxn],x; int st[maxn],top=0; bool cmp(int a,int b){ return a&gt;b; } void init(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;x); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=n;i&gt;=1;i--){ int t=lower_bound(st+1,st+top+1,a[i],cmp)-st; if(t&gt;top) st[++top]=a[i];else st[t]=a[i];//贪心 hm[i]=t; } top=0; int ans=0; for(int i=1;i&lt;=n;i++){ int t=lower_bound(st+1,st+top+1,a[i]+x)-st; ans=max(ans,t+hm[i]-1); t=lower_bound(st+1,st+top+1,a[i])-st; if(t&gt;top) st[++top]=a[i];else st[t]=a[i]; } printf(&quot;%d&quot;,ans); } int main(){ init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>LIS</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彩虹糖]]></title>
    <url>%2F2018%2F10%2F24%2F29%2F</url>
    <content type="text"><![CDATA[Description有1~m之间的整数，A有$tot_a$个，B有$tot_b$个，不会有两个相同的数字出现。有n堆数字，从A开始操作，它能对一堆彩虹糖进行操作当且仅当它有这个数字，并将其分为新的两堆非空的数字。两人都使用最优策略，当一人无法操作时另一人获胜。 Inputn,m$tot_a$$a_i$$tot_b$$b_i$$p_i$ Output一行表示游戏结果，A胜输出”Pomegranate”,B胜输出”Orange”. Hint$n&lt;=10^6,m&lt;=10^4$ Solution首先，我们要探究性质，了解到每一堆先选后选无关系，因为总会按最优策略一样分解产生相同贡献。然后我们设f(x)表示x这堆对先手造成多走的贡献，那么A肯定想要最大化f(i)，而B则想要最小化f(i)，而恰好这里的每个拥有的数都是唯一的，所以很好处理(抽空了解一下博弈论的SG函数和超现实数，如果这里数会重貌似就要超现实数？？？).这里的f(i)是拥有可加性的，分解嘛。对于每个A拥有的f(i):$f_i=max(f_i,f_j+f_{i-j}+1)$对于每个B拥有的f(i):$f_i=min(f_i,f_j+f_{i-j}-1)$ 这样对于每一个$p_i$我们将贡献加起来如果最终&lt;=0就B赢，否则A赢，A先走嘛 上代码： #include&lt;bits/stdc++.h&gt; #define maxn 1000005 #define maxm 10005 using namespace std; int n,m,tota,totb,a[maxm],b[maxm],p[maxn]; int visa[maxm],f[maxm]; void init(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); scanf(&quot;%d&quot;,&amp;tota); for(int i=1;i&lt;=tota;i++){ scanf(&quot;%d&quot;,&amp;a[i]); visa[a[i]]=1; } scanf(&quot;%d&quot;,&amp;totb); for(int i=1;i&lt;=totb;i++){ scanf(&quot;%d&quot;,&amp;b[i]); visa[b[i]]=-1; } for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;p[i]); for(int i=2;i&lt;=m;i++){ if(!visa[i]) continue; for(int j=1;j&lt;i;j++){ if(visa[i]==1) f[i]=max(f[i],f[i-j]+f[j]+1); else f[i]=min(f[i],f[i-j]+f[j]-1); } } int ans=0; for(int i=1;i&lt;=n;i++){ if(p[i]&gt;m) continue; ans+=f[p[i]]; } if(ans&lt;=0) printf(&quot;Orange&quot;); else printf(&quot;Pomegranate&quot;); } int main(){ init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分解]]></title>
    <url>%2F2018%2F10%2F24%2F28%2F</url>
    <content type="text"><![CDATA[Description你有一个数字n，你想把它表达成若干个数字加一的乘积，也就是$n=(x_1+1)∗(x_2+1)∗⋯∗(x_k+1)$。 问$x_1+x_2+⋯+x_k$有多少种不同的取值。 Input一个整数n Output第一行输出一个整数表示不同取值个数。 第二行输出若干个用空格隔开的整数，表示不同的取值，从小到大输出。 Sample Input12 Sample Output44 5 6 11 Hint对于 100% 的数据，有 $1≤n≤10^9$。时间限制：2s空间限制：512MB Solution不难想到可以爆搜将x不断分解，当然爆搜也有巧妙性，看一下这段代码及注释： #include&lt;bits/stdc++.h&gt; using namespace std; set&lt;int&gt;s; int n; void dfs(int now,int x,int ss){ s.insert(now+ss-1); for(int i=x;i*i&lt;=now;i++){//x使不重复枚举 if(now%i==0) dfs(now/i,i,ss+i-1);//ss+i-1使后者的i在统计时先被减过1 } } void init(){ scanf(&quot;%d&quot;,&amp;n); dfs(n,2,0); printf(&quot;%d\n&quot;,s.size()); for(set&lt;int&gt;::iterator it=s.begin();it!=s.end();it++) printf(&quot;%d &quot;,*it); } int main(){ init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>set</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[棒棒糖]]></title>
    <url>%2F2018%2F10%2F24%2F27%2F</url>
    <content type="text"><![CDATA[Description相对于正常求LCA的步骤不同，这里求LCA时$dep_v=dep_u+random(0,1)$（u为v的父亲），然后给你一棵树和m个询问，每组询问两个数x,y，请求出这组询问的LCA求对的概率。对于所有概率要对998244353取模后输出. Hint$1&lt;=n,m&lt;=2 \times 10^5$ Solution其实画个图想一下还是挺简单的，对于一组x,y，若y为x祖先，那么他俩之间的dep不能变，所以方案数为$2^{n-1-mv}$mv表示它们的dep差，而$ans=\frac{2^{n-1-mv}}{2^{n-1}}$。 然后对于其它情况，假设dep大的为x，另者为y，那么只要它们的深度相对相同变化即可，因为dep只会变少，它们最终或许不能立即到最近公共祖先，但最后会升到同一高度，然后往上即可,设x,y到祖先的距离分别为$l_1,l_2$（l1&gt;l2），所以方案数为$\sum_{i=0}^{l_2}C_{l_1}^i \times C_{l_2}^i$再乘上$2^{n-1-mv}$.那么这里强行计算肯定是要T的，可以引用一个组合数公式： $\sum_{i=0}^{m}C_{n}^i \times C_{m}^{m-i} = C_{m+n}^m$ (n&gt;=m) 可以变形成$\sum_{i=0}^{m}C_{n}^i \times C_{m}^{i} = C_{m+n}^m$ (n&gt;=m) 然后代入本题将那坨组合数变为$C_{l_1+l_2}^{l_1}$。然后O(n)预处理，O(1)就可以求出。 上代码： #include&lt;bits/stdc++.h&gt; #define maxn 200005 using namespace std; typedef long long ll; const ll mod=998244353; int n,m,x,y; ll w[maxn],jc[maxn&lt;&lt;1]; ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y){ if(b==0){x=1;y=0;return a;} else{ ll g=exgcd(b,a%b,x,y); ll t=x; x=y; y=t-a/b*y; return g; } } ll niy(ll k){ ll a=k,b=-mod,x,y; ll g=exgcd(a,b,x,y); ll x0=1/g*x; ll t=b/g; if(t&lt;0) t=-t; ll ans=(x0%t+t)%t; return ans; } void ready(){ w[0]=1ll; for(int i=1;i&lt;=maxn-5;i++) w[i]=w[i-1]*2ll%mod; jc[0]=1ll; for(ll i=1;i&lt;=400000;i++) jc[i]=jc[i-1]*i%mod; } struct eage{ int to,next; }e[maxn&lt;&lt;1]; int np=0,first[maxn]; void add(int u,int v){ e[++np]=(eage){v,first[u]}; first[u]=np; } int dep[maxn],fa[maxn][19]; void dfs(int i,int f,int d){ dep[i]=d; fa[i][0]=f; for(int j=1;j&lt;=18;j++) fa[i][j]=fa[fa[i][j-1]][j-1]; for(int p=first[i];p;p=e[p].next){ int j=e[p].to; if(j==f) continue; dfs(j,i,d+1); } } int lca(int u,int v){ if(dep[u]&lt;dep[v]) swap(u,v); int x=dep[u]-dep[v]; for(int i=0;i&lt;=18;i++){ if((1&lt;&lt;i)&amp;x) u=fa[u][i]; } if(u==v) return u; for(int i=18;i&gt;=0;i--){ if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i]; } return fa[u][0]; } void init(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;n;i++){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y);add(y,x); } scanf(&quot;%d&quot;,&amp;m); dfs(1,0,0); ll t=w[n-1]; ll inv=niy(t);//分母 for(int i=1;i&lt;=m;i++){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y); if(dep[x]&lt;dep[y]) swap(x,y); int z=lca(x,y); if(z==y){ ll k=dep[x]-dep[y]; k=n-1-k; ll kk=w[k]; ll ans=kk*inv%mod; printf(&quot;%lld\n&quot;,ans); } else{ ll k=dep[x]+dep[y]-2*dep[z]; k=n-1-k; ll t1=w[k];//后项 int l1=dep[x]-dep[z],l2=dep[y]-dep[z]; ll fz=jc[l1+l2],fm=jc[l1]*jc[l2]%mod; ll niyy=niy(fm); ll ans1=fz*niyy%mod; ans1=ans1*t1%mod; ans1=ans1*inv%mod; printf(&quot;%lld\n&quot;,ans1); } } } int main(){ ready(); init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>LCA</tag>
        <tag>逆元</tag>
        <tag>扩展欧几里得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重排]]></title>
    <url>%2F2018%2F10%2F23%2F26%2F</url>
    <content type="text"><![CDATA[Description你拿到了一串可以拯救世界的数，不过这串数字被重新排列过了，你想要把它恢复到原始的样子。 你现在知道两个很大的数 A 和 B，他们都没有前导0。其中，A是拯救世界的数（也没有前导0）重排后的一个数。拯救世界的数虽然很大，但是也不会超过数 B。现在你想恢复拯救世界的数，求不超过 B 的最大的一个由 A 重新排列的数是什么。 注意，重新排列指的是 A 的数位重新排列，比如123可以重排成321，并且要保证重排后没有前导0。答案保证有解。 Input第一行一个整数 TT 表示数据组数。 后面2T行，第2i行表示第i个点的数 A，第2i+1行表示第i个点的数 B。 Output共 T行，每行一个数表示答案。 Sample Input312123123123300 Sample Output1123231 Hint对于20%的数据，数 A、B的位数 ≤10。 对于另外30%的数据，数 A、B的位数 ≤18。 对于另外10%的数据，数 B 除了第一位非零，其他位都是零。 对于另外10%的数据，数 A、B的位数 ≤100。 对于100%的数据，数 A、B的位数≤500，T≤5。 时间限制：2s空间限制：512MB Solution首先看A，B的长度，若$len_a&lt;len_b$，那肯定a重排后比b小，所以我们贪心从大到小排后输出。而如果相等，那么我们对于每一位都去枚举它跟谁交换，直到刚好满足小于等于B，当然这里是排了序从大到小枚举的，这样暴力是能过的但是较慢。 上代码： #include&lt;bits/stdc++.h&gt; #define maxn 505 using namespace std; char a[maxn],b[maxn]; int t; bool cmp(char a,char b){ return a&gt;b; } void init(){ scanf(&quot;%d&quot;,&amp;t); for(int p=1;p&lt;=t;p++){ scanf(&quot;%s%s&quot;,a+1,b+1); int len=strlen(a+1),len2=strlen(b+1); if(len&lt;len2){ sort(a+1,a+len+1,cmp); printf(&quot;%s\n&quot;,a+1); } else{ for(int i=1;i&lt;=len;i++) for(int j=len;j&gt;=i;j--){//枚举每位交换并保证刚刚最大 sort(a+i,a+len+1); swap(a[i],a[j]); sort(a+i+1,a+len+1); if(strcmp(b+1,a+1)&gt;=0) break; } printf(&quot;%s\n&quot;,a+1); } } } int main(){ init(); return 0; } 然后是比较快的做法： tips:这道题跟以前一道Igra思路相似，先贪心枚举当前选什么，再判断剩下最优能否满足对于每一位从大到小枚举，若前面已经小于就不必再判，否则判当前选后剩下最优状态能否满足。按题意模拟即可…. 上代码： #include&lt;bits/stdc++.h&gt; #define maxn 505 using namespace std; int t; int cnt[12]; char s[maxn],ss[maxn]; int ans[maxn],len1,len2; bool cmp(char a,char b){ return a&gt;b; } bool check(int i,int j){ cnt[j]--; int pos=i; for(int k=0;k&lt;=9;k++) for(int kk=1;kk&lt;=cnt[k];kk++) ans[++pos]=k; cnt[j]++; for(int k=i+1;k&lt;=len1;k++){ if(ss[k]-&#39;0&#39;&gt;ans[k]) return true; if(ss[k]-&#39;0&#39;&lt;ans[k]) return false; } return true; } void init(){ memset(cnt,0,sizeof(cnt)); scanf(&quot;%s%s&quot;,s+1,ss+1); len1=strlen(s+1),len2=strlen(ss+1); for(int i=1;i&lt;=len1;i++) cnt[s[i]-&#39;0&#39;]++; if(len1&lt;len2){ sort(s+1,s+len1+1,cmp); printf(&quot;%s\n&quot;,s+1); } else{ bool same=true; for(int i=1;i&lt;=len1;i++){ for(int j=9;j&gt;=0;j--){ if(!cnt[j]||same&amp;&amp;j&gt;ss[i]-&#39;0&#39;) continue; same=(same&amp;(j==ss[i]-&#39;0&#39;)); if(same&amp;&amp;!check(i,j)) continue; cnt[j]--; ans[i]=j; break; } } for(int i=1;i&lt;=len1;i++) printf(&quot;%d&quot;,ans[i]); printf(&quot;\n&quot;); } } int main(){ scanf(&quot;%d&quot;,&amp;t); for(int i=1;i&lt;=t;i++) init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[翻转]]></title>
    <url>%2F2018%2F10%2F23%2F25%2F</url>
    <content type="text"><![CDATA[Description小c有两个长为n的01串A和B。她可以进行下列3种操作，按任意顺序：1.把A循环左移一位2.把A循环右移一位3.选择一个$B_i$=1的i，翻转$A_i$（令$A_i=1-A_i$）求让A串变得和B串相等需要的最少步数。无解输出-1。 Sample Input10101100 Sample Output3 Hint1&lt;=n&lt;=2000 Solutionemmmmmmmm这道题首先判无解情况，即B全为0而A不全为0。 然后看到2000的数据，O(N)枚举一波最终的位置。然后对于每一个与$B_i$不等的$A_i$看它是往左移还是右移再移回，然后贪心取最大的，边移边翻转，最后ans=变化个数+移动个数+（最大左移+最大右移）$\times$2.注意小于等于移动个数且同向的就不必计入了…移动过程中就换了，详见代码注释。 这样加上排序复杂度为$n^2logn$，完全能过2333 上代码： #include&lt;bits/stdc++.h&gt; #define maxn 2005 using namespace std; char s[maxn],ss[maxn]; int n,lm[maxn],rm[maxn]; struct node{ int l,r; friend bool operator&lt;(node a,node b){ return a.l&lt;b.l; } }; vector&lt;node&gt;q; void ready(){ for(int i=0;i&lt;n;i++){ int now=i; while(ss[now]!=&#39;1&#39;) rm[i]++,now=(now+1)%n; now=i; while(ss[now]!=&#39;1&#39;) lm[i]++,now=(now-1+n)%n; } } void init(){ scanf(&quot;%s%s&quot;,s,ss); n=strlen(s); bool ok1=false; for(int i=0;i&lt;n;i++) if(s[i]==&#39;1&#39;){ok1=true;break;} bool ok2=true; for(int i=0;i&lt;n;i++) if(ss[i]==&#39;1&#39;){ok2=false;break;} if(ok1&amp;&amp;ok2){printf(&quot;-1&quot;);return;} ready(); int cnt,maxx;int ans=0x3f3f3f3f; for(int move=-n+1;move&lt;=n-1;move++){//左移n-1次，右移n-1次 int maxx=abs(move);cnt=0;//统计要修改的步数 q.clear(); for(int i=0;i&lt;n;i++){ if(s[i]==ss[(i+move+n)%n]) continue; cnt++; if(move&lt;=0&amp;&amp;lm[i]&lt;=maxx) continue; if(move&gt;=0&amp;&amp;rm[i]&lt;=maxx) continue;//途中移动翻转 q.push_back((node){lm[i],rm[i]}); } sort(q.begin(),q.end()); int maxy=0,minn=0x3f3f3f3f; for(int i=q.size()-1;i&gt;=0;i--){ minn=min(minn,q[i].l+maxy); maxy=max(maxy,q[i].r);//后一步更新，使覆盖完 } minn=min(minn,maxy);//还有最后一个没判到 ans=min(ans,minn*2+cnt+maxx); //来回走两遍aQAQ } printf(&quot;%d&quot;,ans); } int main(){ init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小W与面试]]></title>
    <url>%2F2018%2F10%2F23%2F24%2F</url>
    <content type="text"><![CDATA[Desciption小W因为染色的时候算错了一位数，所以自闭了。他决定不再染布了，去找工作。 在面试的时候，面试官问了他这样一个问题： 给定一个长度为 n 的序列 ai，求: \sum_{ia_j} a_i xor a_j小W发现他不会做，想求助于你。 Input第一行一个正整数 n。 第二行 n 个整数，表示 $a_i$。 Output一个整数表示答案。 Sample Input22 1 Sample Output3 Hint对于 30% 的数据，满足 n≤5000。 对于 100% 的数据，满足 1≤n≤105,1≤ai≤105。 时间限制：1 s 空间限制：512 MB Solution考虑按位计算贡献，设c{[i]}{[j]}[0/1]表示值在[$x-2^k+1,x$]范围内的第j位为0/1的个数，用树状数组来维护，从后往前依次加入。 上代码： #include&lt;bits/stdc++.h&gt; #define maxn 100005 using namespace std; typedef long long ll; ll c[maxn][20][2],w[20]; int n,a[maxn]; void ready(){ w[0]=1; for(int i=1;i&lt;=17;i++) w[i]=w[i-1]*2; } void update(int x,int d,int f){ while(x&lt;=maxn-5){ c[x][d][f]+=1; x+=(x&amp;-x); } } ll sum(int x,int d,int f){ ll ret=0; while(x&gt;0){ ret+=c[x][d][f]; x-=(x&amp;-x); } return ret*w[d]; } void init(){ ll ans=0; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=n;i&gt;=1;i--){ for(int j=0;j&lt;=17;j++){ if(a[i]&amp;(1&lt;&lt;j)){ ans+=sum(a[i]-1,j,0); update(a[i],j,1); } else{ ans+=sum(a[i]-1,j,1); update(a[i],j,0); } } } printf(&quot;%lld&quot;,ans); } int main(){ ready(); init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sirni]]></title>
    <url>%2F2018%2F10%2F23%2F23%2F</url>
    <content type="text"><![CDATA[Description有 n 个点，每个点有个权值 p1, p2, . . . , pn。这些点之间两两有边，对于点 i, j，这两个点之间的边权为 min($p_imodp_j,p_jmodp_i$)。问把这些点连通的最小代价和是多少，也就是问这个完全图的最小生成树的边权和。 Input第一行一个正整数 n，接下来 n 行每行一个整数，表示这些点的权值。30% 的数据- n ≤ 103。40% 的数据- pi ≤ 106。100% 的数据- 1 ≤ n ≤ 105, pi ≤ 106。 Output一行表示答案 Sample Input34915 Sample Output4 Hint时间限制：5s空间限制：768MB Solution首先会发现每条边边权为$p_imodp_j (p_i&gt;p_j)$，因为小数模大数为小数，大数模小数小于小数。然后先将点排序离散化去重（相同点权两点之间距离为0），然后从小到大对于每个$p_i$，我们设其值为x，那么会从x-2x,2x-3x……选出一个点连边作为最优值（见图，解释在下）：对于每一段，我们肯定首选第一个大于它的是最小的，如图中x-2x的$p_j$，然后对于$p_k$，我们选择不连边而让$p_j$去连更优，如图中绿色段为$p_j$连$p_k$代价，而蓝色段为x连$p_k$代价，可见前者更优，然后我们一共会连$\sum\lfloor\frac{mx}{p_i}\rfloor$条边，将它放大为调和级数求和$plogp$，所以用kruskal可以$plog^2p$求出…. 然后对于连边直接先预处理每个区间第一个选的，然后O（n）搞好. 上代码： #include&lt;bits/stdc++.h&gt; using namespace std; #define maxn 100005 #define maxm 10000005 typedef long long ll; int n,a[maxn],nxtt[maxm],pos[maxm],fa[maxn]; int find(int x){ if(fa[x]==x) return x; int root=find(fa[x]); fa[x]=root; return root; } bool check(int x,int y){ int fx=find(x),fy=find(y); if(fx!=fy) return false; return true; } void link(int x,int y){ int fx=find(x),fy=find(y); if(fx!=fy){ fa[fx]=fy; } } struct eage{ int u,v,len; friend bool operator&lt;(eage a,eage b){ return a.len&lt;b.len; } }e[maxm*4]; int np=0; void init(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++) fa[i]=i; sort(a+1,a+n+1); int cnt=unique(a+1,a+n+1)-a-1; for(int i=1;i&lt;=cnt;i++) nxtt[a[i]]=a[i],pos[a[i]]=i; for(int i=maxm-2;i&gt;=1;i--) if(!nxtt[i]) nxtt[i]=nxtt[i+1],pos[i]=pos[i+1]; for(int i=1;i&lt;cnt;i++){ e[++np]=(eage){i,i+1,a[i+1]%a[i]};//过掉x for(int j=2*a[i];j&lt;maxm;j+=a[i]){//从2x开始找 if(!nxtt[j]) break;//后面没有了 if(nxtt[j]&gt;=j+a[i]) continue; e[++np]=(eage){i,pos[nxtt[j]],nxtt[j]%a[i]}; } } sort(e+1,e+np+1); int calc=0;ll ans=0; for(int i=1;i&lt;=np;i++){ int u=e[i].u,v=e[i].v;ll c=e[i].len; if(check(u,v)) continue; link(u,v); calc++; ans+=c; if(calc==cnt-1){printf(&quot;%lld&quot;,ans);return;} } } int main(){ init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
        <tag>调和级数</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Poklon]]></title>
    <url>%2F2018%2F10%2F23%2F22%2F</url>
    <content type="text"><![CDATA[Description有一个长度为 n 的序列，每个数的范围在 0 到 $10^9$ 之内。你有 Q 个询问，给出 l, r，问这个序列中区间 l 到 r 中恰好出现了两次的数字的个数。序列的下标从 1 开始。 Input第一行两个整数 n 和 Q，接下来一行 n 个整数，表示这个序列。接下来 Q 行，每行两个整数 l, r 表示询问的区间。40% 的数据- n, Q ≤ 5000。100% 的数据-1 ≤ n, Q ≤ 500000。 OutputQ 行，每行一个整数表示答案 Sample Input5 21 1 2 2 31 11 5 Sample Output02 Hint时间限制：5s空间限制：512MB Solution正解貌似是二维树状数组？？？没听懂orz。。。思想跟以前一道很类似，记录每一个数前面一个相同的和后面一个相同的，当区间包含l[i],i或i,r[i]时就会有贡献,从而以l为横轴,r为竖轴建立坐标系，每次修改就是一块矩形的加1，然后查询就对于(l,r)的点值。 ~~有时间一定要了解下qwq~~ 然后貌似用莫队可以随随便便过，直接开始离散化一下，然后莫队一波就欧克了，O($n\sqrt{n}$)还是能过的。 上代码： #include&lt;bits/stdc++.h&gt; #define maxn 500005 using namespace std; int n,q,a[maxn],blog[maxn],t[maxn],c[maxn]; int calc=0; struct node{ int l,r,id,ans; friend bool operator &lt;(node a,node b){ if(blog[a.l]==blog[b.l]) return a.r&lt;b.r; else return a.l&lt;b.l; } }nd[maxn]; bool cmp(node a,node b){ return a.id&lt;b.id; } void update1(int i){ c[a[i]]--; if(c[a[i]]==1) calc--; if(c[a[i]]==2) calc++; } void update2(int i){ c[a[i]]++; if(c[a[i]]==2) calc++; if(c[a[i]]==3) calc--; } void init(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;q); int blo=sqrt(n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),blog[i]=(i-1)/blo+1,t[i]=a[i]; sort(t+1,t+n+1); int cnt=unique(t+1,t+n+1)-t-1; for(int i=1;i&lt;=n;i++){ a[i]=lower_bound(t+1,t+cnt+1,a[i])-t; } for(int i=1;i&lt;=q;i++) scanf(&quot;%d%d&quot;,&amp;nd[i].l,&amp;nd[i].r),nd[i].id=i; sort(nd+1,nd+q+1); int l=1,r=0; for(int i=1;i&lt;=q;i++){ while(l&lt;nd[i].l) update1(l),l++; while(r&gt;nd[i].r) update1(r),r--; while(l&gt;nd[i].l) update2(l-1),l--; while(r&lt;nd[i].r) update2(r+1),r++; nd[i].ans=calc; } sort(nd+1,nd+q+1,cmp); for(int i=1;i&lt;=q;i++) printf(&quot;%d\n&quot;,nd[i].ans); } int main(){ init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>二维树状数组</tag>
        <tag>莫队</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Igra]]></title>
    <url>%2F2018%2F10%2F23%2F21%2F</url>
    <content type="text"><![CDATA[DescriptionAlice 和 Bob 在玩游戏。 Alice 和 “Bob 各写了一个长度为 n 的由小写字母 abc 构成的串。Alice 想把她的串中的字符打乱，对于任意的 B， Alice 串中的第 i 位和 Bob 串中的对应位置不同。Alice 想要知道字典序最小的这样的串是什么，数据保证有有解. Input第一行包含一个正整数 n。接下来两行每行一个长度为 n 的字符串，表示 Alice 和 Bob 手中的串。40W 的数据- n ≤ 20。100W 的数据- 1 ≤ n ≤ 5000 Output一行一个串，表示 Alice 想要找的串。 Sample Input5baaacabcba Sample Outputbaaac Hint时间限制：2s空间限制：512MB Solution这道题…..要用到hall定理，要求字符串A和B完全匹配，所以我们对于A和B中abc字符的量要求满足：$A_a&lt;=B_b+B_c$$A_b&lt;=B_a+B_c$$A_c&lt;=B_a+B_b$简单想一想就会发现如果大于那么a就必须与一个a匹配，所以时刻应满足这个，然后应用贪心策略，在满足条件情况下选字典序最小的（要注意坑点$A_a,A_b,A_c&gt;=0$） 上代码： #include&lt;bits/stdc++.h&gt; #define maxn 5005 using namespace std; int n; char s[maxn],ss[maxn]; int a[4],b[4]; bool check(){ if(a[1]&lt;=b[2]+b[3]&amp;&amp;a[2]&lt;=b[1]+b[3]&amp;&amp;a[3]&lt;=b[1]+b[2]) return true; return false; } void init(){ scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%s&quot;,s+1); for(int i=1;i&lt;=n;i++) a[s[i]-&#39;a&#39;+1]++; scanf(&quot;%s&quot;,ss+1); for(int i=1;i&lt;=n;i++) b[ss[i]-&#39;a&#39;+1]++; for(int i=1;i&lt;=n;i++){ if(ss[i]==&#39;a&#39;){ a[2]--;b[1]--; bool ok=check(); if(a[2]&lt;0) ok=false; if(ok) printf(&quot;b&quot;); else{ a[2]++;a[3]--;printf(&quot;c&quot;); } } else if(ss[i]==&#39;b&#39;){ a[1]--;b[2]--; bool ok=check(); if(a[1]&lt;0) ok=false; if(ok) printf(&quot;a&quot;); else{ a[1]++;a[3]--;printf(&quot;c&quot;); } } else if(ss[i]==&#39;c&#39;){ a[1]--;b[3]--; bool ok=check(); if(a[1]&lt;0) ok=false; if(ok) printf(&quot;a&quot;); else{ a[1]++;a[2]--;printf(&quot;b&quot;); } } } } int main(){ init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>Hall定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小W与卖酒]]></title>
    <url>%2F2018%2F10%2F22%2F20%2F</url>
    <content type="text"><![CDATA[Description小W因为没做出上面那题，没能通过面试。他决定改行卖酒。 他有 n 个容器，每个容器的容积是 ai。他没有其它测量工具，只知道每个容器的容积。 他还有一个大小无限的容器，他想知道他能否在这个容器中倒出 x 体积的酒。他可能有多次询问。 例如他有 2 个容器，大小分别是 3,5，那么他能够倒出 2 体积的酒，因为他可以先把第二个容器填满，然后用第二个容器的酒往第一个容器里倒，直到把第一个容器倒满，那么第二个容器剩下的体积就是 2。最后再把这些酒倒进那个大小无限的容器，就倒出了 2 体积的酒。 Input第一行两个正整数 n, q。 第二行 n 个整数，表示 ai。 接下来 q 行，每行一个整数 x，表示一次询问。 Output输出 q 行，每行 YES 或者 NO 表示对应询问的答案。 Sample Input2 24 612 Sample OutputNOYES Hint对于 10% 的数据，满足 n,q≤5,ai,x≤5。 对于 20% 的数据，满足 n,q≤10,ai,x≤10。 对于 50% 的数据，满足 ai,x≤105。 对于 100% 的数据，满足 1≤n,q≤105,1≤ai,x≤109。 时间限制：1 s 空间限制：512 MB Solution我靠大佬们都是一眼秒a…这好像是个啥子结论，用裴蜀定理证明，然鹅不会….主要求出$g=gcd(a_i)​$，然后对于每一个倒的水量x，若g是x的因数（能被x整除）则x可以倒出…记着吧233333 上代码： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;cctype&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;map&gt; #include&lt;set&gt; using namespace std; int n,m,g,x; int gcd(int x,int y){ if(y==0) return x; else return gcd(y,x%y); } void init(){ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;g); for(int i=2;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;x); g=gcd(g,x); } for(int i=1;i&lt;=m;i++){ scanf(&quot;%d&quot;,&amp;x); if(x%g==0) printf(&quot;YES\n&quot;); else printf(&quot;NO\n&quot;); } } int main(){ //freopen(&quot;1.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;1.out&quot;,&quot;w&quot;,stdout); init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>裴蜀定理</tag>
        <tag>结论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJOI2006 书架]]></title>
    <url>%2F2018%2F10%2F22%2F19%2F</url>
    <content type="text"><![CDATA[Description小T有一个很大的书柜。这个书柜的构造有些独特，即书柜里的书是从上至下堆放成一列。她用1到n的正整数给每本书都编了号。 小T在看书的时候，每次取出一本书，看完后放回书柜然后再拿下一本。由于这些书太有吸引力了，所以她看完后常常会忘记原来是放在书柜的什么位置。不过小T的记忆力是非常好的，所以每次放书的时候至少能够将那本书放在拿出来时的位置附近，比如说她拿的时候这本书上面有X本书，那么放回去时这本书上面就只可能有X-1、X或X+1本书。 当然也有特殊情况，比如在看书的时候突然电话响了或者有朋友来访。这时候粗心的小T会随手把书放在书柜里所有书的最上面或者最下面，然后转身离开。 久而久之，小T的书柜里的书的顺序就会越来越乱，找到特定的编号的书就变得越来越困难。于是她想请你帮她编写一个图书管理程序，处理她看书时的一些操作，以及回答她的两个提问：(1)编号为X的书在书柜的什么位置；(2)从上到下第i本书的编号是多少。 Input第一行有两个数n，m，分别表示书的个数以及命令的条数；第二行为n个正整数：第i个数表示初始时从上至下第i个位置放置的书的编号；第三行到m+2行，每行一条命令。命令有5种形式： 1． Top S——表示把编号为S的书放在最上面。 2． Bottom S——表示把编号为S的书放在最下面。 3． Insert S T——T∈{-1，0，1}，若编号为S的书上面有X本书，则这条命令表示把这本书放回去后它的上面有X+T本书； 4． Ask S——询问编号为S的书的上面目前有多少本书。 5． Query S——询问从上面数起的第S本书的编号。 Output对于每一条Ask或Query语句你应该输出一行，一个数，代表询问的答案。 Sample Input10 101 3 2 7 5 8 10 4 9 6Query 3Top 5Ask 6Bottom 3Ask 3Top 6Insert 4 -1Query 5Query 2Ask 2 Sample Output299753 Hint100%的数据，n,m &lt;= 80000 Solution一道裸的线段平衡树题a…..先上一波权值平衡树的板子（实际操作中可以按情况修改） #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;climits&gt; using namespace std; #define maxn 1000000+5 int fa[maxn],ch[maxn][2],sz[maxn],cnt[maxn],val[maxn]; int rt=0,np=0; bool check(int x){return ch[fa[x]][1]==x;} void link(int x,int y,bool kind){ fa[x]=y;ch[y][kind]=x; } void upload(int x){ sz[x]=sz[ch[x][0]]+sz[ch[x][1]]+cnt[x]; } void rotate(int x){ int y=fa[x],z=fa[y]; bool kind=check(x); int k=ch[x][!kind]; link(k,y,kind); link(x,z,check(y)); link(y,x,!kind); upload(y);upload(x); } void splay(int x,int goal){ while(fa[x]!=goal){ int y=fa[x],z=fa[y]; if(z!=goal) (check(x)^check(y))?rotate(x):rotate(y); rotate(x); } if(fa[x]==0) rt=x; } void find(int x){ int now=rt; while(ch[now][x&gt;val[now]]&amp;&amp;val[now]!=x) now=ch[now][x&gt;val[now]]; splay(now,0); } void insert(int x){ int now=rt,f=0; while(now&amp;&amp;val[now]!=x) f=now,now=ch[now][x&gt;val[now]]; if(now) cnt[now]++; else{ now=++np; val[now]=x; if(f) ch[f][x&gt;val[f]]=now; fa[now]=f; cnt[now]=1; } splay(now,0); } int prnx(int x,bool f){ find(x); int now=rt; if(val[now]&gt;x&amp;&amp;f||val[now]&lt;x&amp;&amp;!f) return now; now=ch[now][f]; while(ch[now][!f]) now=ch[now][!f]; return now; } void del(int x){ int pre=prnx(x,0),last=prnx(x,1); splay(pre,0);splay(last,pre); int delt=ch[last][0]; if(cnt[delt]){cnt[delt]--;splay(delt,0);} else{ ch[last][0]=0;splay(last,0); } } int kth(int now,int k){ if(k&lt;=sz[ch[now][0]]) return kth(ch[now][0],k); if(sz[ch[now][0]]+cnt[now]&lt;k) return kth(ch[now][1],k-sz[ch[now][0]]-cnt[now]); splay(now,0); return val[now]; } int kth(int x){ int now=rt,ans=0; while(1){ if(x&lt;val[now]) now=ch[now][0]; else{ ans+=ch[now][0]?sz[ch[now][0]]:0; if(val[now]==x){splay(now,0);return ans+1;} ans+=cnt[now]; now=ch[now][1]; } } } int main(){ insert(INT_MIN); insert(INT_MAX); for(int i=1;i&lt;=50000;i++) insert(i); for(int i=1;i&lt;=50000;i++) kth(rt,i); return 0; } 这道题是线段平衡树，对于每个操作画下图，想一下就欧克了，没什么好说的….. 上代码： #include&lt;bits/stdc++.h&gt; using namespace std; #define maxn 80005 int n,m,np=0,rt=0; int fa[maxn],ch[maxn][2],sz[maxn]; int val[maxn],rk[maxn]; bool check(int x){return ch[fa[x]][1]==x;} void link(int x,int y,bool kind){ fa[x]=y;ch[y][kind]=x; } void upload(int x){ sz[x]=sz[ch[x][0]]+sz[ch[x][1]]+1; } void rotate(int x){ int y=fa[x]; int z=fa[y]; bool kind=check(x); int k=ch[x][!kind]; link(k,y,kind); link(x,z,check(y)); link(y,x,!kind); upload(y);upload(x); } void splay(int x,int goal){ while(fa[x]!=goal){ int y=fa[x],z=fa[y]; if(z!=goal) (check(x)^check(y))?rotate(x):rotate(y); rotate(x); } if(fa[x]==0) rt=x; } void insert(int x){ int now=rt,f=0; while(now) f=now,now=ch[now][1]; now=++np; link(now,f,1); splay(now,0); } int nxt(int x,bool f){//前提要将x旋转到根 x=ch[x][f]; while(ch[x][!f]) x=ch[x][!f]; return x; } void del(int x){ splay(x,0); int pre=nxt(x,0),nxtt=nxt(x,1); splay(pre,0);splay(nxtt,pre); ch[nxtt][0]=0;splay(nxtt,0); } int kth(int now,int k){ if(k&lt;=sz[ch[now][0]]) return kth(ch[now][0],k); if(sz[ch[now][0]]+1&lt;k) return kth(ch[now][1],k-sz[ch[now][0]]-1); return now; } int s,k; char op[10]; void init(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=2;i&lt;=n+1;i++) scanf(&quot;%d&quot;,&amp;val[i]),rk[val[i]]=i; for(int i=1;i&lt;=n+2;i++) insert(i); for(int i=1;i&lt;=m;i++){ scanf(&quot;%s&quot;,op); if(op[0]==&#39;T&#39;){ scanf(&quot;%d&quot;,&amp;s); int t=rk[s]; del(t); /*splay(1,0); int nxtt=nxt(1,1); splay(nxtt,0);splay(1,nxtt); link(t,1,1); splay(t,0);*/ splay(1,0); int nxtt=nxt(1,1); splay(nxtt,1); link(t,nxtt,0); splay(t,0); } else if(op[0]==&#39;B&#39;){ scanf(&quot;%d&quot;,&amp;s); int t=rk[s]; del(t); /*splay(n+2,0); int pre=nxt(n+2,0); splay(pre,0);splay(n+2,pre); link(t,n+2,0); splay(t,0);*/ splay(n+2,0); int pre=nxt(n+2,0); splay(pre,n+2); link(t,pre,1); splay(t,0); } else if(op[0]==&#39;I&#39;){ scanf(&quot;%d%d&quot;,&amp;s,&amp;k); if(k==0) continue; int t=rk[s]; splay(t,0); if(k==1){ int nxtt=nxt(t,1); swap(rk[val[t]],rk[val[nxtt]]); swap(val[t],val[nxtt]); } else{ int nxtt=nxt(t,0); swap(rk[val[t]],rk[val[nxtt]]); swap(val[t],val[nxtt]); } } else if(op[0]==&#39;A&#39;){ scanf(&quot;%d&quot;,&amp;s); int t=rk[s]; splay(t,0); printf(&quot;%d\n&quot;,sz[ch[t][0]]-1);//减去最开始加入的1 } else if(op[0]==&#39;Q&#39;){ scanf(&quot;%d&quot;,&amp;s); printf(&quot;%d\n&quot;,val[kth(rt,s+1)]);//减去1 } } } int main(){ init(); return 0; }]]></content>
      <categories>
        <category>noip模拟赛</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SCOI2011 糖果]]></title>
    <url>%2F2018%2F10%2F22%2F18%2F</url>
    <content type="text"><![CDATA[Description幼儿园里有N个小朋友，lxhgww老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。但是小朋友们也有嫉妒心，总是会提出一些要求，比如小明不希望小红分到的糖果比他的多，于是在分配糖果的时候，lxhgww需要满足小朋友们的K个要求。幼儿园的糖果总是有限的，lxhgww想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求。 Input输入的第一行是两个整数N，K。接下来K行，表示这些点需要满足的关系，每行3个数字，X，A，B。如果X=1， 表示第A个小朋友分到的糖果必须和第B个小朋友分到的糖果一样多；如果X=2， 表示第A个小朋友分到的糖果必须少于第B个小朋友分到的糖果；如果X=3， 表示第A个小朋友分到的糖果必须不少于第B个小朋友分到的糖果；如果X=4， 表示第A个小朋友分到的糖果必须多于第B个小朋友分到的糖果；如果X=5， 表示第A个小朋友分到的糖果必须不多于第B个小朋友分到的糖果； Output输出一行，表示lxhgww老师至少需要准备的糖果数，如果不能满足小朋友们的所有要求，就输出-1。 Sample Input5 71 1 22 3 24 4 13 4 55 4 52 3 54 5 1 Sample Output11 Hint11说明【数据范围】 对于30%的数据，保证 N&lt;=100 对于100%的数据，保证 N&lt;=100000 对于所有的数据，保证 K&lt;=100000，1&lt;=X&lt;=5，1&lt;=A, B&lt;=N Solution首先，这道题要看出是一个差分约束系统，而求至少便是求最小值，所以应转化为$d[j]&gt;=d[i]+Wij$，这样跑最长路(只有用spfa)并且判0环就行了，然而发现这样只会有60，因为数据大和毒，导致判0环会炸。然后发现可以强联通分量缩点，那么每个分量的值肯定是一样的，如果边中有1就说明不符合。最后加一个超级起点，从它开始拓扑加dp就能过了。 上代码： #include&lt;bits/stdc++.h&gt; #define maxn 150005 using namespace std; int n,m,op,a,b; typedef long long ll; struct eage{ int to,next,len; }e[maxn&lt;&lt;1]; int np=0,first[maxn]; void add(int u,int v,int len){ e[++np]=(eage){v,first[u],len}; first[u]=np; } ll d[maxn]; bool vis[maxn]; int st[maxn],top=0,low[maxn],dfn[maxn],clock_=0,belong[maxn],cc=0; bool ok=false; int stt[maxn],topp=0; bool run(){ for(int i=1;i&lt;=topp;i++){ int t=stt[i]; for(int p=first[t];p;p=e[p].next){ int j=e[p].to,c=e[p].len; if(belong[j]==belong[t]&amp;&amp;c==1) return true; } } return false; } void dfs(int i){ vis[i]=1; dfn[i]=low[i]=++clock_; st[++top]=i; for(int p=first[i];p;p=e[p].next){ int j=e[p].to; if(vis[j]){ if(!belong[j]) low[i]=min(low[i],dfn[j]); continue; } dfs(j); low[i]=min(low[i],low[j]); } if(low[i]==dfn[i]){ cc++;topp=0; while(1){ int t=st[top--]; belong[t]=cc; stt[++topp]=t; if(t==i) break; } bool okk=run(); if(okk==true) ok=true; } } struct node{ int to;ll len; }; vector&lt;node&gt;g[maxn]; queue&lt;int&gt;q; int rd[maxn]; void work(){ for(int i=1;i&lt;=n+1;i++){ for(int p=first[i];p;p=e[p].next){ int j=e[p].to;ll c=e[p].len; if(belong[j]!=belong[i]) g[belong[i]].push_back((node){belong[j],c}),rd[belong[j]]++; } } d[belong[n+1]]=0; q.push(belong[n+1]); while(!q.empty()){ int i=q.front();q.pop(); for(int j=0;j&lt;g[i].size();j++){ node t=g[i][j]; int kk=t.to;ll c=t.len; d[kk]=max(d[kk],d[i]+c); rd[kk]--; if(rd[kk]==0) q.push(kk); } } } void init(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); d[n+1]=0; for(int i=1;i&lt;=m;i++){ scanf(&quot;%d%d%d&quot;,&amp;op,&amp;a,&amp;b); if(op==1){ add(a,b,0); add(b,a,0); } else if(op==2){ add(a,b,1); } else if(op==3){ add(b,a,0); } else if(op==4){ add(b,a,1); } else if(op==5){ add(a,b,0); } } for(int i=1;i&lt;=n;i++) add(n+1,i,1); for(int i=1;i&lt;=n+1;i++){ if(!vis[i]) dfs(i); } if(ok) printf(&quot;-1&quot;); else{ work(); ll ans=0; for(int i=1;i&lt;=n+1;i++) ans+=d[belong[i]]; printf(&quot;%lld&quot;,ans); } } int main(){ //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); //freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); init(); return 0; }]]></content>
      <categories>
        <category>noip模拟赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>缩点</tag>
        <tag>拓扑</tag>
        <tag>差分约束系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[约束]]></title>
    <url>%2F2018%2F10%2F20%2F17%2F</url>
    <content type="text"><![CDATA[Description现有 n 个点， n 条有向边。 要求将 n 个点分入两个集合 A， B，使得对于集合A 中的每一个点 x，存在一个集合 B 中的点 y，从 y 到 x 有一条有向边。 问集合A 最多能包含几个点。 Input第一行一个整数 n，表示总共有 n 个点。接下来一行 n 个整数，表示一个序列 a， a[i]代表存在一条从第 i 个点到第a[i]个点的有向边。 Output一行一个数 ans， ans 是集合 A 最多能包含的点数。 Sample Input52 4 5 3 1 Sample Output2 Hint对于 30%的数据， n&lt;=10对于 100%的数据， n&lt;=100000 Solution发现一个点最多连向另外一个点，可以想一下发现是环加内向树。那么对于入度为0的点便只能加入B集合，那么a[x]定可以为A集合，所以拓扑排序，将遇到的为标记的或x和a[x]都为B的，将a[x]加入A。最后剩下环，将环上的B集合的标记清空(这样可以更大)，然后以环上的A集合点向没有标记的点蔓延赋值，最后就能得到最佳情况。 上代码： #include&lt;bits/stdc++.h&gt; #define maxn 100005 using namespace std; int n,x,rd[maxn],a[maxn]; queue&lt;int&gt;q; int color[maxn]; bool vis[maxn]; int calc; void init(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;x); a[i]=x; rd[x]++; } for(int i=1;i&lt;=n;i++) if(rd[i]==0) q.push(i),color[i]=1; int ans=0; while(!q.empty()){ int i=q.front();q.pop(); if(!color[a[i]]){ color[a[i]]=3-color[i]; if(color[a[i]]==2) ans++; } else if(color[i]==1&amp;&amp;color[a[i]]==1) color[a[i]]=2,ans++; rd[a[i]]--; if(rd[a[i]]==0) q.push(a[i]); } for(int i=1;i&lt;=n;i++) if(rd[i]&amp;&amp;color[i]==1) color[i]=0;//将1清完，从2开始会更多 for(int i=1;i&lt;=n;i++){ if(rd[i]&amp;&amp;color[i]){ int x=i; while(!color[a[x]]){ color[a[x]]=3-color[x]; if(color[a[x]]==2) ans++; x=a[x]; } } } /*for(int i=1;i&lt;=n;i++){ if(!color[i]){ color[i]=1; int x=i; while(!color[a[x]]){ color[a[x]]=3-color[x]; if(color[a[x]]==2) ans++; x=a[x]; } } }*/ printf(&quot;%d&quot;,ans); } int main(){ init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>拓扑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[键盘]]></title>
    <url>%2F2018%2F10%2F20%2F16%2F</url>
    <content type="text"><![CDATA[Description现在文本框中有一个 x 个字符的字符串,希望在经过一系列操作后得到看到一个长度恰好为 n 的字符串。现可以有 5 种操作:1.敲击 1 次键盘,输入一个字符2.敲击 2 次键盘(Ctrl+A),选中所有已经输入的字符3.敲击 2 次键盘(Ctrl+C),复制所有选中的字符到剪贴板4.敲击 2 次键盘(Ctrl+V),把剪贴板中的所有字符输出(不清空剪贴板)5.敲击 1 次键盘(Backspace),若没有选中字符则删除一个字符否则删除所有选中的字符选中状态仅影响复制操作。问至少敲击几次键盘才能得到一个长度为 n 的字符串。 Hint对于 100%的数据 $n,x&lt;=10^6$ Solution这道题思路很nice啊，如果不考虑backspace操作的话，那么是可以递推来做的。但如果有的话，那么可以3次清空为0，然后一直乘2大约140步左右可以大于$10^6$，也就是说极限步数是n+143，实际上会远远不到这个上限，那么若x能到y则连一条边，由调和级数算下来(缩放)大约为nlogn，再最短路跑一遍大约$nlog^2n$，因为上限远远没满卡一下常数能过。(主要为这方面题提供一种思路) dij代码(会T三个点qwq，可能以为1,5操作距离太近不太友好)#include&lt;bits/stdc++.h&gt; #define maxn 2000305 using namespace std; int n,x,dist[maxn]; struct node{ int v,id; friend bool operator &lt;(node a,node b){ return a.v&gt;b.v; } }; priority_queue&lt;node&gt;q; bool vis[maxn]; void init(){ scanf(&quot;%d%d&quot;,&amp;x,&amp;n); memset(dist,0x3f,sizeof(dist)); if(x&gt;n){ dist[n]=x-n; dist[0]=3; q.push((node){dist[0],0}); } else{ dist[n]=n-x;dist[x]=0;q.push((node){dist[x],x}); } while(!q.empty()){ node t=q.top();q.pop(); int i=t.id;if(vis[i]) continue; vis[i]=1; if(i&lt;n) if(dist[i+1]&gt;dist[i]+1){dist[i+1]=dist[i]+1;q.push((node){dist[i+1],i+1});}; if(i==0) continue; if(dist[i-1]&gt;dist[i]+1){dist[i-1]=dist[i]+1;q.push((node){dist[i-1],i-1});}; int len=4; int m=2*i; while(m&lt;=n){ if(dist[m]&gt;dist[i]+len+2){ dist[m]=dist[i]+len+2;q.push((node){dist[m],m}); } m=m+i;len+=2; } if(dist[n]&gt;dist[i]+len+2+m-n) dist[n]=dist[i]+len+2+m-n;//超过的最快方法 } printf(&quot;%d&quot;,dist[n]); } int main(){ init(); return 0; } spfa(而spfa由于直接按加的顺序展开所以会好很多…)#include&lt;bits/stdc++.h&gt; #define maxn 2000305 using namespace std; int n,x,dist[maxn]; /*struct node{ int v,id; friend bool operator &lt;(node a,node b){ return a.v&gt;b.v; } };*/ //priority_queue&lt;node&gt;q; queue&lt;int&gt;q; bool vis[maxn]; void init(){ scanf(&quot;%d%d&quot;,&amp;x,&amp;n); memset(dist,0x3f,sizeof(dist)); if(x&gt;n){ dist[n]=x-n; dist[0]=3; q.push(0);vis[0]=1; } else{ dist[n]=n-x;dist[x]=0;q.push(x);vis[x]=1; } while(!q.empty()){ int i=q.front();q.pop(); vis[i]=0; if(i&lt;n) if(dist[i+1]&gt;dist[i]+1){dist[i+1]=dist[i]+1;if(!vis[i+1]) vis[i+1]=1,q.push(i+1);}; if(i==0) continue; if(dist[i-1]&gt;dist[i]+1){dist[i-1]=dist[i]+1;if(!vis[i-1]) vis[i-1]=1,q.push(i-1);}; int len=4; int m=2*i; while(m&lt;=n){ if(dist[m]&gt;dist[i]+len+2){ dist[m]=dist[i]+len+2;if(!vis[m]) vis[m]=1,q.push(m); } m=m+i;len+=2; } if(dist[n]&gt;dist[i]+len+2+m-n) dist[n]=dist[i]+len+2+m-n;//超过的最快方法 } printf(&quot;%d&quot;,dist[n]); } int main(){ init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>隐式图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[祎隋]]></title>
    <url>%2F2018%2F10%2F20%2F15%2F</url>
    <content type="text"><![CDATA[生活，靠容忍和退让支撑着前行 《祎隋》 年幼时 你含糊地 把热情挥洒 年老时 你明白地 将运命呈出]]></content>
      <categories>
        <category>杂诗</category>
      </categories>
      <tags>
        <tag>杂诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[noip模拟赛2]]></title>
    <url>%2F2018%2F10%2F18%2F13%2F</url>
    <content type="text"><![CDATA[T1Description小 H 最近迷上了名为“石头，剪刀，布”的游戏。游戏规则很简单：比赛双方同时数到三，然后同时出一个手势，代表“石头”、“剪刀”或“布”。“石头”胜“剪刀”，“剪刀”胜“布”，“布”胜“石头”。举个例子， 小 H 出“石头”， 对方出“布”，则对方胜利。当然，也可以“平局”（如果双方手势相同的话）。小 H 对阵小 B。 小 H 作为一个匹托专家，能够预测小 B 未来 N 回合的手势。 但作为具有数学头脑的人， 他又是比较懒的，以至于他只愿意变换固定次数的手势来完成游戏。例如， 他只想变 1 次，则他可能出“石头”几次，剩下的都出“布”；或者其他。现在小 H 与小 B 准备进行 N 回合的比赛，且已经测出小 B 未来 N 回合的手势，小 H 只愿意改变 K 次手势（最开始手势任意）。请你帮小 H 求出他最多能赢多少场 Input输入文件名为 game.in。输入的第一行两个空格隔开的数字 N 和 K，分别表示比赛的回合数和小 H 变换手势的次数。 接下来的 N 行，每行一个字母，表示小 B 的手势： ’H’表示石头、 ’S’表示剪刀、 ’P’表示布 Output输出文件名为 game.out。输出一行一个整数， 小 H 最多能赢的场数 Sample Input5 1P P H P S Sample Output4 Hint对于 30%的数据： N≤20对于 100%的数据： N≤100 000， K≤20 Solution一道水水的dp啊qwq，刷表和i-1到i转移都可以。注意细节…O($n \ast k$)实现就欧克。 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cctype&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; #include&lt;queue&gt; #include&lt;map&gt; #include&lt;set&gt; #include&lt;vector&gt; using namespace std; #define maxn 100005 int n,k,a[maxn],dp[maxn][22][3];//0:石头,1：剪刀,2:布 char s[2]; void init(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n;i++){scanf(&quot;%s&quot;,s);if(s[0]==&#39;H&#39;)a[i]=0;if(s[0]==&#39;S&#39;) a[i]=1;if(s[0]==&#39;P&#39;) a[i]=2;}; //dp[0][0][0]=dp[0][0][1]=dp[0][0][2]=0; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;=min(i,k);j++) for(int kk=0;kk&lt;=2;kk++){//枚举上一个的手势 int f=0; if(a[i]==2&amp;&amp;kk==1) f=1; if(a[i]==1&amp;&amp;kk==0) f=1; if(a[i]==0&amp;&amp;kk==2) f=1; dp[i][j][kk]=max(dp[i][j][kk],dp[i-1][j][kk]+f);//不换 int tt=(a[i]-1+3)%3; if(j&gt;=1){ if(tt==kk) continue;//不换..对身体好 dp[i][j][tt]=max(dp[i][j][tt],dp[i-1][j-1][kk]+1); } } int maxx=0; for(int i=0;i&lt;=2;i++) maxx=max(maxx,dp[n][k][i]); printf(&quot;%d&quot;,maxx); } int main(){ //freopen(&quot;game.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;game.out&quot;,&quot;w&quot;,stdout); init(); return 0; } T2Description为补贴家用，小 M 终于谋得一份兼职——牛奶销售员。小 M 打算把牛奶销售到 N 个城市，这 N 个城市编号为 1..N。这些城市之间有 R 条高速公路和 P 条泥泞小道连接。每条高速路或泥泞小道连接 N个城市中的 A 和 B， 需要的花费为 C，对于高速路的花费 C， 一定是大于等于 0 的；然而对于泥泞小道，由于边远城市的人民感谢送奶工的辛劳，会额外付更多的奶钱， 所以有些小道的花费可能为负数（表示有收益）。高速公路是双向的，可以从 A 走到 B，也可以从 B 走到 A；然后泥泞小道则不是双向的，只能从 A 走到 B。事实上， 由于泥泞道路经过的都是蛮荒之地，所以政府为了社会和谐，出台了一些政策保证： 如果一条泥泞小道可以从 A到 B，那么保证不可能通过高速路或泥泞小道从 B 再回到 A。小 M 的销售中心在城市 S，现在他想知道，把牛奶从 S 送到每个城市的最小花费的，或者根本就不能送到。 Input输入文件名为 sales.in。输入的第 1 行包含四个空格隔开的整数: N, R, P 和 S，他们的意义如题目描述。 第 2 到 R+1 行每行含三个空格隔开的整数： A, B 和 C，表示一条高速公路双向连接城市 A 和 B，需要的花费为 C。 第 R+2 到 R+P+1 行每行包含三个空格隔开的整数： A, B 和 C，表示一条泥泞小道可以从城市 A 到 B，需要的花费为 C。 Output输出文件名为 sales.out。输出有 N 行，每行一个整数，第 i 行表示从 S 到达城市 i 的最小花费，如果不存在输出”NO PATH”。 Sample Input6 3 3 41 2 53 4 55 6 103 5 -1004 6 -1001 3 -10 Sample OutputNO PATHNO PATH50-95-100 Hint对于 30%的数据： N≤10 000对于 100%的数据： 1≤N≤25,000 , 1≤P,R≤50,000高速公路的 C： 0≤C≤10,000泥泞小道的 C： -10,000≤C≤10,000 Solution这道题真的傻缺了啊qwq，别人想的是有负权边不能跑dij，我tm想的是没有负环直接跑dij，感觉复杂度差不多就直接交上去了哇qwq。实际上你的复杂度超乎你想象。开始正经：这道题有两种解法：1.spfa+slf优化，好像勉强过得到？直接用双端队列deque维护一下。slf优化还是能加就加吧，毕竟挺简单的。不过关于spfa，它已经死了.所以稳妥一点还是用dij吧，对身体好a.2.dij+缩点+拓扑：woc这个思路真的很nice啊，首先发现可以缩点连成一个DAG图，然后对于每个联通块单独跑dij，这样算下来总复杂度也就nlogn左右（事实证明真的跑得飞快！法1时间几乎是它的十倍）.然后就是注意细节的实现，也为这种混合图提供了一种思路。当把所有的入边处理完之后用vector记录入点，就可以队首存入多个起点，一次dij跑完，复杂度被大大减少.（可以回顾noip2017逛公园）. 上代码： #include&lt;bits/stdc++.h&gt; #define maxn 25005 #define maxm 150005 using namespace std; struct eage{ int to,next,len; }e[maxm]; int np=0,first[maxn]; void add(int u,int v,int len){ e[++np]=(eage){v,first[u],len}; first[u]=np; } int n,r,p,s,x,y,z,dfn[maxn],low[maxn],belong[maxn],cc=0,clock_=0; int st[maxn],top=0,rd[maxn]; bool vis[maxn]; vector&lt;int&gt;g[maxn]; struct noded{ int from,to,len; }; vector&lt;noded&gt;b[maxn]; void dfs(int i,int f){ vis[i]=1; st[++top]=i; low[i]=dfn[i]=++clock_; for(int p=first[i];p;p=e[p].next){ int j=e[p].to; if(vis[j]){ if(!belong[j]) low[i]=min(low[i],dfn[j]); continue; } dfs(j,i); low[i]=min(low[i],low[j]); } if(low[i]==dfn[i]){ cc++; while(1){ int t=st[top--]; belong[t]=cc; if(t==i) break; } } } int dist[maxn]; bool viss[maxn]; struct node{ int v,id; friend bool operator &lt;(node a,node b){ return a.v&gt;b.v; } }; void dij(int s){ priority_queue&lt;node&gt;q; for(int i=0;i&lt;g[s].size();i++){ int t=g[s][i]; q.push((node){dist[t],t}); } while(!q.empty()){ node t=q.top();q.pop(); int i=t.id; if(viss[i]) continue; viss[i]=1; for(int p=first[i];p;p=e[p].next){ int j=e[p].to,c=e[p].len; if(belong[j]!=belong[i]) continue; if(dist[j]&gt;dist[i]+c){ dist[j]=dist[i]+c; q.push((node){dist[j],j}); } } } } queue&lt;int&gt;qq; void work(){ memset(viss,0,sizeof(viss)); for(int i=1;i&lt;=n;i++) dist[i]=1000000007; g[belong[s]].push_back(s); dist[s]=0; qq.push(belong[s]); while(!qq.empty()){ int i=qq.front();qq.pop(); dij(i); for(int j=0;j&lt;b[i].size();j++){ noded tt=b[i][j]; int t1=tt.from,t2=tt.to,c=tt.len; dist[t2]=min(dist[t2],dist[t1]+c); g[belong[t2]].push_back(t2); rd[belong[t2]]--; if(rd[belong[t2]]==0) qq.push(belong[t2]); } } for(int i=1;i&lt;=n;i++){ if(dist[i]==1000000007) printf(&quot;NO PATH\n&quot;); else printf(&quot;%d\n&quot;,dist[i]); } } void run(){ for(int i=1;i&lt;=n;i++){ if(!vis[i]) continue; for(int p=first[i];p;p=e[p].next){ int j=e[p].to; if(belong[j]!=belong[i]){ //g[belong[i]].push_back(belong[j]); b[belong[i]].push_back((noded){i,j,e[p].len}); rd[belong[j]]++; } } } work(); } void init(){ scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;r,&amp;p,&amp;s); for(int i=1;i&lt;=r;i++){ scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); add(x,y,z); add(y,x,z); } for(int i=1;i&lt;=p;i++){ scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); add(x,y,z); } dfs(s,0); run(); } int main(){ init(); return 0; } T3Description小 Y 同学手上有两类线段，分别为 A 线段和 B 线段。A 线段的有n种，第i种有$s_i$条，其左端点和右端点为$a_i$和$b_i$，他们都是109范围内的正整数，且一定有$a_i$ ≤ $b_i$。 B 线段的有m种，第i种有$k_i$条，其左端点和右端点为$l_i$和$r_i$，他们也是109范围内的正整数，且一定有$l_i$ ≤$r_i$。 小 Y还规定，如果一条 A 线段($a_i$, $b_i$)能匹配一条 B 线段($l_i$, $r_i$)，当且仅当$l_i$ ≤ $a_i$≤$b_i$ ≤ $r_i$。现在小 Y 需要你判断能否为所有的 A 线段都指定一条与之匹配的 B 线段。注意，无论是 A 线段还是 B 线段，每条都只能匹配一次，且仅能匹配一次。 Input输入文件名为 machine.in输入的第 1 行是一个整数T，表示数据组数。每组数据的第 1 行有两个整数n, m，分别表 A 类线段和 B 类线段的种类数。接下来n行，每行 3 个整数ai、 bi、 si，描述一种 A 类线段。接下来 m 行，每行三个整数li、 ri、 ki，描述一种 B 类线段。 Output输入文件名为 machine.out仅输出共T行，每行一个字符串，若可以实现则输出 Yes，否则输出No。 Sample Input32 21 4 23 5 11 4 22 5 13 21 3 12 4 13 5 11 3 22 5 12 21 2 21 2 11 2 11 2 2 Sample OutputYesNoYes Hint对于所有数据保证有：1 ≤ $s_i$, $k_i$ ≤ 109，1 ≤ t≤ 50，1 ≤ n, m ≤ 50000。一个测试点中，所有n的和不超过 4000000，所有m的和也不超过 4000000。 Solution还是一道套路题a，用set维护直接nlognA了啊（没办法蒟蒻太蒻了）。稍微注意线段维护的细节，按照左端点排序，相同排右端点。然后用两个指针维护，对于每个i，将l小于等于它的加入到multiset里面（以右端点为关键字）然后每次lower_bound找一下就欧克了啊qwq.(勉哥说对于每个被删掉的指针要查询它的下一个必须要预先处理好) tips线段类的有很多问题可以总结a….上一次居然被那个线段贪心给卡了qwq(处理不重叠的最多线段)就是右端点排个序，左端点大的就可以加进去，贪贪贪 #include&lt;bits/stdc++.h&gt; #define maxn 50005 using namespace std; struct node{ int l,r,w; friend bool operator &lt;(node a,node b){ if(a.l!=b.l)return a.l&lt;b.l; else return a.r&lt;b.r; } }nda[maxn],ndb[maxn]; struct noded{ int r,w; friend bool operator &lt;(noded a,noded b){ return a.r&lt;b.r; } }; multiset&lt;noded&gt;s; multiset&lt;noded&gt;::iterator it,itt; int t,n,m; void init(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(&quot;%d%d%d&quot;,&amp;nda[i].l,&amp;nda[i].r,&amp;nda[i].w); for(int i=1;i&lt;=m;i++) scanf(&quot;%d%d%d&quot;,&amp;ndb[i].l,&amp;ndb[i].r,&amp;ndb[i].w); sort(nda+1,nda+n+1); sort(ndb+1,ndb+m+1); s.clear(); int j=1;//b的序号 for(int i=1;i&lt;=n;i++){//a的序号 while(j&lt;=m&amp;&amp;ndb[j].l&lt;=nda[i].l) s.insert((noded){ndb[j].r,ndb[j].w}),j++; noded tt=(noded){nda[i].r,0}; it=s.lower_bound(tt); if(it==s.end()) {printf(&quot;No\n&quot;);return;} while(1){ noded t=*it; s.erase(it); if(t.w&gt;=nda[i].w){t.w-=nda[i].w,nda[i].w=0,s.insert((noded){t.r,t.w});break;} else nda[i].w-=t.w; it=s.lower_bound(tt); if(it==s.end()) {printf(&quot;No\n&quot;);return;} } } printf(&quot;Yes\n&quot;); } int main(){ scanf(&quot;%d&quot;,&amp;t); for(int i=1;i&lt;=t;i++) init(); return 0; }]]></content>
      <categories>
        <category>noip模拟赛</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>dijsktra</tag>
        <tag>spfa</tag>
        <tag>slf优化</tag>
        <tag>缩点</tag>
        <tag>拓扑</tag>
        <tag>DAG图</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[noip模拟赛1]]></title>
    <url>%2F2018%2F10%2F17%2F12%2F</url>
    <content type="text"><![CDATA[T1Description每天中午，美丽的重庆一中都会上演一场华丽的千人大竞走。大量人流短时间涌进第二食堂， 食堂班长小 H 表示不淡定了，他必须合理安排饭堂饭菜的价格，来让同学们有愉快的心情就餐。已知第一饭堂饭菜的价格是有 N 位数字的整数，如果一个价格有不小于K（1≤K≤N） 个数位完全相同，那么这个价格就被认为是漂亮的，否则这个价格被认为是不漂亮的。 小 H 想改变其中一个饭菜价格，改变价格中的一位数字需要花费一些钱， 钱数等于改前和改后的数字之差的绝对值。小 H 希望你能把这个价格改地漂亮，求出最小花费，同时给出字典序最小的修改方案。 Input输入文件名为 canteen.in。输入的第一行两个空格隔开的数字 N 和 K(1≤K≤N)。 第二行是一个长度为 N 位的数字， 表示原来的价格。 Output输出文件名为 canteen.out。输出包含两行，第一行一个整数， 表示最小费用。 第二行是字典序最小的方案。 Sample Input6 5889696 Sample Output4888688 Hint对于 30%的数据： N≤10对于 100%的数据： N≤100 000 Solution比较水的一道贪心a，只是要注意细节，维护两个东西：最小费用和最小字典序。显然最小费用优先级更大。我们枚举相同的k个数字从0到9，对于每一个确定的st,用i=0~9依次考虑变的数字，注意先执行st+i，再执行st-i以保证字典序最优。然后对于小于st的从后往前改，大于st的从前往后改来保证字典序。 tips（想好细节,think twice,code once）上代码： The Code#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;algorithm&gt; #include&lt;cmath&gt; #include&lt;cctype&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;map&gt; #include&lt;set&gt; #define maxn 100005 using namespace std; int n,k; char s[maxn]; char ss[maxn]; char tt[maxn]; int cnt[10]; int minn=0x3f3f3f3f; int yb[10]; int calc[10]; bool cmp(){ for(int i=1;i&lt;=n;i++){ if(tt[i]&lt;ss[i]) return true; else if(tt[i]&gt;ss[i]) return false; } return false; } void init(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;k); scanf(&quot;%s&quot;,s+1); for(int i=1;i&lt;=n;i++) cnt[s[i]-&#39;0&#39;]++,ss[i]=&#39;9&#39;;//最大化 for(int st=0;st&lt;=9;st++){ int t=k;//要变的个数 int ans=0;//要花的钱 for(int i=0;i&lt;=9;i++){ if(i==0){ if(cnt[st]&gt;=t) break; t-=cnt[st]; } else{ int t1=st+i,t2=st-i; if(t1&lt;=9){ if(cnt[t1]&gt;=t){ans+=t*i;break;} t-=cnt[t1];ans+=cnt[t1]*i; } if(t2&gt;=0){ if(cnt[t2]&gt;=t){ans+=t*i;break;} t-=cnt[t2];ans+=cnt[t2]*i; } } } minn=min(minn,ans); calc[st]=ans; } for(int st=0;st&lt;=9;st++){ if(calc[st]==minn){ for(int i=1;i&lt;=n;i++) tt[i]=s[i]; memset(yb,0,sizeof(yb)); int t=k;//要变的个数 for(int i=0;i&lt;=9;i++){ if(i==0){ if(cnt[st]&gt;=t) break; t-=cnt[st]; } else{ int t1=st+i,t2=st-i; if(t1&lt;=9){ if(cnt[t1]&gt;=t){yb[t1]=t;break;} t-=cnt[t1];yb[t1]=cnt[t1]; } if(t2&gt;=0){ if(cnt[t2]&gt;=t){yb[t2]=t;break;} t-=cnt[t2];yb[t2]=cnt[t2]; } } } for(int i=0;i&lt;=9;i++){ if(yb[i]){ if(i&gt;st){ for(int j=1;j&lt;=n;j++) if(s[j]==(i+&#39;0&#39;)) if(yb[i])tt[j]=st+&#39;0&#39;,yb[i]--; else{break;} } else{ for(int j=n;j&gt;=1;j--) if(s[j]==(i+&#39;0&#39;)) if(yb[i])tt[j]=st+&#39;0&#39;,yb[i]--; else{break;} } } } if(cmp()) for(int i=1;i&lt;=n;i++) ss[i]=tt[i]; } } printf(&quot;%d\n&quot;,minn); for(int i=1;i&lt;=n;i++) printf(&quot;%c&quot;,ss[i]); /*memset(dp,0x3f,sizeof(dp)); for(int i=1;i&lt;=9;i++) dp[0][i]=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=min(i,k);j++) for(int kk=1;kk&lt;=9;kk++){ dp[j][kk]=min(dp[j][kk],dp[j-1][kk]+abs(s[i]-&#39;0&#39;-kk)); } int minn=0x3f3f3f3f; for(int i=1;i&lt;=9;i++) minn=min(minn,dp[k][i]); printf(&quot;%d&quot;,minn);*/ } int main(){ //freopen(&quot;canteen.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;canteen.out&quot;,&quot;w&quot;,stdout); init(); return 0; } T2Description小 M 新设计了一款战略游戏。游戏的地图包含有 N 个阵地（用 1..N 编号），用 N-1 条战略交通线把它们连接起来， 地图中任意两个阵地都能直接或间接地相互到达。 小 M 为每条交通线设定一个名为“战略重要性”的参数，它是一个正整数，且这个数值越大，说明这条交通线的战略重要性越大。 小 M 还设计了一个阵地间的“战略相关性”的度量标准， 那就是两个阵地间路径上“战略重要性”最小的交通线。小 M 已经完成了游戏大多数模块的代码， 还有一个在线查询模块没有完成，即对于用户查询： k， v，表示查询与阵地 v“战略相关性” 不小于 k 的阵地的数目。由于小 M 还要负责游戏的推广， 所以这个查询模块的代码就交给你了。 Input输入文件名为 strategy.in。第一行输入包含 N 和 Q。 接下来的 N-1 行描述地图中的交通线。 每行包括三个整数 pi,qi 和 ri ( 1≤pi,qi≤N， ri&lt;=1000000000 )，表示阵地 pi 和 qi的战略重要性为 ri 。接下来的 Q 行描述了 Q 次查询。 每行包含两个整数，k 和 v (1≤k≤1,000,000,000, 1≤v≤N )，表示一次查询。 Output输出文件名为 strategy.out。输出 Q 行。在第 i 行输出第 i 次查询的的答案。 Sample Input4 31 2 32 3 22 4 41 24 13 1 Sample Output302 Hint对于 20%的数据： N,Q≤3 00对于 50%的数据： N,Q≤5 000对于 100%的数据： N,Q≤100 000 Solution首先会想到离线处理，再根据单调性，想到用并查集维护，将大于等于k的边所连接的点加入并查集，这样对于每个联通块，其中任意两点都是符合“战略相关性”大于等于k的，所以对于每个询问，答案就是v所在联通块点个数减1即可。 上代码： The Code#include&lt;bits/stdc++.h&gt; using namespace std; #define maxn 100005 struct eage{ int u,v,len; friend bool operator &lt;(eage a,eage b){ return a.len&gt;b.len; } }e[maxn]; int np=0; int n,q,x,y,z,fa[maxn],sz[maxn]; struct node{ int id,k,v,ans; friend bool operator&lt;(node a,node b){ return a.k&gt;b.k; } }nd[maxn]; bool cmp(node a,node b){ return a.id&lt;b.id; } int find(int i){ if(fa[i]==i) return i; int root=find(fa[i]); fa[i]=root; return root; } void link(int x,int y){ int fx=find(x),fy=find(y); if(fx!=fy){ fa[fx]=fy; sz[fy]+=sz[fx]; } } bool check(int x,int y){ int fx=find(x),fy=find(y); if(fx!=fy) return false; return true; } void init(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;q); for(int i=1;i&lt;=n;i++) fa[i]=i,sz[i]=1; for(int i=1;i&lt;n;i++){ scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z); e[++np]=(eage){x,y,z}; } for(int i=1;i&lt;=q;i++){ scanf(&quot;%d%d&quot;,&amp;nd[i].k,&amp;nd[i].v);nd[i].id=i; } sort(e+1,e+np+1);sort(nd+1,nd+q+1); int j=1; for(int i=1;i&lt;=q;i++){ while(j&lt;=np&amp;&amp;e[j].len&gt;=nd[i].k){ link(e[j].u,e[j].v); j++; } nd[i].ans=sz[find(nd[i].v)]-1; } sort(nd+1,nd+q+1,cmp); for(int i=1;i&lt;=q;i++) printf(&quot;%d\n&quot;,nd[i].ans); } int main(){ init(); return 0; } T3Description小 Y 正用图章和颜料在草稿纸上乱涂颜色。对于数学敏感的他，突然发现这是一个有意思的数学问题：给出有 N 个格子的纸、宽度为 K 个格子的图章和 M 种不同的颜色，每次用图章把纸上连续的 K 个格子上染任意一种颜色，最后把纸涂满，那么小 Y 想知道最后纸上的颜色序列有多少种不同的情况？ Input输入文件名为 paint.in输入数据仅一行，包含三个整数 N,M,K，他们中间用一个空格分开，分别表示纸张的长度，颜色数目和图章的宽度。 Output输入文件名为 paint.out输出文件仅一行，一个非负整数，表示答案。这个数可能很大，请模1000000007 后输出。 Sample Input3 2 2 Sample Output6 Hint对于 20%的数据 N,M,K≤5对于 50%的数据 N,K≤1 000对于 100%的数据 N,M,K≤10 000 000 Solution真的是数学问题吗？？？首先要明白一点，合法的是要求至少有一个长度为K的相同颜色的块。（这个都没有想出来我好蒻A qwq）然后正难则反，我们只要求出不合法的总个数，然后用总的方法数减去不合法的即为合法的方案数，那么这里用dp,设f[i]为前i个不合法的方案数，那么就不会出现连续k个，所以：$f[i]=f[i-1] \ast m （i&lt;k）​$ $f[i]=(f[i-1]+f[i-2]+…+f[i-k+1]) \ast (m-1) (i&gt;=k)$ 第i个和第i-k个必须不一样再简单加个滑动窗口就可以O(n)过了233333 tips题目中有mod的话，一般不是dp就是数学（套路！！！）上代码： The Code#include&lt;bits/stdc++.h&gt; #define maxn 10000005 using namespace std; typedef long long ll; const ll mod=1000000007; int n,m,k; ll dp[maxn]; ll qkpow(ll t,int pos){ if(pos==0) return 1; if(pos==1) return t%mod; ll tt=qkpow(t,pos/2); if(pos&amp;1) return tt*tt%mod*t%mod; else return tt*tt%mod; } void init(){ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); ll all=qkpow(m,n); dp[0]=1; ll sum=0; for(int i=1;i&lt;k;i++) dp[i]=dp[i-1]*m%mod,sum=(sum+dp[i])%mod; for(int i=k;i&lt;=n;i++){ dp[i]=(sum)*(m-1)%mod; sum=(sum+dp[i]-dp[i-k+1]+mod)%mod; } ll ans=(all-dp[n]+mod)%mod; printf(&quot;%lld&quot;,ans); } int main(){ init(); return 0; } 小结：总结套路a鸽子，多想想那些大佬是怎么思考的。（think twice,code once）]]></content>
      <categories>
        <category>noip模拟赛</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>离线</tag>
        <tag>数学</tag>
        <tag>dp</tag>
        <tag>正难则反</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[祎隋]]></title>
    <url>%2F2018%2F10%2F16%2F11%2F</url>
    <content type="text"><![CDATA[童话，被同化前做过的梦《祎隋》 我们因多少人孤单 又有多少人为我们不安 等待是漫长的表演 相安是莫大的荒诞 为搏那一瞬笑颜 熹光几点 我们敢于冒险 心怀本愿 却屡次三番 无法实现 使得停滞不前 初心淡暗 何时起相顾无言 仿佛就从昨天 再忆那春风不及的笑脸 已是许久以前 颔首 低眉 轻笑 每个瞬间 浅唱 微吟 翩舞 总拨心弦 可我没有华丽诗篇 没有道貌伟岸 只有痴心一片 闲心几点 忽而悄然自言 你可曾是我心中的四月天？ 回神漠然 青春已半 不如数月以前 我们未曾相见 窗沿 雨 雷电 深夜未眠 愿初心不变 心境自然 虽喜忧掺半 往前仍是少年]]></content>
      <categories>
        <category>杂诗</category>
      </categories>
      <tags>
        <tag>杂诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF350E Wrong Floyd]]></title>
    <url>%2F2018%2F10%2F16%2F10%2F</url>
    <content type="text"><![CDATA[Description给定n个点,m条边以及k个标记点，要求进行Floyd时只以标记的点为中间点进行松弛操作（每条边边权为1）要求你造出m条边的数据来hack掉这种程序。 Hint3&lt;=n&lt;=300 , 2&lt;=k&lt;=n2&lt;=k&lt;=n , n-1&lt;=m&lt;=n*(n-1)/2; Solution我们只需要任意一点只和非标记点连边就可以了（这样就无法正确更新它到其他点的距离） 具体一下几个细节： 1.判k==n或m&gt;最多可以构出的边maxm； maxm=(n-1)*(n-2)/2+num;（num:非标记点的数量） 2.将随便一个标记点与所以非标记点连边； 3.再随便一个非标记点与未加入图中的点连边来保证图的联通； 4.最后随便加未加的边使边数凑够m即可； The Code#include&lt;bits/stdc++.h&gt; #define maxn 310 using namespace std; int n,m,k,x,num; bool vis[maxn],iss[maxn][maxn],viss[maxn]; void init(){ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=n;i++) iss[i][i]=1; for(int i=1;i&lt;=k;i++) scanf(&quot;%d&quot;,&amp;x),vis[x]=1; num=n-k; int maxx=(n-1)*(n-2)/2+num; if(m&gt;maxx||k==n){ printf(&quot;-1&quot;);return; } int t,tt=1;int calc=0; while(!vis[tt]) tt++; viss[tt]=1; for(int i=1;i&lt;=n;i++){ if(!vis[i]){ t=i; viss[t]=1; printf(&quot;%d %d\n&quot;,t,tt); iss[t][tt]=iss[tt][t]=1; calc++; } } //保证联通 for(int i=1;i&lt;=n;i++){ if(viss[i]) continue; printf(&quot;%d %d\n&quot;,i,t); iss[i][t]=iss[t][i]=1; calc++; if(calc==m) break; } for(int i=1;i&lt;=n;i++){ if(calc==m) break; if(i==tt) continue; for(int j=1;j&lt;=n;j++){ if(j==tt) continue; if(iss[i][j]) continue; printf(&quot;%d %d\n&quot;,i,j); calc++; iss[i][j]=iss[j][i]=1; if(calc==m) break; } } } int main(){ init(); return 0; }]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[32.Sort]]></title>
    <url>%2F2018%2F10%2F16%2F9%2F</url>
    <content type="text"><![CDATA[Description众所周知，排序方法有许多种。例如：简单易懂的冒泡排序，平均复杂度较优的快速排序，以及不基于比较的基数排序等等。 现在，小 DD 得到了一个自然数序列 {a1,a2,⋯,an}{a1,a2,⋯,an}。他想要对其按照从小到大的顺序进行排序（即使得每个元素均严格不大于他的后继元素）。但由于基于比较的排序算法复杂度下界已经被证明为 Θ(nlog2n)Θ(nlog2⁡n)，所以小 DD 决定尝试一种全新的排序算法：翻转排序。 在翻转排序中，小 DD 在每次操作中，可以选择一个区间 [l,r][l,r] (1≤l≤r≤n)(1≤l≤r≤n)，并翻转 al,al+1,⋯,aral,al+1,⋯,ar。即，在该次操作完后，序列将会变为 a1,a2,⋯,al−1,ar,ar−1,⋯,al+1,al,ar+1,ar+2,⋯,ana1,a2,⋯,al−1,ar,ar−1,⋯,al+1,al,ar+1,ar+2,⋯,an。 例如，对于序列 [1,6,2,4,3,5][1,6,2,4,3,5]，若选择区间 [2,4][2,4] 进行翻转，则将会得到 [1,4,2,6,3,5][1,4,2,6,3,5]。 定义一次操作的代价为 r−l+1r−l+1，即翻转的区间长度。定义一个操作序列的代价为每次操作的代价之和。现在，请你帮助小 DD 求出一个代价足够小的操作序列（你并不一定要求出代价最小的操作序列）。 Input第一行一个正整数 nn，表示序列长度。 第二行 nn 个空格隔开的非负整数，表示小 DD 得到的自然数序列 a1,a2,⋯,ana1,a2,⋯,an。 Output输出若干行，每行两个空格隔开的正整数 l,rl,r (1≤l≤r≤n)(1≤l≤r≤n)，表示一次翻转区间 [l,r][l,r] 的操作。 最后输出一行 -1 -1，标志着操作序列的结束。 Sample Input4 1 3 2 4 Sample Output2 3 -1 -1 Hint1.下发文件中提供了 checker.cpp，该程序将对于其所在目录下的 sort.in，判断其所在目录下的 sort.out 是否为一个正确的操作序列。若正确，将给出该操作序列的代价。若不正确，将给出错误信息。选手可以借助该程序来更好地检查自己的程序是否正确。 运行时，必须保证 sort.in 为一个合法的输入，且需保证 sort.out 符合题目中描述的输出格式，否则出现任何结果均有可能。 2.对于所有测试数据，保证 1≤n≤500001≤n≤50000，且 0≤ai≤1090≤ai≤109。 （附checker.cpp） #include &lt;algorithm&gt; #include &lt;cstdio&gt; int arr[50005]; int main() { FILE *fin = fopen(&quot;sort.in&quot;, &quot;r&quot;), *fout = fopen(&quot;sort.out&quot;, &quot;r&quot;); if (!fin) { puts(&quot;INVALID : File sort.in not found.&quot;); return -1; } if (!fout) { puts(&quot;INVALID : File sort.out not found.&quot;); return -1; } int n; fscanf(fin, &quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) fscanf(fin, &quot;%d&quot;, arr + i); int l, r, sum = 0; while (~fscanf(fout, &quot;%d%d&quot;, &amp;l, &amp;r)) { if (l == -1 &amp;&amp; r == -1) break; sum += r - l + 1; if (l &lt;= 0 || l &gt; n) { printf(&quot;INVALID : l = %d is not in range [1, %d].\n&quot;, l, n); return -1; } if (r &lt;= 0 || r &gt; n) { printf(&quot;INVALID : r = %d is not in range [1, %d].\n&quot;, r, n); return -1; } if (l &gt; r) { printf(&quot;INVALID : %d = l &gt; r = %d.\n&quot;, l, r); return -1; } if (sum &gt; 20000000) { puts(&quot;INVALID : Too much cost.&quot;); return -1; } std::reverse(arr + --l, arr + r); } bool f = true; for (int i = 1; i &lt; n; i++) f &amp;= arr[i] &gt;= arr[i - 1]; if (!f) { puts(&quot;INVALID : Not sorted.&quot;); return -1; } printf(&quot;VALID : Total cost is %d.\n&quot;, sum); return 0; } checker Solution本题算是一个比较新颖的题目，实际上是用这种翻转来模拟实现归并排序: 先将给定数列进行离散化，每次选定一个中间的数，将小于等于它的排在左边，大于它的排在右边，再依次递归两边就可以了； 主要是复杂度（进行操作的次数）证明a…. 排一遍要n，由于其非01性，所以进行log2n次的n排，故排一遍将l到r以stdd为标准换为左边小于等于stdd，右边大于等于stdd的操作数为Θ(nlog2n) ； T(n) = 2T(n/2) + Θ(nlog2n),可以解得 T(n) = Θ(nlog22n) ； tql%%%上代码。 #include&lt;bits/stdc++.h&gt; #define maxn 50005 using namespace std; int n,pos[maxn]; struct node{ int v,id; friend bool operator&lt;(node a,node b){ return a.v&lt;b.v; } }nd[maxn]; int stdd; void run(int l,int r){ if(l==r) return; int mid=l+r&gt;&gt;1; run(l,mid);run(mid+1,r); int L,R;//要翻转的区间 L=R=mid;//L和R的初值 int i=mid,j=mid+1; while(i&gt;=l&amp;&amp;pos[i]&gt;stdd) L=i--; while(j&lt;=r&amp;&amp;pos[j]&lt;=stdd) R=j++; if(L!=R){ printf(&quot;%d %d\n&quot;,L,R); reverse(pos+L,pos+R+1); } } void msort(int l,int r){ if(l==r) return; int mid=stdd=(l+r)&gt;&gt;1; run(l,r);//将l到r以stdd为标准换为左边小于等于stdd，右边大于等于stdd msort(l,mid);msort(mid+1,r); } void init(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;nd[i].v);nd[i].id=i; } sort(nd+1,nd+n+1); for(int i=1;i&lt;=n;i++) pos[nd[i].id]=i;//离散化位置确定 msort(1,n); printf(&quot;-1 -1\n&quot;); } int main(){ //freopen(&quot;sort.in&quot;,&quot;r&quot;,stdin); //freopen(&quot;sort.out&quot;,&quot;w&quot;,stdout); init(); return 0; }]]></content>
      <categories>
        <category>Noi.ac</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数对子]]></title>
    <url>%2F2018%2F10%2F16%2F8%2F</url>
    <content type="text"><![CDATA[Description我们定义一个数对 (x,y) 是好的，当且仅当 x≤y，且 x xor y的二进制表示下有奇数个 1 现在给定 nn 个区间 [li,ri]，你需要对于每个 i∈[1,n]，输出有几对好的数 (x,y)满足 x 和 y 都在 [l1,r1]∪[l2,r2]…∪[li,ri]，即两个数都在前 i 个区间的并里 Input第一行一个正整数 n 接下来 n 行每行两个整数 [li,ri]，表示第 i个区间，保证 li≤ri Ouput输出 n 行，第 i行一个整数表示有几对好的数 (x,y) 满足 x,y 都在前 i 个区间的并里 Sample Input3 1 7 3 10 9 20 Sample Output12 25 100 Hint对于 30%30% 的数据，有 1≤n≤1001≤n≤100，1≤li≤ri≤1001≤li≤ri≤100 对于 50%50% 的数据，有 1≤n≤10001≤n≤1000，1≤li≤ri≤232−11≤li≤ri≤232−1 对于 100%100% 的数据，有 1≤n≤1051≤n≤105, 1≤li≤ri≤232−11≤li≤ri≤232−1 时间限制：2s 空间限制：512MB Solutiontips先补充几个小知识点（快速求出一个数的二进制中有多少个1）: x=x&amp;(x-1)（递归求法，适用于单个数） 表达式的意思就是:把x的二进制表示 从低位开始，将遇到的第一个为1的 二进制位 置0。 int calc=0; while(x) x=x&amp;(x-1),calc++; calc即为所求值 求0到x中有多少二进制含1个数为奇数的： long long calc(long long x) { long long tmp=x,tot=0; while(tmp) { if(tmp&amp;1)tot++; tmp&gt;&gt;=1; } return (x&gt;&gt;1)+((x&amp;1) || (tot&amp;1)); } 证明：00 01 10 11 100 101 110 111....继续下去可以发现规律是偶奇奇偶奇偶偶奇.... 所以x&gt;&gt;1之前一半的，如果x为奇数（会少算一个）或其本身有奇数个1得加上 所以说探究性质a老哥(这个性质也可以记住) p.s.当线段树叶子节点有n个时，应开总共2^(log2n+1)个点，即2*n个点 正经题解开始：首先，对于每个数对（x,y）, 若要x xor y的二进制表示下有奇数个 1，则必定一者含奇数个1，一者含偶数个。 证明：若两个都为奇数，1.则奇减奇等于偶（重叠个数为奇个）2.奇减偶先为奇（重叠个数为偶数个），奇加奇等于偶 ​ 若两个都为偶数，则可同上证明 ​ 一奇一偶，1.奇减奇等于偶，偶减奇等于奇，奇加偶等于奇2.奇减偶等于奇，偶减偶等于偶，偶加奇等于奇 所以我们采取线段树来维护区间含奇数个1和含偶数个1的个数，对于区间l,r，则用上述中所介绍的calc函数，来calc(r)-calc(l-1)得到奇数个1个数以及r-l+1-（calc(r)-calc(l-1)）得到偶数个1个数 每次输入一个区间加进去统计一个区间，然后输出总的相乘即可。p.s.线段树很好的解决了区间相交的问题，在以及统计过的区间标记vis[now]=1; 上代码： #include&lt;bits/stdc++.h&gt; #define maxn 100005 using namespace std; typedef long long ll; ll num[maxn&lt;&lt;4][2]; int lc[maxn&lt;&lt;4],rc[maxn&lt;&lt;4],rt=0,np=0; int n; bool vis[maxn&lt;&lt;4]; void upload(int now){ num[now][0]=num[lc[now]][0]+num[rc[now]][0]; num[now][1]=num[lc[now]][1]+num[rc[now]][1]; } ll calc(ll x) { ll t=x,tot=0; while(t) { if(t&amp;1)tot++; t&gt;&gt;=1; } return (x&gt;&gt;1)+((x&amp;1) || (tot&amp;1)); } void update(int &amp;now,ll l,ll r,ll x,ll y){ if(!now) now=++np; if(vis[now]) return; if(l&gt;=x&amp;&amp;r&lt;=y){ num[now][1]=calc(r)-calc(l-1); num[now][0]=r-l+1-num[now][1]; vis[now]=1; return; } ll m=(l+r)&gt;&gt;1; if(y&lt;=m)update(lc[now],l,m,x,y); else if(x&gt;m)update(rc[now],m+1,r,x,y); else{ update(lc[now],l,m,x,y); update(rc[now],m+1,r,x,y); } upload(now); } void init(){ scanf(&quot;%d&quot;,&amp;n); ll L,R,mx=1ll&lt;&lt;32; for(int i=1;i&lt;=n;i++){ scanf(&quot;%lld%lld&quot;,&amp;L,&amp;R); update(rt,1,mx,L,R); printf(&quot;%lld\n&quot;,num[1][0]*num[1][1]); } } int main(){ init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>二进制</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[祎隋]]></title>
    <url>%2F2018%2F10%2F16%2F7%2F</url>
    <content type="text"><![CDATA[愿你像个孩子，愿你心生双翼 《祎隋》 青涩 带着年少初识的忐忑 我们相遇了 传奇 三年来我们所追寻的词字 一段故事 从这里轻启 回忆 忘不却从前往事 追不上白驹过隙 再聚 仿佛多年往复 传奇已铸 但我们的故事未完待续 我们的航船才起征途 愿 愿相框里的我们永远闪闪发光 愿你仍是原般模样]]></content>
      <categories>
        <category>杂诗</category>
      </categories>
      <tags>
        <tag>杂诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF351B Jeff and Furik]]></title>
    <url>%2F2018%2F10%2F16%2F6%2F</url>
    <content type="text"><![CDATA[Description给一个1~n的排列p[i]，Jeff先手可以交换任意两个相邻元素，而Furik会有0.5的几率把任意满足p[i] &lt; p[i+1]的p[i]和p[i+1]交换，有0.5的几率把任意满足p[i] &gt; p[i+1]的p[i]和p[i+1]交换，问将整个序列变成升序所需的最小期望步数 Input第一行一整数n表示序列长度，之后一个1~n的排列p[i] (1&lt;=n&lt;=3000) Output输出把整个序列变成升序所需的最小期望步数 Sample Input53 5 2 4 1 Sample Output13.000000 Solution考虑E[i]（i为逆序对个数）的最小期望步数，则E[0]=0,E[1]=1;那么每一次Jeff肯定是交换使逆序对减少一个而Furik则有50%减少一个50%增加一个，故$E[i]=1/2(E[i-2]+1)+1/2(E[i-1+1]+1)$;化简得$E[i]=E[i-2]+4$; 故模拟归并排序求一次逆序对个数便可实现。 Code#include&lt;bits/stdc++.h&gt; #define maxn 3005 using namespace std; int n,a[maxn],t[maxn]; int msort(int l,int r){ if(l==r) return 0; int m=l+r&gt;&gt;1; int t1=msort(l,m); int t2=msort(m+1,r); int t3=0; int i=l,j=m+1,k=l; while(i&lt;=m&amp;&amp;j&lt;=r){ if(a[i]&gt;a[j]){ t3+=m-i+1; t[k++]=a[j++]; } else{ t[k++]=a[i++];//本来就应该小于 } } while(i&lt;=m) t[k++]=a[i++]; while(j&lt;=r) t[k++]=a[j++]; for(int p=l;p&lt;=r;p++) a[p]=t[p];//调整 return t1+t2+t3; } void init(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); int nd=msort(1,n); if(nd&amp;1){ printf(&quot;%lf&quot;,(double)(2*nd-1)); } else printf(&quot;%lf&quot;,(double)2*nd); } int main(){ init(); return 0; }]]></content>
      <categories>
        <category>CF</category>
      </categories>
      <tags>
        <tag>概率期望</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卡常数]]></title>
    <url>%2F2018%2F10%2F16%2F5%2F</url>
    <content type="text"><![CDATA[Decription（在十进制下）定义 mn(i) 表示把 i 的各位数字从小到大排序得到的数，mx(i) 表示从大到小得到的数。这里的数是允许有前导零的，比如mn(10000)=00001=1 ， mx(132)=321 等。定义 f(i)=mx(i)−mn(i) 。当然，这里 mx(i) 的定义是要在某个整数 k 位十进制数下的。 卡常数指印度数学家Kaprekar发现的常数 6174 。他发现，任取一个各位数字不全相同的四位数 x，不断地使 x=f(x) ，最终总能得到 6174 。 现在Fizzydavid学习了高级的卡常数技巧，他想知道对于五位数的情况。他每次会给你一个带前导零的五位数x，要让你求出操作 x=f(x) 进行 c 次之后的结果。他每次给你的 c 都是一样的。此时 f 定义中的 k=5。 Input第一行两个整数 T,c 。T 表示询问次数，c 的含义如题面。 接下来 T 行每行一个五位数 x ，不足五位会加前导零补到五位。 Output对于每个询问输出一行表示答案。不足五位需要补到五位。 Hint1≤T≤105,1≤c≤109,0≤x&lt;105 。 20%的数据保证 c≤10 。 另外20%的数据保证 T≤10 。 另外30%的数据保证 c≥105 。 时间限制： 2s 空间限制： 512MB Solutionwoc这道题思路很Nice啊。首先会想到肯定每个数进行一定次数之后会循环(不然就没法做了a)。然后这里应该要想到我们对当前的数求循环的时候，我们事实上已经对所有经过的数求出来了，这样稍微处理一下就可以保证每个数只被访问一次。但这样还是会T a。。。于是探究性质：发现对于一个x进行a+b次操作等于先将x进行a次操作，再进行b次操作，或者反过来，再进一步想到可以倍增预处理(Nice啊).这样就欧克了a(注意倍增不要写错a在刷状态的时候QAQ) tips1.以后遇到这种性质都可以考虑倍增(LCA也有这种性质嘛)2.补充一下姿势（雾%nd 输出的整型宽度至少为n位，右对齐，%5d即宽度至少为5位，位数大于5则输出实际位数%0nd 用得比较多，表示输出的整型宽度至少为n位，不足n位用0填充printf（”%05d”,1）输出：00001printf（”%5d”,1）输出：**1（$*$为空格） The Code#include&lt;bits/stdc++.h&gt; #define maxn 100005 using namespace std; int n,x,c; int g[100005][31],mx,mn,a[7]; int cmp(int x,int y){ return x&gt;y; } int f(int x){ memset(a,0,sizeof(a)); int pos=6; while(x){ a[--pos]=x%10;x/=10; } sort(a+1,a+6);mn=a[1]*10000+a[2]*1000+a[3]*100+a[4]*10+a[5]; sort(a+1,a+6,cmp);mx=a[1]*10000+a[2]*1000+a[3]*100+a[4]*10+a[5]; return mx-mn; } void pre(){ for(int i=0;i&lt;=99999;i++) g[i][0]=f(i); for(int j=1;j&lt;=30;j++) for(int i=0;i&lt;=99999;i++) g[i][j]=g[g[i][j-1]][j-1]; } bool vis[31]; void init(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;c); for(int i=0;i&lt;=30;i++) if(c&amp;(1&lt;&lt;i)) vis[i]=1; for(int i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;x); for(int j=0;j&lt;=30;j++) if(vis[j]) x=g[x][j]; printf(&quot;%05d\n&quot;,x); } } int main(){ pre(); init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>倍增</tag>
        <tag>预处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树]]></title>
    <url>%2F2018%2F10%2F16%2F4%2F</url>
    <content type="text"><![CDATA[The Solutionemmmmmmmm，这道题题意读错了a，有点难受…很考细节的一道题，同时告诉我们细节题要对拍。首先我们要维护的是最大的剩余空间，但实质上是最大的最近距离，比如区间所剩为5和4，实际上它们的最近距离都为2。在设定友好函数时要注意。在处理好一般操作之后是特判，主要就是对于两端的处理，因为它们是独立成段的(图中红色部分)，所以只要红色长度大于最近距离即更优。垃圾贴图库炸了，已换图床不会再出现此种情况最后要注意标号尽可能小的细节。 The Code#include&lt;bits/stdc++.h&gt; #define maxn 200005 using namespace std; struct node{ int l,r; friend bool operator &lt;(node a,node b){ if((a.r-a.l)/2!=(b.r-b.l)/2)return (a.r-a.l)/2&gt;(b.r-b.l)/2; //排得是这个最近距离aQAQ 并且不能将2免去，因为奇偶 else return a.l&lt;b.l; } }; set&lt;node&gt;s; set&lt;node&gt;::iterator it; int n,m,x,y; map&lt;int,int&gt;mp; int pre[maxn],next[maxn],st[maxn],rk[maxn]; int np=0; void init(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); s.insert((node){0,n+1}); pre[0]=0;next[0]=n+1;pre[n+1]=0;next[n+1]=n+1; for(int i=1;i&lt;=m;i++){ scanf(&quot;%d%d&quot;,&amp;x,&amp;y); /*if(x==1){ if(t.l==0&amp;&amp;t.r==n+1){ st[np]=1; rk[1]=np; next[0]=1; next[1]=n+1; pre[n+1]=1; s.erase((node){0,n+1}); s.insert((node){0,1});s.insert((node){1,n+1}); printf(&quot;1\n&quot;);continue; } if(t.l==1&amp;&amp;t.r==n+1){ st[np]=n; rk[n]=np; pre[n]=1; next[n]=n+1; pre[n+1]=n; next[0]=1; s.erase((node){1,n+1}); s.insert((node){1,n});s.insert((node){n,n+1}); printf(&quot;%d\n&quot;,n);continue; }*/ if(x==1){ mp[y]=++np; it=s.begin(); node t=*it; int len=(t.r-t.l)/2; bool ok1=false,ok2=false; int len1=0,len2=0; if(!rk[1]) len1=next[0]-1;if(!rk[n]) len2=n-pre[n+1]; if(len2&gt;len1) ok2=true;else ok1=true;//标号 if(!rk[1]&amp;&amp;ok1){//要考虑两端点的问题 if(next[0]-1&gt;=len){//标号优先 st[np]=1; rk[1]=np; next[1]=next[0];pre[next[0]]=1;next[0]=1; s.erase((node){0,next[1]}); s.insert((node){0,1}); s.insert((node){1,next[1]}); printf(&quot;1\n&quot;);continue; } } if(!rk[n]&amp;&amp;ok2){ if(n-pre[n+1]&gt;len){ st[np]=n; rk[n]=np; pre[n]=pre[n+1];next[pre[n+1]]=n;pre[n+1]=n; s.erase((node){pre[n],n+1}); s.insert((node){n,n+1}); s.insert((node){pre[n],n}); printf(&quot;%d\n&quot;,n);continue; } } int position=t.l+len;rk[position]=np;st[np]=position; pre[position]=t.l;next[position]=t.r;pre[t.r]=position; next[t.l]=position; printf(&quot;%d\n&quot;,position); s.erase((node){pre[position],next[position]}); s.insert((node){pre[position],position}); s.insert((node){position,next[position]}); } else{ int t=st[mp[y]]; s.erase((node){pre[t],t}); s.erase((node){t,next[t]}); s.insert((node){pre[t],next[t]}); rk[t]=0; next[pre[t]]=next[t]; pre[next[t]]=pre[t]; pre[t]=next[t]=0; } } } int main(){ init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[减肥计划]]></title>
    <url>%2F2018%2F10%2F15%2F3%2F</url>
    <content type="text"><![CDATA[Solution哇，这道题还是太急了，探究出个性质就直接溜了。首先当$\sum{a_i}$一定时，$\sum{b_i}$越大肯定越优，那么可以dp[i]表示$\sum{a_i}$为i时最大的$\sum{b_i}$之值。由于a的和为$n \ast max({a_i})$，所以总的复杂度会是$n^2 \ast max({a_i})$。显然会超时。所以我们来探求性质，发现当答案为$\frac{\sum{a_i}}{\sum{b_i}}$，若此时有$\frac{a_i}{b_i}$大于它时，那么加入一定会增大，反之加入小于的会减小，所以我们对于一个答案，不断删去小于它的$\frac{a_i}{b_i}$，直到$\sum{a_i}$&lt;m后停下来，那么过程中不会减小，此时再加入大于的即可，所以最多只用dp到$max({a_i})+m$，因此时间复杂度也降为$n \ast (m+max({a_i}))$ ，即可通过此题。 上代码： Code#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cctype&gt; #include&lt;set&gt; #include&lt;algorithm&gt; #include&lt;map&gt; #include&lt;queue&gt; #define maxn 10000005 using namespace std; typedef long long ll; int n,m; ll dp[maxn&lt;&lt;1],a[maxn],b[maxn]; ll gcd(ll x,ll y){ if(y==0) return x; else return gcd(y,x%y); } ll maxx=0,sum=0; void init(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;a[i],&amp;b[i]),maxx=max(maxx,a[i]),sum+=a[i]; if(sum&lt;m){printf(&quot;-1&quot;);return;} for(int i=1;i&lt;=m+maxx;i++) dp[i]=-0x3f3f3f3f; dp[0]=0; for(int i=1;i&lt;=n;i++) for(int j=maxx+m;j&gt;=a[i];j--) dp[j]=max(dp[j],dp[j-a[i]]+b[i]); ll fz=-1,fm=1; for(int i=m;i&lt;=maxx+m;i++) if(fz*i&lt;dp[i]*fm) fz=dp[i],fm=i; ll g=gcd(fz,fm); fz/=g;fm/=g; printf(&quot;%d/%d&quot;,fz,fm); } int main(){ init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>dp</tag>
        <tag>正睿</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正睿普转提9.16]]></title>
    <url>%2F2018%2F10%2F15%2F14%2F</url>
    <content type="text"><![CDATA[代码记录…T1#include&lt;bits/stdc++.h&gt; #define maxn 100005 using namespace std; typedef long long ll; int n,fa[maxn],ch[maxn][2],x; ll st[maxn],a[maxn]; int top=0; void dfs(int i){ if(ch[i][0]) dfs(ch[i][0]); st[++top]=a[i]; if(ch[i][1]) dfs(ch[i][1]); } ll q[maxn]; int rear=0; void run(ll x){ /*if(x&gt;=q[rear]){ q[++rear]=x; return; } int l=1,r=rear,mid; while(l&lt;=r){ mid=(l+r)&gt;&gt;1; if(q[mid-1]&lt;=x&amp;&amp;x&lt;q[mid]){q[mid]=x;return;} if(x&lt;q[mid-1]) r=mid-1; else l=mid+1; }*/ int t=upper_bound(q+1,q+rear+1,x)-q; if(t==rear+1) q[++rear]=x; else q[t]=x;//将刚好大于它的代替，这里是运用了贪心思想a } void init(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]); for(int i=2;i&lt;=n;i++){ scanf(&quot;%d%d&quot;,&amp;fa[i],&amp;x); ch[fa[i]][x]=i; } dfs(1); for(ll i=1;i&lt;=top;i++) st[i]=st[i]-i; q[0]=-10000000000; for(int i=1;i&lt;=top;i++) run(st[i]); int ans=n-rear; printf(&quot;%d&quot;,ans); } int main(){ init(); return 0; } T2#include&lt;bits/stdc++.h&gt; #define maxn 500005 using namespace std; int n,a[maxn],np=0,rt=0; int gcd(int x,int y){ if(y==0) return x; else return gcd(y,x%y); } int minv[maxn][20],gcdd[maxn][20],logg[maxn],w[25]; void ready(){ w[0]=1; logg[0]=-1; for(int i=1;i&lt;=20;i++) w[i]=w[i-1]*2; for(int i=1;i&lt;=maxn-5;i++) logg[i]=logg[i/2]+1; for(int i=1;i&lt;=n;i++){ minv[i][0]=gcdd[i][0]=a[i]; } for(int i=1;i&lt;=logg[n];i++)//加个1保个险 for(int j=1;j&lt;=n;j++) if(j+w[i]-1&lt;=n){ minv[j][i]=min(minv[j][i-1],minv[j+w[i-1]][i-1]);//本来是j+(1&lt;&lt;(i-1))-1+1 gcdd[j][i]=gcd(gcdd[j][i-1],gcdd[j+w[i-1]][i-1]); } } int cd1(int i,int j){ int len=j-i+1; int t=logg[len]; return min(minv[i][t],minv[j-w[t]+1][t]); } int cd2(int i,int j){ int len=j-i+1; int t=logg[len]; return gcd(gcdd[i][t],gcdd[j-w[t]+1][t]); } int st[maxn],top=0,yb[maxn],topp=0; bool check(int mid){ topp=0; bool ok=false; for(int i=1;i&lt;=n-mid+1;i++){ int j=i+mid-1; if(cd1(i,j)==cd2(i,j)){ ok=true; yb[++topp]=i; } } if(ok){ top=0; for(int i=1;i&lt;=topp;i++) st[++top]=yb[i]; return true; } return false; } void run(){ int A=1,B=n,mid,ans; while(A&lt;=B){ mid=A+B&gt;&gt;1; if(check(mid)) ans=mid,A=mid+1; else B=mid-1; } printf(&quot;%d %d\n&quot;,top,ans-1);//L-R for(int i=1;i&lt;=top;i++) printf(&quot;%d &quot;,st[i]); } void init(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); ready(); run(); } int main(){ init(); return 0; } T3#include&lt;bits/stdc++.h&gt; #define maxn 55 using namespace std; typedef long long ll; const ll mod=1e9+7; ll c[maxn][maxn],dp[maxn][maxn]; int p[maxn],n; void ready(){ for(int i=0;i&lt;=50;i++){ c[i][0]=1; for(int j=1;j&lt;=i;j++) c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod; } } ll dfs(int len,int now){ if(dp[len][now]!=-1) return dp[len][now]; if(len==1) return dp[len][now]=1; ll ans=0;int j,k,pos=0,t[maxn];//pos和t只有内定了给，不然要重 函数递归时会改变 for(int i=1;i&lt;=n;i++) if(p[i]&gt;=now&amp;&amp;p[i]&lt;now+len) t[++pos]=p[i];//pos==len for(int i=1;i&lt;pos;i++){ swap(t[i],t[i+1]);//枚举交换的位置 for(j=1;j&lt;=i;j++)//判断是否满足 if(t[j]&gt;=now+i) break;//最多为now+i-1; for(k=i+1;k&lt;=pos;k++) if(t[k]&lt;now+i) break;//最小为now+i; if(j&gt;i&amp;&amp;k&gt;pos){ ll t1=dfs(i,now); ll t2=dfs(pos-i,now+i); ans=(ans+t1*t2%mod*c[pos-2][i-1]%mod)%mod;//第一个:now~now+i-1 第二个now+i~now+len-1; //在这之前进行n-2次交换,前i-1次选择前面来处理前面的i个 } swap(t[i],t[i+1]); } return dp[len][now]=ans; } void init(){ scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;p[i]); memset(dp,-1,sizeof(dp)); dfs(n,0); if(dp[n][0]==-1) printf(&quot;%d&quot;,0); else printf(&quot;%lld&quot;,dp[n][0]); } int main(){ ready(); init(); return 0; } T4#include&lt;bits/stdc++.h&gt; #define maxn 305 using namespace std; int n,m,k; double a[maxn],b[maxn*maxn];//b:(k-x,m-x)/(k,m) 而x最多为n^2 void ready(){ a[0]=1.0; for(int i=1;i&lt;=n;i++) a[i]=a[i-1]*(n-i+1)*1.0/i; b[0]=1; for(int i=1;i&lt;=n*n;i++) b[i]=b[i-1]*(k-i+1)*1.0/(m-i+1); } void outt(){ printf(&quot;1&quot;); for(int i=1;i&lt;=99;i++) printf(&quot;0&quot;); } int main(){ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); ready(); double ans=0; for(int i=0;i&lt;=n;i++) for(int j=0;j&lt;=n;j++){ int x=(i+j)*n-i*j; if(x&gt;k) break;//再加只会更多 ans+=a[i]*a[j]*b[x]; } if(ans&gt;1e99) outt(); else printf(&quot;%lf&quot;,ans); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>概率期望</tag>
        <tag>数学</tag>
        <tag>dp</tag>
        <tag>LIS</tag>
        <tag>ST表</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小瓶颈生成树]]></title>
    <url>%2F2018%2F10%2F15%2F2%2F</url>
    <content type="text"><![CDATA[所谓最小瓶颈生成树….就是使得生成树树上最大边权值最小。这里主要介绍一种期望O（M）（线性）的求法，其实主要就是二分，具体思路如下： 类比找第k大值的方法，首先随机一个边权w。 然后将不超过这个边权的边加入，遍历这张图。 如果图连通，那么瓶颈不超过w，于是只需考虑边权不超过w的边。 否则将这些连通点缩起来，考虑边权大于w的边。 每次将问题的规模缩小至一半。 期望时间复杂度O(m)。 相关例题有两道：A.Hangar Hurdles (CERC 16) 有一个n*n的网格图，上面有些格子可行，有些格子是障碍。 有Q个询问，想把一个正方形箱子从(r1,c1)推到(r2,c2)，问箱子最大的大小。（起点终点是正方形箱子的中点） N&lt;=1000 Q&lt;=300000 B.洪蛤吨有一个宽度为L的管道，我们可以视其为一条y=L的直线与X轴所夹的部分。 （所以这根管道的长度可以视为正无穷） 这个管道中有个N个障碍点，第i个障碍点的坐标为(Xi,Yi)。 已知有一个球体，能在不碰到障碍点的前提下，从管道的最左端走到最右端。（即从管道内横坐标负无穷的地方走到横坐标正无穷的地方）。 求这个球体的直径最大是多少。为了避免精度误差，请输出答案保留三位小数的结果。 两题有异曲同工之妙a…（/滑稽，思路差不多…）都可以用最小瓶颈树实现复杂度最小下面上一下t2的代码：（没有用最小瓶颈树优化，逃） #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; #include&lt;cmath&gt; #include&lt;cctype&gt; #include&lt;set&gt; #include&lt;algorithm&gt; #include&lt;map&gt; #include&lt;queue&gt; #define maxn 505 using namespace std; struct eage{ int u,v; double dist; }e[maxn*maxn/2+maxn*2]; bool cmp(eage a,eage b){ return a.dist&lt;b.dist; } double dis(int x1,int y1,int x2,int y2){ return sqrt(1.0*(x1-x2)*(x1-x2)+1.0*(y1-y2)*(y1-y2)); } int fa[maxn]; int find(int x){ if(fa[x]==x) return x; int root=find(fa[x]); fa[x]=root; return root; } void link(int x,int y){ int fx=find(x),fy=find(y); if(fx!=fy){ fa[fx]=fy; } } bool check(int x,int y){ int fx=find(x),fy=find(y); if(fx!=fy) return false; return true; } int l,n; struct node{ int x,y; }nd[maxn]; void init(){ int pos=0; scanf(&quot;%d%d&quot;,&amp;n,&amp;l); for(int i=1;i&lt;=n+2;i++) fa[i]=i;//n+1是上，n+2是下 for(int i=1;i&lt;=n;i++){ scanf(&quot;%d%d&quot;,&amp;nd[i].x,&amp;nd[i].y); } for(int i=1;i&lt;=n;i++){ e[++pos]=(eage){i,n+1,l-nd[i].y}; e[++pos]=(eage){i,n+2,nd[i].y}; for(int j=i+1;j&lt;=n;j++){ e[++pos]=(eage){i,j,dis(nd[i].x,nd[i].y,nd[j].x,nd[j].y)}; } } int cnt=0; sort(e+1,e+pos+1,cmp); for(int i=1;i&lt;=pos;i++){ int u=e[i].u,v=e[i].v; if(check(u,v)) continue; link(u,v); cnt++; if(find(n+1)==find(n+2)){//只要上底和下底连接了就行 这样才能保证极大值可以通过，如果后面更大，那这里是过不了的 printf(&quot;%.3f&quot;,e[i].dist); break; } } } int main(){ init(); return 0; }]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>最小瓶颈生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UpdateAfterEvent]]></title>
    <url>%2F2018%2F10%2F15%2F1%2F</url>
    <content type="text"><![CDATA[Description​ 小松鼠打了10个小时的游戏，一脸满足。却发现周围再次围满了游客，逃！ 她发现整个西湖内的松鼠都以相同的速度在树之间跳跃。每跳跃一次花费一个单位的时间。我们可以把西湖抽象为一张n个点的无向图，初始时每个点上都有若干只松鼠，它们每单位时间都可以沿着一条无向边进行跳跃。 对于一只当前在点i的松鼠，它在接下来的一个单位时间内等概率向相邻的点跳跃。更具体地讲，我们称与点i通过一条无向边直接相连的点为与i相邻的点，假设这样的点有p个，那么对于每一个与i相邻的点，在下一时刻都有1/p的概率跳到它。 超萌小松鼠已知初始时刻（0时刻）每棵树上的松鼠分布情况，她想知道在T时刻，在同一棵树上的松鼠对数的期望。关于“松鼠对数”的解释：假设有4只松鼠在同一棵树上，那么我们称有6对在同一棵树上的松鼠。为了避免精度误差，我们将答案模10^9 + 7输出。 Input​ 第一行三个数n，T。意义如题面中所述。接下来一行n个数，第i个数ai表示第i个点初始时刻有ai只松鼠。接下来n行，每行n个数，第i行第j个数如果为1表示点i与点j间有无向边相连，为0则表示没有。 Output​ 输出一行一个数，表示T时刻在同一棵树上的松鼠对数的期望在模10^9 +7意义下的答案。 Solution这道题考察了许多知识点，考察综合能力。 首先，题目总体是考察概率期望，但切忌陷入思路死角，去求每棵树上的最终期望松鼠对数。实际上，我们对于每只松鼠，去求它到某点的概率p,那么每两只松鼠在某点的期望便是p1p21（还有很多可转化为概率来做的期望题）由于要除法取模，要预先递推求出逆元，复习一下公式：inv[1]=1;inv[i]=(mod-mod/i)*inv[mod%i]%mod. 那么对于松鼠到某点的概率求取，我们先O(N^2)求出最开始互相连点之间的概率，然后每一时刻，枚举中间点，进行概率传递，由于t比较大，可以用矩阵快速幂思想来将其优化到log2n级别。 最后，由于我们计算期望是O（n^3）的，无法过n&lt;=1000的点，发现如下式子： 设p(i,j)为i到j点的概率。假设计算终点在1，则ans=p(1,1)p(2,1)+p(1,1)p(3,1)…..+p(1,1)p(n,1)+p(2,1)p(3,1)+p(2,1)p(4,1)+…….发现可以转化为p(1,1)(p(2,1)+p(3,1)+p(4,1)+….+p(n,1))+p(2,1)(p(3,1)+p(4,1)+…..+p(n,1)).由此发现是可以前缀和优化的，由此只用枚举一点和终点，从而变成O(N^2).当然可以每个统计一次，然后最后除以2.貌似更方便哈….. The Code#include&lt;bits/stdc++.h&gt; #define maxn 1005 using namespace std; typedef long long ll; const ll mod=1e9+7; struct matrix{ ll a[maxn][maxn]; }nd,ans; int n,t,e[maxn][maxn]; matrix operator *(matrix &amp;x,matrix &amp;y){ matrix c; memset(c.a,0,sizeof(c.a)); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=n;k++){ c.a[i][j]=(c.a[i][j]+(x.a[i][k]*y.a[k][j])%mod)%mod; } return c; } void pow(int t){ for(int i=1;i&lt;=n;i++) ans.a[i][i]=1; while(t){ if(t&amp;1) ans=ans*nd;//最后为1 nd=nd*nd; t/=2; } } ll p[maxn][maxn],inv[maxn],v[maxn]; void init(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;t); for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;v[i]); inv[1]=1; for(int i=2;i&lt;=1000;i++) inv[i]=(mod-mod/i)*inv[mod%i]%mod; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf(&quot;%d&quot;,&amp;e[i][j]); memset(nd.a,0,sizeof(nd.a)); for(int i=1;i&lt;=n;i++){ int res=0; for(int j=1;j&lt;=n;j++) res+=e[i][j]; for(int j=1;j&lt;=n;j++) nd.a[i][j]=inv[res]*e[i][j]; } if(t&gt;1){ pow(t); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) p[i][j]=ans.a[i][j]; } else{ for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) p[i][j]=nd.a[i][j]; } ll calc=0; for(int i=1;i&lt;=n;i++){ ll t1=0,t2=0; for(int j=1;j&lt;=n;j++){ ll tt=(p[j][i]*v[j])%mod; t1=(t1+tt)%mod; t2=(t2+tt*p[j][i])%mod; } calc=(calc+(t1*t1%mod-t2+mod)%mod*inv[2]%mod)%mod; } printf(&quot;%lld&quot;,calc); } int main(){ init(); return 0; }]]></content>
      <categories>
        <category>noip模拟赛</category>
      </categories>
      <tags>
        <tag>概率期望</tag>
        <tag>前缀和优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[祎隋]]></title>
    <url>%2F2018%2F10%2F14%2Fkk%2F</url>
    <content type="text"><![CDATA[祎隋如你，春风十里不及你《祎隋》 无需仰首，我已知晓 那阳光濡缕，和风轻挠 不用回头，我已知晓 那鲜艳裙摆 ，恬然一笑 …… 因你自嘲，为你歌声倾倒 附上小鞠美图一张]]></content>
      <categories>
        <category>杂诗</category>
      </categories>
      <tags>
        <tag>杂诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[about]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[这里是一位来自重庆一中的大龄蒟蒻选手，苟活ing，持续更新 qq: 1494476174 tele: 18883231287]]></content>
  </entry>
  <entry>
    <title><![CDATA[文章分类]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[gallery]]></title>
    <url>%2Fgallery%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[links]]></title>
    <url>%2Flinks%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[timeline]]></title>
    <url>%2Ftimeline%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
