<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[减肥计划]]></title>
    <url>%2F2018%2F10%2F15%2F3%2F</url>
    <content type="text"><![CDATA[Solution哇，这道题还是太急了，探究出个性质就直接溜了。首先当$\sum{a_i}$一定时，$\sum{b_i}$越大肯定越优，那么可以dp[i]表示$\sum{a_i}$为i时最大的$\sum{b_i}$之值。由于a的和为$nmax({a_i})$，所以总的复杂度会是$n^2max({a_i})$。显然会超时。所以我们来探求性质，发现当答案为$\frac{\sum{a_i}}{\sum{b_i}}$，若此时有$\frac{a_i}{b_i}$大于它时，那么加入一定会增大，反之加入小于的会减小，所以我们对于一个答案，不断删去小于它的$\frac{a_i}{b_i}$，直到$\sum{a_i}$&lt;m后停下来，那么过程中不会减小，此时再加入大于的即可，所以最多只用dp到$max({a_i})+m$，因此时间复杂度也降为$n*(m+max({a_i}))​$ ，即可通过此题。 上代码： Code123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;queue&gt;#define maxn 10000005using namespace std;typedef long long ll;int n,m;ll dp[maxn&lt;&lt;1],a[maxn],b[maxn];ll gcd(ll x,ll y)&#123; if(y==0) return x; else return gcd(y,x%y);&#125;ll maxx=0,sum=0;void init()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;a[i],&amp;b[i]),maxx=max(maxx,a[i]),sum+=a[i]; if(sum&lt;m)&#123;printf("-1");return;&#125; for(int i=1;i&lt;=m+maxx;i++) dp[i]=-0x3f3f3f3f; dp[0]=0; for(int i=1;i&lt;=n;i++) for(int j=maxx+m;j&gt;=a[i];j--) dp[j]=max(dp[j],dp[j-a[i]]+b[i]); ll fz=-1,fm=1; for(int i=m;i&lt;=maxx+m;i++) if(fz*i&lt;dp[i]*fm) fz=dp[i],fm=i; ll g=gcd(fz,fm); fz/=g;fm/=g; printf("%d/%d",fz,fm); &#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>正睿</tag>
        <tag>dp</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小瓶颈生成树]]></title>
    <url>%2F2018%2F10%2F15%2F2%2F</url>
    <content type="text"><![CDATA[所谓最小瓶颈生成树….就是使得生成树树上最大边权值最小。这里主要介绍一种期望O（M）（线性）的求法，其实主要就是二分，具体思路如下： 类比找第k大值的方法，首先随机一个边权w。 然后将不超过这个边权的边加入，遍历这张图。 如果图连通，那么瓶颈不超过w，于是只需考虑边权不超过w的边。 否则将这些连通点缩起来，考虑边权大于w的边。 每次将问题的规模缩小至一半。 期望时间复杂度O(m)。 相关例题有两道：A.Hangar Hurdles (CERC 16) 有一个n*n的网格图，上面有些格子可行，有些格子是障碍。 有Q个询问，想把一个正方形箱子从(r1,c1)推到(r2,c2)，问箱子最大的大小。（起点终点是正方形箱子的中点） N&lt;=1000 Q&lt;=300000 B.洪蛤吨有一个宽度为L的管道，我们可以视其为一条y=L的直线与X轴所夹的部分。 （所以这根管道的长度可以视为正无穷） 这个管道中有个N个障碍点，第i个障碍点的坐标为(Xi,Yi)。 已知有一个球体，能在不碰到障碍点的前提下，从管道的最左端走到最右端。（即从管道内横坐标负无穷的地方走到横坐标正无穷的地方）。 求这个球体的直径最大是多少。为了避免精度误差，请输出答案保留三位小数的结果。 两题有异曲同工之妙a…（/滑稽，思路差不多…）都可以用最小瓶颈树实现复杂度最小下面上一下t2的代码：（没有用最小瓶颈树优化，逃） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;set&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;queue&gt;#define maxn 505using namespace std;struct eage&#123; int u,v; double dist;&#125;e[maxn*maxn/2+maxn*2];bool cmp(eage a,eage b)&#123; return a.dist&lt;b.dist;&#125;double dis(int x1,int y1,int x2,int y2)&#123; return sqrt(1.0*(x1-x2)*(x1-x2)+1.0*(y1-y2)*(y1-y2)); &#125;int fa[maxn];int find(int x)&#123; if(fa[x]==x) return x; int root=find(fa[x]); fa[x]=root; return root;&#125;void link(int x,int y)&#123; int fx=find(x),fy=find(y); if(fx!=fy)&#123; fa[fx]=fy; &#125; &#125;bool check(int x,int y)&#123; int fx=find(x),fy=find(y); if(fx!=fy) return false; return true;&#125;int l,n;struct node&#123; int x,y;&#125;nd[maxn];void init()&#123; int pos=0; scanf("%d%d",&amp;n,&amp;l); for(int i=1;i&lt;=n+2;i++) fa[i]=i;//n+1是上，n+2是下 for(int i=1;i&lt;=n;i++)&#123; scanf("%d%d",&amp;nd[i].x,&amp;nd[i].y); &#125; for(int i=1;i&lt;=n;i++)&#123; e[++pos]=(eage)&#123;i,n+1,l-nd[i].y&#125;; e[++pos]=(eage)&#123;i,n+2,nd[i].y&#125;; for(int j=i+1;j&lt;=n;j++)&#123; e[++pos]=(eage)&#123;i,j,dis(nd[i].x,nd[i].y,nd[j].x,nd[j].y)&#125;; &#125; &#125; int cnt=0; sort(e+1,e+pos+1,cmp); for(int i=1;i&lt;=pos;i++)&#123; int u=e[i].u,v=e[i].v; if(check(u,v)) continue; link(u,v); cnt++; if(find(n+1)==find(n+2))&#123;//只要上底和下底连接了就行 这样才能保证极大值可以通过，如果后面更大，那这里是过不了的 printf("%.3f",e[i].dist); break; &#125; &#125;&#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>正睿</category>
      </categories>
      <tags>
        <tag>最小瓶颈生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UpdateAfterEvent]]></title>
    <url>%2F2018%2F10%2F15%2F1%2F</url>
    <content type="text"><![CDATA[Description​ 小松鼠打了10个小时的游戏，一脸满足。却发现周围再次围满了游客，逃！ 她发现整个西湖内的松鼠都以相同的速度在树之间跳跃。每跳跃一次花费一个单位的时间。我们可以把西湖抽象为一张n个点的无向图，初始时每个点上都有若干只松鼠，它们每单位时间都可以沿着一条无向边进行跳跃。 对于一只当前在点i的松鼠，它在接下来的一个单位时间内等概率向相邻的点跳跃。更具体地讲，我们称与点i通过一条无向边直接相连的点为与i相邻的点，假设这样的点有p个，那么对于每一个与i相邻的点，在下一时刻都有1/p的概率跳到它。 超萌小松鼠已知初始时刻（0时刻）每棵树上的松鼠分布情况，她想知道在T时刻，在同一棵树上的松鼠对数的期望。关于“松鼠对数”的解释：假设有4只松鼠在同一棵树上，那么我们称有6对在同一棵树上的松鼠。为了避免精度误差，我们将答案模10^9 + 7输出。 Input​ 第一行三个数n，T。意义如题面中所述。接下来一行n个数，第i个数ai表示第i个点初始时刻有ai只松鼠。接下来n行，每行n个数，第i行第j个数如果为1表示点i与点j间有无向边相连，为0则表示没有。 Output​ 输出一行一个数，表示T时刻在同一棵树上的松鼠对数的期望在模10^9 +7意义下的答案。 Solution这道题考察了许多知识点，考察综合能力。 首先，题目总体是考察概率期望，但切忌陷入思路死角，去求每棵树上的最终期望松鼠对数。实际上，我们对于每只松鼠，去求它到某点的概率p,那么每两只松鼠在某点的期望便是p1p21（还有很多可转化为概率来做的期望题）由于要除法取模，要预先递推求出逆元，复习一下公式：inv[1]=1;inv[i]=(mod-mod/i)*inv[mod%i]%mod. 那么对于松鼠到某点的概率求取，我们先O(N^2)求出最开始互相连点之间的概率，然后每一时刻，枚举中间点，进行概率传递，由于t比较大，可以用矩阵快速幂思想来将其优化到log2n级别。 最后，由于我们计算期望是O（n^3）的，无法过n&lt;=1000的点，发现如下式子： 设p(i,j)为i到j点的概率。假设计算终点在1，则ans=p(1,1)p(2,1)+p(1,1)p(3,1)…..+p(1,1)p(n,1)+p(2,1)p(3,1)+p(2,1)p(4,1)+…….发现可以转化为p(1,1)(p(2,1)+p(3,1)+p(4,1)+….+p(n,1))+p(2,1)(p(3,1)+p(4,1)+…..+p(n,1)).由此发现是可以前缀和优化的，由此只用枚举一点和终点，从而变成O(N^2).当然可以每个统计一次，然后最后除以2.貌似更方便哈….. The Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;#define maxn 1005using namespace std;typedef long long ll;const ll mod=1e9+7;struct matrix&#123; ll a[maxn][maxn];&#125;nd,ans;int n,t,e[maxn][maxn];matrix operator *(matrix &amp;x,matrix &amp;y)&#123; matrix c; memset(c.a,0,sizeof(c.a)); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=n;k++)&#123; c.a[i][j]=(c.a[i][j]+(x.a[i][k]*y.a[k][j])%mod)%mod; &#125; return c;&#125;void pow(int t)&#123; for(int i=1;i&lt;=n;i++) ans.a[i][i]=1; while(t)&#123; if(t&amp;1) ans=ans*nd;//最后为1 nd=nd*nd; t/=2; &#125;&#125;ll p[maxn][maxn],inv[maxn],v[maxn];void init()&#123; scanf("%d%d",&amp;n,&amp;t); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;v[i]); inv[1]=1; for(int i=2;i&lt;=1000;i++) inv[i]=(mod-mod/i)*inv[mod%i]%mod; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf("%d",&amp;e[i][j]); memset(nd.a,0,sizeof(nd.a)); for(int i=1;i&lt;=n;i++)&#123; int res=0; for(int j=1;j&lt;=n;j++) res+=e[i][j]; for(int j=1;j&lt;=n;j++) nd.a[i][j]=inv[res]*e[i][j]; &#125; if(t&gt;1)&#123; pow(t); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) p[i][j]=ans.a[i][j]; &#125; else&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) p[i][j]=nd.a[i][j]; &#125; ll calc=0; for(int i=1;i&lt;=n;i++)&#123; ll t1=0,t2=0; for(int j=1;j&lt;=n;j++)&#123; ll tt=(p[j][i]*v[j])%mod; t1=(t1+tt)%mod; t2=(t2+tt*p[j][i])%mod; &#125; calc=(calc+(t1*t1%mod-t2+mod)%mod*inv[2]%mod)%mod; &#125; printf("%lld",calc);&#125;int main()&#123; init(); return 0;&#125;]]></content>
      <categories>
        <category>noip模拟赛1</category>
      </categories>
      <tags>
        <tag>概率期望</tag>
        <tag>前缀和优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[祎隋]]></title>
    <url>%2F2018%2F10%2F14%2Fkk%2F</url>
    <content type="text"><![CDATA[祎隋如你，春风十里不及你《祎隋》 无需仰首，我已知晓 那阳光濡缕，和风轻挠 不用回头，我已知晓 那鲜艳裙摆 ，恬然一笑 …… 因你自嘲，为你歌声倾倒 附上小鞠美图一张]]></content>
  </entry>
  <entry>
    <title><![CDATA[文章分类]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
