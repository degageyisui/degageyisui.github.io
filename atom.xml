<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>祎隋</title>
  
  <subtitle>祎隋如你，春风十里不及你</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="www.degage.xyz/"/>
  <updated>2019-01-13T07:51:07.909Z</updated>
  <id>www.degage.xyz/</id>
  
  <author>
    <name>degage</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>马拉车算法</title>
    <link href="www.degage.xyz/2019/01/13/%E9%A9%AC%E6%8B%89%E8%BD%A6/"/>
    <id>www.degage.xyz/2019/01/13/马拉车/</id>
    <published>2019-01-13T07:49:38.000Z</published>
    <updated>2019-01-13T07:51:07.909Z</updated>
    
    <content type="html"><![CDATA[<p>马拉车算法</p><pre><code class="lang-c++">int init(char *str){    int n=strlen(str);    for(int i=1,j=0;i&lt;=2*n;j++,i+=2)    {        s[i]=&#39;#&#39;;        s[i+1]=str[j];    }    s[0]=&#39;$&#39;;    s[2*n+1]=&#39;#&#39;;    s[2*n+2]=&#39;@&#39;;    s[2*n+3]=&#39;\n&#39;;    return 2*n+1;}void manacher(int n){    int mx=0,p=0;    for(int i=1;i&lt;=n;i++)    {        if(mx&gt;i)len[i]=min(mx-i,len[2*p-i]);        else len[i]=1;        while(s[i-len[i]]==s[i+len[i]])len[i]++;        if(len[i]+i&gt;mx)mx=len[i]+i,p=i;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;马拉车算法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-c++&quot;&gt;int init(char *str)
{
    int n=strlen(str);
    for(int i=1,j=0;i&amp;lt;=2*n;j++,i+=2)
    {
        
      
    
    </summary>
    
      <category term="省选" scheme="www.degage.xyz/categories/%E7%9C%81%E9%80%89/"/>
    
    
      <category term="马拉车算法" scheme="www.degage.xyz/tags/%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="www.degage.xyz/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>莫比乌斯反演未整理</title>
    <link href="www.degage.xyz/2019/01/02/58/"/>
    <id>www.degage.xyz/2019/01/02/58/</id>
    <published>2019-01-02T15:07:13.000Z</published>
    <updated>2019-01-13T06:38:58.050Z</updated>
    
    <content type="html"><![CDATA[<p>$\sigma(p^k)=k+1$<br>$phi(p^k)=p^{k-1}\times(p-1)$</p><p>$(phi\star1)(p^k)=p^k$</p><p>证明：</p><p>$1(i)=1$</p><p>$(phi\star1)(n)=\sum_{i|n}(phi(i)\times 1)$<br>$(phi\star1)(p^k)=(phi)(1)+(phi)(p^1)+….+(phi)(p^k)$<br>套公式$phi(p^k)=p^{k-1}\times(p-1)$<br>化为$(p-1)\times(p^0+p^1+…+p^{k-1})=p^k$</p><p>由于$(phi\star1)(p^k)$是积性函数，所以$phi\star1=id$</p><p>莫比乌斯反演：</p><p>定义<strong>1</strong>的逆是$\mu​$（莫比乌斯函数）</p><p>如果$g=f\star1$，就有$f=f\ \star 1\ \star\mu=g\ \star\mu$</p><p>所以$g(n)=\sum_{d|n}f(d)$则$f(n)=\sum_{d|n}g(d)\times\mu(n/d)$ （莫比乌斯反演定理）</p><p>另一个方向：$g(n)=\sum_{n|d}f(d)$ 则$f(n)=\sum_{n|d}g(d)\times \mu(d/n)$  其中d的取值范围为f的定义域</p><script type="math/tex; mode=display">\mu(n)=(-1)^{t}</script><p>当 <script type="math/tex">n=p_1\times p_2\times ...\times p_t且p_i各不相同</script></p><script type="math/tex; mode=display">else  \mu(i)=0</script><p>结论： $phi=\mu \star id$  </p><p>莫比乌斯函数常用的两个性质：</p><ul><li>对于任意正整数$n$，$\sum_{d|n}\mu(d)=[n=1]$。（$[n=1]$表示只有当$n=1$成立时，返回值为1；否则，值为0；(这个就是用μ是容斥系数的性质可以证明)<strong>(PS:这一条性质是莫比乌斯反演中最常用的)</strong></li><li>对于任意正整数n，$\sum_{d|n}\frac{\mu(d)}{d}=\frac{\phi(n)}{n}$。（这个性质很奇妙，它把欧拉函数和莫比乌斯函数结合起来）</li></ul><p>整除分块：</p><ul><li>对于每一个$\lfloor\frac{n}{i}\rfloor$我们可以通过打表<del>(或理性的证明)</del>可以发现：有许多$\lfloor\frac{n}{i}\rfloor$的值是一样的，而且它们呈一个块状分布；再通过打表之类的各种方法,我们惊喜的发现对于每一个值相同的块，它的最后一个数就是$n/(n/i)$。得出这个结论后，我们就可以做的$O(\sqrt{n})$处理了。<br>附一个整除分块的代码吧：</li></ul><pre><code class="lang-c++">for(int l=1,r;l&lt;=n;l=r+1){    r=n/(n/l);    ans+=(r-l+1)\star(n/l);}</code></pre><pre><code class="lang-c++">void get_mu(int n){    mu[1]=1;    for(int i=2;i&lt;=n;i++)    {        if(!vis[i]){prim[++cnt]=i;mu[i]=-1;}        for(int j=1;j&lt;=cnt&amp;&amp;prim[j]\stari&lt;=n;j++)        {            vis[prim[j]\stari]=1;            if(i%prim[j]==0)break;            else mu[i\starprim[j]]=-mu[i];        }    } }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;$\sigma(p^k)=k+1$&lt;br&gt;$phi(p^k)=p^{k-1}\times(p-1)$&lt;/p&gt;
&lt;p&gt;$(phi\star1)(p^k)=p^k$&lt;/p&gt;
&lt;p&gt;证明：&lt;/p&gt;
&lt;p&gt;$1(i)=1$&lt;/p&gt;
&lt;p&gt;$(phi\star1)(n)=\sum_{
      
    
    </summary>
    
      <category term="省选" scheme="www.degage.xyz/categories/%E7%9C%81%E9%80%89/"/>
    
    
      <category term="数学" scheme="www.degage.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>祎隋</title>
    <link href="www.degage.xyz/2019/01/02/57/"/>
    <id>www.degage.xyz/2019/01/02/57/</id>
    <published>2019-01-02T15:07:03.000Z</published>
    <updated>2019-01-13T08:16:18.139Z</updated>
    
    <content type="html"><![CDATA[<h2 id="我愿…"><a href="#我愿…" class="headerlink" title="我愿…"></a>我愿…</h2><p><font face="等线">《祎隋》</font>&lt;/br&gt;  </p><p><font face="等线">我愿意是歌声不成形体</font>&lt;/br&gt;    </p><p><font face="等线">又发自于你</font> &lt;/br&gt;   </p><p><font face="等线">轻托你的灵动美丽</font>&lt;/br&gt;    </p><p><font face="等线">我愿意是烟火转瞬即逝</font>&lt;/br&gt;    </p><p><font face="等线">又引你一视</font>&lt;/br&gt;    </p><p><font face="等线">映亮你的天真欣喜</font>&lt;/br&gt;    </p><p><font face="等线">我愿意是微风不被注意</font>&lt;/br&gt;    </p><p><font face="等线">又轻拂着你</font>&lt;/br&gt;    </p><p><font face="等线">飘扬你的醉人芳香</font>&lt;/br&gt;    </p><p><font face="等线">我愿意是皎月独凌寒处</font>&lt;/br&gt;    </p><p><font face="等线">又照你一世</font>&lt;/br&gt;   </p><p><font face="等线">平稳你的夜夜美梦</font>&lt;/br&gt;   </p><p><font face="等线">我愿意是时光静默流淌</font> &lt;/br&gt;  </p><p><font face="等线">又伴你一生</font>&lt;/br&gt;    </p><p><font face="等线">承载你的所有过往</font>&lt;/br&gt;    </p><p><img src="https://i.loli.net/2019/01/02/5c2cd3d567883.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;我愿…&quot;&gt;&lt;a href=&quot;#我愿…&quot; class=&quot;headerlink&quot; title=&quot;我愿…&quot;&gt;&lt;/a&gt;我愿…&lt;/h2&gt;&lt;p&gt;&lt;font face=&quot;等线&quot;&gt;《祎隋》&lt;/font&gt;&amp;lt;/br&amp;gt;  &lt;/p&gt;
&lt;p&gt;&lt;font face=&quot;等线&quot;&gt;我愿
      
    
    </summary>
    
      <category term="杂诗" scheme="www.degage.xyz/categories/%E6%9D%82%E8%AF%97/"/>
    
    
      <category term="杂诗" scheme="www.degage.xyz/tags/%E6%9D%82%E8%AF%97/"/>
    
  </entry>
  
  <entry>
    <title>网络流</title>
    <link href="www.degage.xyz/2018/12/16/56/"/>
    <id>www.degage.xyz/2018/12/16/56/</id>
    <published>2018-12-16T15:18:54.000Z</published>
    <updated>2018-12-16T15:30:14.132Z</updated>
    
    <content type="html"><![CDATA[<p>首先主要是关于退流的理解，仔细理解这张图：<br><img src="https://i.loli.net/2018/12/16/5c166eaf19395.png" alt=""></p><p>然后上模板：<br>最大流<br>(1)EK:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxn 205#define maxm 2005using namespace std;int n,m,x,y,z;struct eage{    int from,to,next,cap,flow;}e[maxm&lt;&lt;1];int first[maxn],np=0;void add(int u,int v,int c){    e[++np]=(eage){u,v,first[u],c,0};    first[u]=np;    e[++np]=(eage){v,u,first[v],0,0};    first[v]=np;} int a[maxn],fa[maxn];int other(int i){    return i&amp;1?i+1:i-1;}int bfs(int s,int t){    queue&lt;int&gt;q;    memset(a,0,sizeof(a));    a[s]=0x3f3f3f3f;    fa[s]=0;    q.push(s);    while(!q.empty()){        int i=q.front();q.pop();        for(int p=first[i];p;p=e[p].next){            int j=e[p].to;            if(!a[j]&amp;&amp;e[p].cap&gt;e[p].flow){                a[j]=min(a[i],e[p].cap-e[p].flow);                fa[j]=p;                q.push(j);                if(j==t) return a[j];            }        }    }    return 0;//如果没有找到任意一条 }int ek(){    int maxflow=0;    while(1){        int del=bfs(1,n);        if(del==0) break;        maxflow+=del;        int f=fa[n];        while(f){            e[f].flow+=del;            e[other(f)].flow-=del;            f=fa[e[f].from];        }    }    return maxflow;}void init(){     scanf(&quot;%d%d&quot;,&amp;m,&amp;n);     for(int i=1;i&lt;=m;i++){         scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);         add(x,y,z);     }         printf(&quot;%d&quot;,ek());}int main(){    init();    return 0;}</code></pre><p>(2)Dinic</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxn 205#define maxm 2005#define inf 0x3f3f3f3fusing namespace std;struct eage{    int from,to,next,cap,flow;}e[maxm&lt;&lt;1];int first[maxn],np=0;void add(int u,int v,int c){    e[++np]=(eage){u,v,first[u],c,0};    first[u]=np;    e[++np]=(eage){v,u,first[v],0,0};    first[v]=np;}int n,m,x,y,z,s,t;bool vis[maxn];int other(int i){    return i&amp;1?i+1:i-1;}int dfs(int i,int mn){    vis[i]=1;    if(i==t) return mn;    for(int p=first[i];p;p=e[p].next){        int j=e[p].to;        int dis=e[p].cap-e[p].flow;        if(vis[j]||dis==0) continue;        int del=dfs(j,min(mn,dis));        if(del==0) continue;        e[p].flow+=del;        e[other(p)].flow-=del;        return del;     }    return 0;}int ek(){    int maxflow=0;    while(1){        memset(vis,0,sizeof(vis));        int del=dfs(s,inf);        if(del==0) break;        maxflow+=del;    }        return maxflow;}void init(){    scanf(&quot;%d%d&quot;,&amp;m,&amp;n);    s=1,t=n;    for(int i=1;i&lt;=m;i++){        scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);        add(x,y,z);    }    printf(&quot;%d&quot;,ek());}int main(){    init();    return 0;}</code></pre><p>费用流:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxn 305#define maxm 3005#define inf 0x3f3f3f3fusing namespace std;struct eage{    int from,to,next,cap,flow,w;}e[maxm&lt;&lt;1];int first[maxn],np=0;void add(int u,int v,int c,int w){    e[++np]=(eage){u,v,first[u],c,0,w};    first[u]=np;    e[++np]=(eage){v,u,first[v],0,0,-w};    first[v]=np;}int other(int i){    return i&amp;1?i+1:i-1;}int n,m,x,y,z,w,dist[maxn],a[maxn],fa[maxn];bool vis[maxn];int spfa(){    queue&lt;int&gt;q;    memset(vis,0,sizeof(vis));    memset(a,0,sizeof(a));    a[1]=inf;    fa[1]=0;q.push(1);    memset(dist,0x3f,sizeof(dist));    dist[1]=0;    while(!q.empty()){        int i=q.front();q.pop();        vis[i]=0;        for(int p=first[i];p;p=e[p].next){            int j=e[p].to;            if(e[p].cap&gt;e[p].flow)            if(dist[j]&gt;dist[i]+e[p].w){                dist[j]=dist[i]+e[p].w;                a[j]=min(a[i],e[p].cap-e[p].flow);                fa[j]=p;                if(!vis[j]) q.push(j),vis[j]=1;            }        }    }    return a[n];}void ek(){    int maxflow=0;    int cost=0;    while(spfa()){        maxflow+=a[n];        cost+=dist[n]*a[n];        int f=fa[n];        while(f){            e[f].flow+=a[n];            e[other(f)].flow-=a[n];            f=fa[e[f].from];        }    }    printf(&quot;%d %d&quot;,maxflow,cost);}void init(){    scanf(&quot;%d%d&quot;,&amp;m,&amp;n);    for(int i=1;i&lt;=m;i++){        scanf(&quot;%d%d%d%d&quot;,&amp;x,&amp;y,&amp;z,&amp;w);        add(x,y,z,w);    }    ek();}int main(){    init();    return 0;}</code></pre><p>二分图:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxn 405#define maxm 40005#define inf 0x3f3f3f3fusing namespace std;struct eage{    int from,to,next,cap,flow;}e[maxm&lt;&lt;1];int first[maxn],np=0;void add(int u,int v,int c){    e[++np]=(eage){u,v,first[u],c,0};    first[u]=np;    e[++np]=(eage){v,u,first[v],0,0};    first[v]=np;}int other(int i){    return i&amp;1?i+1:i-1;}int n,m,x,y,s,t;bool vis[maxn];int dfs(int i,int mn){    vis[i]=1;    if(i==t) return mn;    for(int p=first[i];p;p=e[p].next){        int j=e[p].to,dis=e[p].cap-e[p].flow;        if(vis[j]||dis==0) continue;        int del=dfs(j,min(mn,dis));        if(del==0) continue;        e[p].flow+=del;        e[other(p)].flow-=del;        return del;    }    return 0;}void ek(){    int maxflow=0;    while(1){        memset(vis,0,sizeof(vis));        int del=dfs(s,inf);        if(del==0) break;        maxflow+=del;     }    printf(&quot;%d&quot;,maxflow);}void init(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    s=401,t=402;    for(int i=1;i&lt;=n;i++){        scanf(&quot;%d&quot;,&amp;y);        for(int j=1;j&lt;=y;j++){            scanf(&quot;%d&quot;,&amp;x);            add(i,x+n,1);        }        add(s,i,1);    }    for(int i=1;i&lt;=m;i++) add(i+n,t,1);//最多只出去一个，保证两边不连到一个点上     ek();}int main(){    init();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先主要是关于退流的理解，仔细理解这张图：&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2018/12/16/5c166eaf19395.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后上模板：&lt;br&gt;最大流&lt;br&gt;(1)EK:&lt;/p&gt;
&lt;pre&gt;&lt;code
      
    
    </summary>
    
      <category term="省选" scheme="www.degage.xyz/categories/%E7%9C%81%E9%80%89/"/>
    
    
      <category term="网络流" scheme="www.degage.xyz/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>划分物品</title>
    <link href="www.degage.xyz/2018/11/08/55/"/>
    <id>www.degage.xyz/2018/11/08/55/</id>
    <published>2018-11-08T08:33:39.000Z</published>
    <updated>2018-12-16T14:59:43.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>你有 n 个物品，第 i 个物品的重量是$w_i$。</p><p>你需要把这些物品划分成若干组，满足每一组的重量和都是质数。</p><p>两个方案是不同的当且仅当存在两个物品 i 和 j，在第一个方案里他们处在同一组，第二个方案里他们不处在同一组。（对998244353取模）</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>$n&lt;=16,w_i&lt;=100$</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>10<br>2 3 4 5 6 7 8 9 10 11</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>1177</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>一道经典的状压dp题，我们可以用$sum_i$来表示状态为i的集合所表示的重量和(类似思路也可以搞其他的)设$dp_i$表示状态为i的集合所能容纳的方案数，那么$dp_i=\sum_{(j属于i且j为素数)}dp_{i-j}$。显然这样是不正确的，因为有重复的，所以我们便固定一个x属于i，然后可以正确dp。</p><p>上代码:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxv 1605using namespace std;typedef long long ll;const ll mod=998244353;ll dp[1&lt;&lt;18];int sum[1&lt;&lt;18];int n,w[20];bool vis[maxv];int prime[maxv&gt;&gt;1],top=0;void ready(){    vis[0]=vis[1]=1;    for(int i=1;i&lt;=maxv-5;i++){        if(!vis[i]) prime[++top]=i;        for(int j=1;j&lt;=top&amp;&amp;prime[j]*i&lt;=maxv-5;j++){            vis[prime[j]*i]=1;            if(i%prime[j]==0) break;        }    }}void init(){    scanf(&quot;%d&quot;,&amp;n);    int all=(1&lt;&lt;n)-1;    for(int i=1;i&lt;=n;i++){    scanf(&quot;%d&quot;,&amp;w[i]);sum[1&lt;&lt;i-1]=w[i];        }    dp[0]=1;    for(int i=1;i&lt;=all;i++)    for(int j=1;j&lt;=n;j++){        if((i|(1&lt;&lt;j-1))!=i) continue;        if((1&lt;&lt;j-1)==i) continue;        sum[i]=sum[i-(1&lt;&lt;j-1)]+w[j];//可用如此方式来记录每个状态代表的值     }    for(int i=1;i&lt;=all;i++){        int x=i&amp;(-i);//固定一个 注意i&amp;-i的值是1&lt;&lt;后的         for(int j=i;j;j=i&amp;(j-1)){            if((x|j)!=j) continue;            if(vis[sum[j]]) continue;            dp[i]=(dp[i]+dp[i-j])%mod;        }     }    printf(&quot;%lld&quot;,dp[all]);}int main(){    ready();    init();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;你有 n 个物品，第 i 个物品的重量是$w_i$。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="正睿" scheme="www.degage.xyz/categories/%E6%AD%A3%E7%9D%BF/"/>
    
    
      <category term="dp" scheme="www.degage.xyz/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>计数</title>
    <link href="www.degage.xyz/2018/11/07/54/"/>
    <id>www.degage.xyz/2018/11/07/54/</id>
    <published>2018-11-07T13:04:13.000Z</published>
    <updated>2018-11-07T15:29:13.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>既然是萌萌哒 visit_world 的比赛，那必然会有一道计数题啦！<br>考虑一个N个节点的二叉树，它的节点被标上了$1-N$的编号. 并且，编号为i的节点在二叉树的前序遍历中恰好是第i个出现.<br>我们定义$A_i$表示编号为i的点在二叉树的中序遍历中出现的位置.<br>现在，给出m个限制条件，第i个限制条件给出了$u_i,v_i$,表示$A_{u_i}&lt;A_{v_i}$，也即中序遍历中$u_i$在$v_i$之前出现.<br>你需要计算有多少种不同的带标号二叉树满足上述全部限制条件，答案对$1e9+7$取模.</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>$T&lt;=5,N&lt;=400,M&lt;=10^3$</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>3 5<br>0<br>3 2<br>1 2<br>2 3<br>3 3<br>1 2<br>2 3<br>3 1</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>42<br>1<br>0</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先M=0可以看出是个卡特兰数。<br>然后我们知道先序遍历，根据其特性来枚举出合法的中序遍历，每次找到一个根，枚举它左边有多少个，右边有多少个，然后判断是否合法，合法的话方案数乘起来累加。<br>见图：<br><img src="https://i.loli.net/2018/11/07/5be3017335edf.png" alt=""><br>首先枚举后有三个大小关系：根的中序遍历大于任意左子树的，任意右子树的大于根的，任意右子树的大于左子树的。<br>然后发现check是$n^2$的，而dp又是$n^3$的，这样就$n^5$了，<font color="red">这里有个很nice的思路</font>，用二维前缀和优化，如果要求i的中序遍历小于j的，那么$a[i][j]=1$，然后sum求一波二维前缀和，对于$sum[i][j]$其含义便是1-i中小于1-j中的个数和，那么我们询问$[l1,r1]小于[l2,r2]$就为$sum[r1,r2]-sum[l1-1,r2]-sum[r1,l2-1]+sum[l1-1,l2-1]$然后就优化成$O(1)$的check了，整体复杂度就被优化至了$O(n^3)$，真的TQL%%%</p><p>上代码：</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxn 405using namespace std;typedef long long ll;const ll mod=1e9+7;int a[maxn][maxn],n,t,m,x,y,sum[maxn][maxn];ll dp[maxn][maxn];int calc(int l1,int r1,int l2,int r2){//如果返回值说l1~r1有小于l2~r2的     return sum[r1][r2]-sum[l1-1][r2]-sum[r1][l2-1]+sum[l1-1][l2-1];}bool check(int now,int l1,int r1,int l2,int r2){    if(calc(l2,r2,l1,r1))return false;    if(calc(now,now,l1,r1))return false;    if(calc(l2,r2,now,now))return false;    return true;}void init(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    memset(a,0,sizeof(a));    memset(sum,0,sizeof(sum));    memset(dp,0,sizeof(dp));    for(int i=1;i&lt;=m;i++){        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);        a[x][y]=1;    }     for(int i=1;i&lt;=n;i++)    for(int j=1;j&lt;=n;j++){        sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j];    }    for(int i=1;i&lt;=n;i++) dp[i][i]=1;    for(int len=1;len&lt;=n;len++)    for(int i=1;i&lt;=n;i++){        int j=i+len;        if(j&gt;n) break;        //其实这余下三坨是可以归在一起算的         if(!calc(i,i,i+1,j))dp[i][j]=(dp[i][j]+dp[i+1][j])%mod;//如果没有限制         if(!calc(i+1,j,i,i))dp[i][j]=(dp[i][j]+dp[i+1][j])%mod;        for(int k=i+1;k&lt;j;k++){            if(check(i,i+1,k,k+1,j)) dp[i][j]=(dp[i][j]+dp[i+1][k]*dp[k+1][j])%mod;        }     }         printf(&quot;%lld\n&quot;,dp[1][n]);} int main(){    scanf(&quot;%d&quot;,&amp;t);    for(int i=1;i&lt;=t;i++)    init();        return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;既然是萌萌哒 visit_world 的比赛，那必然会有一道计数题啦
      
    
    </summary>
    
      <category term="正睿" scheme="www.degage.xyz/categories/%E6%AD%A3%E7%9D%BF/"/>
    
    
      <category term="dp" scheme="www.degage.xyz/tags/dp/"/>
    
      <category term="二维前缀和" scheme="www.degage.xyz/tags/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>购物</title>
    <link href="www.degage.xyz/2018/11/07/53/"/>
    <id>www.degage.xyz/2018/11/07/53/</id>
    <published>2018-11-07T13:04:04.000Z</published>
    <updated>2018-11-07T15:28:21.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>visit_world 有一个商店，商店里卖 个商品，第 i 个的价格为$a_i$<br>我们称一个正整数 K 是美妙的，当且仅当我们可以在商店里选购若干个商品，使得价格之和落在区间$ [K, 2K]$ 中。<br>问：有多少个美妙的数。</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>$N&lt;=10^5,a_i&lt;=10^9$<br>时空限制：1s / 512MB</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>3<br>1 2 3</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>6</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>我们将$a_i$从小到大排序，对于前i个，假设它们和为sum,那么k能去到的范围即为$[\frac{sum+1}{2},sum]$，那么对于$\frac{sum-1}{2}$开始是覆盖的不到，我们便会减去一些来使覆盖，所以肯定是逐渐拿小的来，到最后剩下$a_i$，那么设前i-1个的和为sum’，则$[sum’+1,\frac{a_i-1}{2}]$是覆盖不到，所以最终把这些空隙减掉即可。</p><p>上代码：</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxn 100005using namespace std;typedef long long ll;int n;ll a[maxn];void init(){    scanf(&quot;%d&quot;,&amp;n);    for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]);    ll sum=0,del=0;    sort(a+1,a+n+1);    for(int i=1;i&lt;=n;i++){        del+=max((a[i]+1)/2-sum-1,0ll);        sum+=a[i];     }    printf(&quot;%lld&quot;,sum-del);}int main(){    init();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;visit_world 有一个商店，商店里卖 个商品，第 i 个的价
      
    
    </summary>
    
      <category term="正睿" scheme="www.degage.xyz/categories/%E6%AD%A3%E7%9D%BF/"/>
    
    
      <category term="数学" scheme="www.degage.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>physics</title>
    <link href="www.degage.xyz/2018/11/06/52/"/>
    <id>www.degage.xyz/2018/11/06/52/</id>
    <published>2018-11-06T11:34:13.000Z</published>
    <updated>2018-11-06T12:11:22.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>一个n行m列的矩阵，每个为0或1，如果一个边长为K的正方形包含的所有数都为1，那么会形成一个强度为K的电场，有q次询问，每次询问会把1个1变做0，求每次询问的最大电场强度值。</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>$n,m&lt;=2 \ast 10^3 ,1&lt;=q&lt;=10^4$</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>5 5 5<br>+-+++<br>+++++<br>+++++<br>+++++<br>++++-<br>1 5<br>2 2<br>5 3<br>2 3<br>1 1</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>4<br>3<br>3<br>2<br>2</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先会想到用单调栈$n^2$计算最大1正方形，然后发现每改一个只会影响一列的up数组，然后发现如果答案递减不好维护，那么正难则反，我们先将所有的改动加进来，然后倒序考虑所有操作。<br>那么答案是会依次递增的，我们维护一个up和一个down数组来记录每个格子向上和向下最多多少格，对于每次询问，O(N)更新那一列的up和down，再O(n)单调队列扫一遍那一行，类似滑动窗口的来查询长度为k的序列的$min(up_i)和min(down_i)$，看它们加起来是否大于等于k，如果满足继续扩大k，否则标记答案。</p><p>上代码：</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxn 2005 #define maxq 10005#define inf 0x3f3f3f3fusing namespace std;struct node{    int x,y,ans;}nd[maxq];int n,m,a[maxn][maxn],q,st[maxn],top=0,up[maxn][maxn],down[maxn][maxn];char s[maxn];int maxx=0;void calc(){    for(int j=1;j&lt;=m;j++)    for(int i=1;i&lt;=n;i++) up[i][j]=(a[i][j]==0?0:up[i-1][j]+1);     for(int j=1;j&lt;=m;j++)    for(int i=n;i&gt;=1;i--) down[i][j]=(a[i][j]==0?0:down[i+1][j]+1);    st[0]=0;    for(int i=1;i&lt;=n;i++){        top=0;        for(int j=1;j&lt;=m;j++){            while(top&amp;&amp;up[i][j]&lt;=up[i][st[top]]){//单调栈                 maxx=max(maxx,min(up[i][st[top]],j-1-st[top-1]));                top--;            }            st[++top]=j;        }        while(top){            maxx=max(maxx,min(up[i][st[top]],m-st[top-1]));            top--;        }    }}void calcc(int j){    for(int i=1;i&lt;=n;i++) up[i][j]=(a[i][j]==0?0:up[i-1][j]+1);     for(int i=n;i&gt;=1;i--) down[i][j]=(a[i][j]==0?0:down[i+1][j]+1);}int q1[maxn],q2[maxn],front1,front2,rear1,rear2;bool check(int i,int len){    if(len&gt;min(n,m)) return false;    front1=front2=rear1=rear2=0;    for(int j=1;j&lt;=m;j++){        while(front1&lt;rear1&amp;&amp;j-q1[front1]&gt;=len)front1++;        while(front1&lt;rear1&amp;&amp;up[i][q1[rear1-1]]&gt;=up[i][j])rear1--;        q1[rear1++]=j;        while(front2&lt;rear2&amp;&amp;j-q2[front2]&gt;=len)front2++;        while(front2&lt;rear2&amp;&amp;down[i][q2[rear2-1]]&gt;=down[i][j])rear2--;        q2[rear2++]=j;        if(j&gt;=len&amp;&amp;up[i][q1[front1]]+down[i][q2[front2]]-1&gt;=len)return true;    }    return false;}void init(){    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q);    for(int i=1;i&lt;=n;i++){        scanf(&quot;%s&quot;,s+1);        for(int j=1;j&lt;=m;j++) a[i][j]=(s[j]==&#39;+&#39;?1:0);    }    for(int i=1;i&lt;=q;i++){        scanf(&quot;%d%d&quot;,&amp;nd[i].x,&amp;nd[i].y);a[nd[i].x][nd[i].y]=0;    }    calc();    nd[q].ans=maxx;    for(int i=q;i&gt;=2;i--){        a[nd[i].x][nd[i].y]=1;        calcc(nd[i].y);//更新         nd[i-1].ans=nd[i].ans;        while(check(nd[i].x,maxx+1)) maxx++,nd[i-1].ans=maxx;//只改动了这一行     }    for(int i=1;i&lt;=q;i++) printf(&quot;%d\n&quot;,nd[i].ans); }int main(){    init();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;一个n行m列的矩阵，每个为0或1，如果一个边长为K的正方形包含的所有
      
    
    </summary>
    
      <category term="正睿" scheme="www.degage.xyz/categories/%E6%AD%A3%E7%9D%BF/"/>
    
    
      <category term="正难则反" scheme="www.degage.xyz/tags/%E6%AD%A3%E9%9A%BE%E5%88%99%E5%8F%8D/"/>
    
      <category term="单调队列" scheme="www.degage.xyz/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
      <category term="单调栈" scheme="www.degage.xyz/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>Chinese</title>
    <link href="www.degage.xyz/2018/11/06/51/"/>
    <id>www.degage.xyz/2018/11/06/51/</id>
    <published>2018-11-06T11:34:05.000Z</published>
    <updated>2018-11-06T12:35:11.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>一个n行m列的矩阵，每个格子可以填一个$1~k$的整数，矩阵中的一个格子为炼字当且仅当其值比其所在行和列的其它数都大，定义一个矩阵的精彩度为炼字的个数。设$f_i$为精彩度为i的方案数，显然:$\sum_{i=0}^{n \ast m} f_i=k^{n \ast m}$。现在你需要求出$\sum_{i=0}^{n \ast m} f_i \ast i mod (1e9+7)$</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>$n,m&lt;=10^9,k&lt;=10^6$</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>2 2 2</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>8</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先，对$\sum_{i=0}^{n \ast m} f_i \ast i$的理解为所有方案中炼字的个数和，那么考虑对每个格子单独计算贡献，如图：<br><img src="https://i.loli.net/2018/11/06/5be18a56030c0.jpg" alt=""><br>那么每个格子产生的贡献即为</p><script type="math/tex; mode=display">\sum_{i=1}^{k} k^{(n-1) \ast (m-1)} \ast (i-1)^{n-1} \ast (i-1)^{m-1}</script><p>因为相应性质，我们只要再乘上$n \ast m$即为最终答案。</p><p>上代码：</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod=1e9+7;ll n,m,k;ll qkpow(ll t,ll pos){    ll ans=1,base=t;    while(pos){        if(pos&amp;1) ans=ans*base%mod;        base=base*base%mod;        pos&gt;&gt;=1;    }    return ans;}void init(){    scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;k);    ll t1=qkpow(k,(n-1)*(m-1));     ll ans=0;    for(int i=1;i&lt;k;i++) ans=(ans+qkpow(i,n-1)*qkpow(i,m-1)%mod*t1%mod)%mod;    ans=ans*n%mod*m%mod;    printf(&quot;%lld&quot;,ans);}int main(){    init();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;一个n行m列的矩阵，每个格子可以填一个$1~k$的整数，矩阵中的一个
      
    
    </summary>
    
      <category term="正睿" scheme="www.degage.xyz/categories/%E6%AD%A3%E7%9D%BF/"/>
    
    
      <category term="数学" scheme="www.degage.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Certificate</title>
    <link href="www.degage.xyz/2018/11/05/50/"/>
    <id>www.degage.xyz/2018/11/05/50/</id>
    <published>2018-11-05T09:33:25.000Z</published>
    <updated>2018-11-05T09:37:46.473Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>已知有$N(N≤14)$个变量，变量取值0或1。<br>已知$f(0,0,⋯,0)，⋯，f(1,1,⋯,1)$的函数值。<br>对于每种输入$x=(x_0,x_1,⋯,x_n)$，求最少需要知道几个变量的值即可确定函数值。<br>举个例子：假设有两个变量，函数$f(a,b)=a\&amp;b$，那么对于$f(x)=0$，我们只要知道其中一个变量为0即可确定函数值为0，否则我们需要知道两个变量是否都为1，才能确定函数值为1。</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>可以先$2^N$枚举选出的t个关键问题，再$2^N$判断，复杂度为$4^N$，可以勉强卡过。</p><p>上代码：</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxn 16using namespace std;int ans[1&lt;&lt;maxn],check[1&lt;&lt;maxn],n,a[1&lt;&lt;maxn];char s[1&lt;&lt;maxn];int calc(int x){    int cnt=0;    while(x){        cnt++;        x-=x&amp;(-x);    }    return cnt;}void init(){    scanf(&quot;%d&quot;,&amp;n);    int all=1&lt;&lt;n;    scanf(&quot;%s&quot;,s);    memset(ans,0x3f,sizeof(ans));    for(int i=0;s[i];i++) a[i]=(s[i]==&#39;0&#39;?0:1);    for(int i=0;i&lt;all;i++){        memset(check,-1,sizeof(check));        for(int j=0;j&lt;all;j++){            if(check[i&amp;j]==-1) check[i&amp;j]=a[j];            else if(check[i&amp;j]!=a[j]) check[i&amp;j]=2;        }        int len=calc(i);        for(int j=0;j&lt;all;j++) if(check[i&amp;j]==a[j]) ans[j]=min(ans[j],len);    }     for(int i=0;i&lt;all;i++) printf(&quot;%d &quot;,ans[i]);}int main(){    init();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;已知有$N(N≤14)$个变量，变量取值0或1。&lt;br&gt;已知$f(0
      
    
    </summary>
    
      <category term="正睿" scheme="www.degage.xyz/categories/%E6%AD%A3%E7%9D%BF/"/>
    
    
      <category term="枚举" scheme="www.degage.xyz/tags/%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>树的距离</title>
    <link href="www.degage.xyz/2018/11/03/48/"/>
    <id>www.degage.xyz/2018/11/03/48/</id>
    <published>2018-11-03T02:25:50.000Z</published>
    <updated>2018-11-04T13:04:46.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>开始有一个空的集合S，进行Q次操作：</p><p>1.插入一个数x（如果已存在就忽略）<br>2.删除一个数x（如果不存在就忽略）<br>3.询问点集中数与x的最短距离<br>定义两个数a,b的距离为，每次将a乘一个质数或除以一个质数因子，使a变成b的最小步数。$（Q≤50000,x≤1000000，时限2秒）$</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>对于两个数A,B:</p><script type="math/tex; mode=display">A=p_1^{a_1}+p_2^{a_2}+.....p_n^{a_n}</script><script type="math/tex; mode=display">B=p_1^{b_1}+p_2^{b_2}+.....p_n^{b_n}</script><p>(如果某些$p_i$，相应的次数为0)<br>那么A,B的距离即为</p><script type="math/tex; mode=display">\sum_{i=1}^n abs(a_i-b_i)</script><p>设gcd(A,B)为g，那么dis可以化为$num(\frac a{g})+num(\frac b{g})$，其中num(x)表示x包含的质数个数。<br>然后我们发现枚举B的话复杂度无法承受，那么转过来枚举A的因数来作为GCD，然后统计相应步数即可。当然这里可以用set或map来维护以谁为gcd的最小B.</p><p>上代码：</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxn 1000005using namespace std;int prime[maxn&gt;&gt;1],top=0,s[maxn];typedef long long ll;bool vis[maxn];void ready(){    vis[0]=vis[1]=1;    for(int i=2;i&lt;=maxn-5;i++){        if(!vis[i]) prime[++top]=i,s[i]=1;        for(int j=1;j&lt;=top&amp;&amp;i*prime[j]&lt;=maxn-5;j++){            vis[prime[j]*i]=1;s[prime[j]*i]=s[i]+1;            if(i%prime[j]==0) break;         }    }}int q,op,x;int c[maxn][20];void init(){    scanf(&quot;%d&quot;,&amp;q);    memset(vis,0,sizeof(vis));    for(int i=1;i&lt;=q;i++){        scanf(&quot;%d%d&quot;,&amp;op,&amp;x);        if(op==1&amp;&amp;!vis[x]){            vis[x]=1;            for(int j=1;1ll*j*j&lt;=x;j++) if(x%j==0){                 c[j][s[x]-s[j]]++;                c[x/j][s[j]]++;            }        }        if(op==2&amp;&amp;vis[x]){            vis[x]=0;            for(int j=1;1ll*j*j&lt;=x;j++) if(x%j==0){                c[j][s[x]-s[j]]--;                c[x/j][s[j]]--;            }        }         if(op==3){            int ans=1e9;            for(int j=1;1ll*j*j&lt;=x;j++) if(x%j==0){                for(int k=0;k&lt;20;k++) if(c[j][k]) ans=min(ans,k+s[x]-s[j]);                for(int k=0;k&lt;20;k++) if(c[x/j][k]) ans=min(ans,k+s[j]);            }            if(ans==1e9) printf(&quot;-1\n&quot;);            else printf(&quot;%d\n&quot;,ans);        }    }}int main(){    ready();    init();    return 0;}</code></pre><p>滔滔的map代码：</p><pre><code class="lang-ruby">#include&lt;map&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000000+5,inf=0x3f3f3f3f;int n,f[maxn];bool vis[maxn];vector&lt;int&gt;primes;map&lt;int,int&gt;mp[maxn];void init(){    for(int i=2;i&lt;=maxn-5;i++){        if(!f[i])f[i]=1,primes.push_back(i);        for(int k=0;k&lt;primes.size()&amp;&amp;i*primes[k]&lt;=maxn-5;k++){            f[i*primes[k]]=f[i]+1;            if(i%primes[k]==0)break;        }    }}void ins(int x){    if(vis[x])return;vis[x]=1;    int sq=sqrt(x+0.5);    for(int i=1;i&lt;=sq;i++){        if(x%i==0)mp[i][f[x]]++;        if(x%i==0&amp;&amp;i*i!=x)mp[x/i][f[x]]++;    }}void del(int x){    if(!vis[x])return;vis[x]=0;    int sq=sqrt(x+0.5);    for(int i=1;i&lt;=sq;i++){        if(x%i==0)if(--mp[i][f[x]]==0)mp[i].erase(f[x]);        if(x%i==0&amp;&amp;i*i!=x)if(--mp[x/i][f[x]]==0)mp[x/i].erase(f[x]);    }}int Find(int i){    if(!mp[i].size())return inf*2;    return mp[i].begin()-&gt;first;}void solve(int x){    int sq=sqrt(x+0.5),ans=inf;    for(int i=1;i&lt;=sq;i++){        if(x%i==0)ans=min(ans,f[x]+Find(i)-2*f[i]);        if(x%i==0&amp;&amp;i*i!=x)ans=min(ans,f[x]+Find(x/i)-2*f[x/i]);    }    if(ans&gt;=inf)printf(&quot;-1\n&quot;);    else printf(&quot;%d\n&quot;,ans);}int main(){    init();    scanf(&quot;%d&quot;,&amp;n);    for(int i=1,op,x;i&lt;=n;i++){        scanf(&quot;%d%d&quot;,&amp;op,&amp;x);        if(op==1)ins(x);        if(op==2)del(x);        if(op==3)solve(x);    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;开始有一个空的集合S，进行Q次操作：&lt;/p&gt;
&lt;p&gt;1.插入一个数x
      
    
    </summary>
    
      <category term="正睿" scheme="www.degage.xyz/categories/%E6%AD%A3%E7%9D%BF/"/>
    
    
      <category term="数学" scheme="www.degage.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="枚举" scheme="www.degage.xyz/tags/%E6%9E%9A%E4%B8%BE/"/>
    
      <category term="map" scheme="www.degage.xyz/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>小G的树</title>
    <link href="www.degage.xyz/2018/11/03/47/"/>
    <id>www.degage.xyz/2018/11/03/47/</id>
    <published>2018-11-03T02:25:42.000Z</published>
    <updated>2018-11-03T03:18:04.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给出n个点的树，每条边长会等概率是1或2，求树的直径的期望。（$n≤60$）</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>只要会树型dp求树的直径，然后枚举就可以$O(n^4)$过了</p><p>上代码：</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxn 70using namespace std;typedef long long ll;ll g[maxn&lt;&lt;1][maxn&lt;&lt;1],ff[maxn][maxn&lt;&lt;1][maxn&lt;&lt;1];int n,x,y;struct eage{    int to,next;}e[maxn&lt;&lt;1];int np=0,first[maxn];void add(int u,int v){    e[++np]=(eage){v,first[u]};    first[u]=np;}int sz[maxn];void dfs(int i,int f){     ff[i][0][0]=sz[i]=1;     for(int p=first[i];p;p=e[p].next){         int j=e[p].to;         if(j==f) continue;         dfs(j,i);         memset(g,0,sizeof(g));         for(int l1=0;l1&lt;=sz[i]*2;l1++)         for(int z1=l1;z1&lt;=sz[i]*2;z1++)if(ff[i][l1][z1])         for(int l2=0;l2&lt;=sz[j]*2;l2++)         for(int z2=l2;z2&lt;=sz[j]*2;z2++) if(ff[j][l2][z2]){             for(int len=1;len&lt;=2;len++){             int t=max(z1,z2);             t=max(t,l1+l2+len);             g[max(l1,l2+len)][t]+=ff[i][l1][z1]*ff[j][l2][z2];;            }        }        sz[i]+=sz[j];        for(int l=0;l&lt;=sz[i]*2;l++)        for(int z=l;z&lt;=sz[i]*2;z++)        ff[i][l][z]=g[l][z];     } } void init(){    scanf(&quot;%d&quot;,&amp;n);    for(int i=1;i&lt;n;i++){        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);add(x,y);add(y,x);    }     dfs(1,0);    double ans=0;    for(int l=0;l&lt;=n*2;l++)    for(int z=l;z&lt;=n*2;z++){        ans+=ff[1][l][z]*z;    }     printf(&quot;%lf&quot;,ans/(1ll&lt;&lt;(n-1)));}int main(){    init();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;给出n个点的树，每条边长会等概率是1或2，求树的直径的期望。（$n≤
      
    
    </summary>
    
      <category term="正睿" scheme="www.degage.xyz/categories/%E6%AD%A3%E7%9D%BF/"/>
    
    
      <category term="概率期望" scheme="www.degage.xyz/tags/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/"/>
    
      <category term="树型dp" scheme="www.degage.xyz/tags/%E6%A0%91%E5%9E%8Bdp/"/>
    
  </entry>
  
  <entry>
    <title>郁闷的小G</title>
    <link href="www.degage.xyz/2018/11/03/46/"/>
    <id>www.degage.xyz/2018/11/03/46/</id>
    <published>2018-11-03T02:25:35.000Z</published>
    <updated>2018-11-03T03:21:23.103Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>有5种类型的题E,EM,M,MH,H若干，其中E,EM可用来出第一题，EM,M,MH可用来出第二题，MH,H可用来出第三题，求最多可出多少场模拟赛。（设N为最大数，$1≤N≤10^18$）</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>我干考试时懵了直接上了个大模拟，结果用二分简单到爆炸！！！</p><p>模拟：</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll e,em,m,mh,h,a,b,c,x=1,y=1;int main(){     scanf(&quot;%lld%lld%lld%lld%lld&quot;,&amp;e,&amp;em,&amp;m,&amp;mh,&amp;h);     a=e+em,b=m,c=mh+h;     if(a&lt;=b) x=0;     if(c&lt;=b) y=0;     if(!x&amp;&amp;!y){         ll ans=min(a,min(b,c));         printf(&quot;%lld&quot;,ans);     }     else if(!x){         ll mid=(b+c)/2;         if(mid-b&lt;=mh) y=mid-b;         else y=mh;         ll minn=y+b;         ll ans=min(a,minn);         printf(&quot;%lld&quot;,ans);     }     else if(!y){         ll mid=(a+b)/2;         if(mid-b&lt;=em) x=mid-b;         else x=em;         ll minn=b+x;         ll ans=min(minn,c);         printf(&quot;%lld&quot;,ans);     }     else{         if(a&gt;c){             ll mv=a-c;             if(mv&gt;em) mv=em;            a=a-mv;              if(b+mv&gt;=c){                 printf(&quot;%lld&quot;,c);            }            else{                if(mv==em){                    b+=mv;                    ll mid=(b+c)/2;                     if(mid-b&lt;=mh) y=mid-b;                     else y=mh;                     ll minn=y+b;                     printf(&quot;%lld&quot;,minn);                }                else{                    b+=mv;                    em-=mv;//还剩的步数                     ll mvv=min(em,mh);                    ll cnt=(c-b)/3;                    if(cnt&gt;mvv) cnt=mvv;                    ll minn=b+cnt*2;                    c=c-cnt,a=a-cnt;em-=mvv;mh-=mvv;                    if(minn&lt;c){                       if(em){                           ll mid=(minn+c)/2;                         if(mid-minn&lt;=em) y=mid-minn;                         else y=em;                         minn=minn+y;                       }                       if(mh){                           ll mid=(minn+c)/2;                         if(mid-minn&lt;=mh) y=mid-minn;                         else y=mh;                         minn=minn+y;                       }                        }                    printf(&quot;%lld&quot;,minn);                }            }         }         else{             ll mv=c-a;             if(mv&gt;mh) mv=mh;            c=c-mv;              if(b+mv&gt;=a){                 printf(&quot;%lld&quot;,a);            }            else{                if(mv==mh){                    b+=mv;                    ll mid=(a+b)/2;                     if(mid-b&lt;=em) x=mid-b;                     else x=em;                     ll minn=b+x;                     printf(&quot;%lld&quot;,minn);                }                else{                    b+=mv;                    mh-=mv;//还剩的步数                     ll mvv=min(em,mh);                    ll cnt=(c-b)/3;                    if(cnt&gt;mvv) cnt=mvv;                    ll minn=b+cnt*2;                    c=c-cnt,a=a-cnt;em-=mvv;mh-=mvv;                    if(minn&lt;c){                       if(em){                           ll mid=(minn+c)/2;                         if(mid-minn&lt;=em) y=mid-minn;                         else y=em;                         minn=minn+y;                       }                       if(mh){                           ll mid=(minn+c)/2;                         if(mid-minn&lt;=mh) y=mid-minn;                         else y=mh;                         minn=minn+y;                       }                        }                    printf(&quot;%lld&quot;,minn);                }            }         }     }    return 0;}</code></pre><p>滔滔的二分：</p><pre><code class="lang-c++">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;bool check(LL mid,LL A,LL B,LL C,LL A_B,LL B_C){    if(A&lt;mid){if(A+A_B&lt;mid)return false;A_B-=mid-A;}B+=A_B;    if(B&lt;mid){if(B+B_C&lt;mid)return false;B_C-=mid-B;}    C+=B_C;if(C&lt;mid)return false;    return true;}int main(){    LL A,B,C,A_B,B_C;    scanf(&quot;%lld%lld%lld%lld%lld&quot;,&amp;A,&amp;A_B,&amp;B,&amp;B_C,&amp;C);    LL L=min({A,B,C}),R=max({A+A_B,B+A_B+B_C,B_C+C}),ans;    while(L&lt;=R){        LL mid=(L+R)&gt;&gt;1;        if(check(mid,A,B,C,A_B,B_C))ans=mid,L=mid+1;        else R=mid-1;    }    printf(&quot;%lld&quot;,ans);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;有5种类型的题E,EM,M,MH,H若干，其中E,EM可用来出第一题
      
    
    </summary>
    
      <category term="正睿" scheme="www.degage.xyz/categories/%E6%AD%A3%E7%9D%BF/"/>
    
    
      <category term="模拟" scheme="www.degage.xyz/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="二分" scheme="www.degage.xyz/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>取数游戏</title>
    <link href="www.degage.xyz/2018/11/01/45/"/>
    <id>www.degage.xyz/2018/11/01/45/</id>
    <published>2018-11-01T09:39:42.000Z</published>
    <updated>2018-11-01T09:47:19.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>有一个$N \ast M$的矩阵，你需要进行恰好K次操作，每次可以选择其中一行或者其中一列，将其中的元素全部累加到ans里去，然后把全中的这些数全部减去P，问ans最大是多少</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>2 2 2 2<br>1 3<br>2 4</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>11</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>$N,M&lt;=1000,K&lt;=10^5,0&lt;=P&lt;=100,1&lt;A_{ij}&lt;1000$</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先探究性质发现取行或取列只分别对列和行整体造成影响，贪心还是要取大的，所以只考虑对自身的影响。再发现取行或取列都是分别对以后的取列或取行造成-p的影响，所以先后是没有关系的。<br>那么先预处理出去行k次和取列k次最大值，再O(n)枚举行列分别取多少，再减去$i \ast (k-i) \ast p$即可。</p><p>上代码：</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxn 100005using namespace std;typedef long long ll;ll h[maxn],l[maxn],sh[maxn],sl[maxn];int n,m,k,p,x;priority_queue&lt;ll&gt;q,qq;void init(){    scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;k,&amp;p);    for(int i=1;i&lt;=n;i++)    for(int j=1;j&lt;=m;j++){        scanf(&quot;%d&quot;,&amp;x);        h[i]+=x;l[j]+=x;    }    for(int i=1;i&lt;=n;i++) q.push(h[i]);    for(int i=1;i&lt;=k;i++){        ll t=q.top();q.pop();        sh[i]=sh[i-1]+t;t-=m*p;        q.push(t);    }    for(int i=1;i&lt;=m;i++) qq.push(l[i]);    for(int i=1;i&lt;=k;i++){        ll t=qq.top();qq.pop();        sl[i]=sl[i-1]+t;t-=n*p;        qq.push(t);     }    ll ans=-1000000000000;    for(int i=0;i&lt;=k;i++){          ans=max(ans,sh[i]+sl[k-i]-1ll*i*(k-i)*p);    }    printf(&quot;%lld&quot;,ans);} int main(){    init();    return 0; }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;有一个$N \ast M$的矩阵，你需要进行恰好K次操作，每次可以选
      
    
    </summary>
    
      <category term="正睿" scheme="www.degage.xyz/categories/%E6%AD%A3%E7%9D%BF/"/>
    
    
      <category term="贪心" scheme="www.degage.xyz/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="优先队列" scheme="www.degage.xyz/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>字符串</title>
    <link href="www.degage.xyz/2018/11/01/44/"/>
    <id>www.degage.xyz/2018/11/01/44/</id>
    <published>2018-11-01T09:32:22.000Z</published>
    <updated>2018-11-03T00:35:23.291Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>要求用m种字母构造一个长度为n的字符串，使得该字符串的所有长度为k的子串均为回文串，问方案数</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>三个整数$n,m,k(1≤n,m,k≤2000)$</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>输出满足条件的字符串数量，结果模$10^9+7$</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>5 2 4</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>2</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>对于每个位置，考虑它在一个回文串中的位置，与它相应的与它用并查集相连(回文串必须一样)，最后剩下若干集合，有cnt个，那么答案即为$m^{cnt}$，当然也可以直接分k,n关系讨论</p><p>并查集代码：</p><pre><code class="lang-c++">#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;ctime&gt;using namespace std;typedef long long ll;typedef pair&lt;int,int&gt;P;const int INF=0x3f3f3f3f,maxn=100001;#define mod 1000000007int Pow(int a,int b){    int ans=1;    while(b)    {        if(b&amp;1)ans=(ll)ans*a%mod;        a=(ll)a*a%mod;        b&gt;&gt;=1;    }    return ans;}int n,m,k,fa[maxn];int find(int x){    if(fa[x]==x)return x;    return fa[x]=find(fa[x]);}void unite(int x,int y){    x=find(x),y=find(y);    if(x==y)return ;    fa[x]=y;}int main(){    int n,m,k;    while(~scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k))    {        for(int i=1;i&lt;=n;i++)fa[i]=i;        for(int i=1;i&lt;=n;i++)            for(int j=1;j&lt;k&amp;&amp;i+k-j&lt;=n;j+=2)                unite(i,i+k-j);        int ans=0;        for(int i=1;i&lt;=n;i++)            if(fa[i]==i)ans++;        ans=Pow(m,ans);        printf(&quot;%d\n&quot;,ans);    }    return 0;}</code></pre><p>nk关系代码：</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxn 2005using namespace std;typedef long long ll;const ll mod=1e9+7;int n,m,k;ll qkpow(ll t,int pos){    ll ans=1,base=t;    while(pos){        if(pos&amp;1) ans=ans*base%mod;        base=base*base%mod;        pos=pos&gt;&gt;1;    }    return ans;}void init(){    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);    if(k==1){        printf(&quot;%lld&quot;,qkpow(m,n));    }    else if(k==n) printf(&quot;%lld&quot;,qkpow(m,(k+1)/2));    else if(k&amp;1) printf(&quot;%lld&quot;,m*m%mod);    else if(k&gt;n) printf(&quot;%lld&quot;,qkpow(m,n));    else printf(&quot;%d&quot;,m);}int main(){    init();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;要求用m种字母构造一个长度为n的字符串，使得该字符串的所有长度为k的
      
    
    </summary>
    
      <category term="正睿" scheme="www.degage.xyz/categories/%E6%AD%A3%E7%9D%BF/"/>
    
    
      <category term="数学" scheme="www.degage.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="并查集" scheme="www.degage.xyz/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>Coin</title>
    <link href="www.degage.xyz/2018/10/31/43/"/>
    <id>www.degage.xyz/2018/10/31/43/</id>
    <published>2018-10-31T11:38:09.000Z</published>
    <updated>2018-10-31T12:05:48.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>小M有个n行m列的棋盘，每个格子都包含了至多一枚硬币，硬币正面或者反面朝上。<br>小M和小D轮流操作，小M先手。每个人可以选择棋盘中没在之前被选择过的一行或者一列，然后将所选的行或列上的硬币全部翻转，即正面变成反面，反面变成正面。<br>当所有硬币都正面朝上或者所有的行列都被选择，游戏结束。最后一次操作的玩家将会获得1分。如果当前局面所有的硬币都正面朝上，小M和小D都将获得2分的额外收益。<br>问两个人如果都按最优策略操作，即最大化自己的分数，那么小M最后的得分是多少。（T组数据，1≤T,n,m≤100）<br>保证每列至少有一个硬币，每行至少有一个反面朝上的硬币。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>1<br>2 5<br>exexe<br>xeoex</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>3</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先如果能构成全向上的局面，那么两人肯定是要构成的。否则就按照n+m奇偶来决定最后谁走。<br>我们假设向上为0，向下为1，那么对于每一个$a_{ij}$，要求满足$h_i xor l_j xor a_{ij}==0$，变化一下即为<br>$h_i xor l_j==a_{i-j}$，所以我们设$a_{ij}$为边权，然后可以连边维护，用类似二分图染色的方法扫一遍以判断是否合法(本可以用并查集维护，但貌似方式不对，联系不紧密)<br>那么我们现在就会有诸多联通块，对每个联通块是个独立游戏，我们开始讨论：<br>如果是奇-奇那么先手在这一块必定赢，而偶偶先手必输但是没影响因为如果有奇奇的话，先手最后是多下一步的，这是第一部分。第二部分就是奇偶，如果只有奇数个奇偶，那么最终先手可以多选一个奇偶的奇而获胜，否则后手选到奇偶的偶获胜。<br>注意细节实现就行了。</p><p>上代码：</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;#define maxn 105struct eage{    int to,next,len;}e[maxn*maxn*2];int np=0,first[maxn&lt;&lt;1];void add(int u,int v,int len){    e[++np]=(eage){v,first[u],len};    first[u]=np;}int t,n,m;char op[maxn];bool ok;int base;int cnt[3];int color[maxn&lt;&lt;1];void dfs(int i){    cnt[color[i]]++;    for(int p=first[i];p;p=e[p].next){        int j=e[p].to,c=e[p].len;        if(c==0){            if(color[j]){                if(color[j]!=color[i]) ok=false;                continue;            }            else{                color[j]=color[i];                dfs(j);            }        }         else{            if(color[j]){                if(color[i]==color[j]) ok=false;                continue;            }            else{                color[j]=3-color[i];                dfs(j);            }        }    }}void run(){    for(int i=1;i&lt;=n+m;i++){        if(!color[i]){            cnt[1]=cnt[2]=0;            color[i]=1;            ok=true;            dfs(i);            if(!ok) return;            if(cnt[1]&amp;1&amp;&amp;cnt[2]&amp;1) base^=1;            else if(!(cnt[1]&amp;1)&amp;&amp;!(cnt[2]&amp;1)) ;            else base^=2;         }     }}void init(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    memset(color,0,sizeof(color));    memset(first,0,sizeof(first));    np=0;    ok=true;    base=0;    for(int i=1;i&lt;=n;i++){        scanf(&quot;%s&quot;,op+1);        for(int j=1;j&lt;=m;j++){         if(op[j]==&#39;x&#39;){             add(i,j+n,1);             add(j+n,i,1);         }          if(op[j]==&#39;o&#39;){             add(i,j+n,0);             add(j+n,i,0);         }        }     }    run();    if(!ok){        int calc=n+m;        if(calc&amp;1){            printf(&quot;1\n&quot;);        }        else{            printf(&quot;0\n&quot;);        }    }    else{        if(base) printf(&quot;3\n&quot;);        else printf(&quot;2\n&quot;);    }}int main(){    scanf(&quot;%d&quot;,&amp;t);    for(int i=1;i&lt;=t;i++)    init();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;小M有个n行m列的棋盘，每个格子都包含了至多一枚硬币，硬币正面或者反
      
    
    </summary>
    
      <category term="正睿" scheme="www.degage.xyz/categories/%E6%AD%A3%E7%9D%BF/"/>
    
    
      <category term="隐式图" scheme="www.degage.xyz/tags/%E9%9A%90%E5%BC%8F%E5%9B%BE/"/>
    
      <category term="博弈论" scheme="www.degage.xyz/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
      <category term="二分图" scheme="www.degage.xyz/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Poker</title>
    <link href="www.degage.xyz/2018/10/31/42/"/>
    <id>www.degage.xyz/2018/10/31/42/</id>
    <published>2018-10-31T11:29:24.000Z</published>
    <updated>2018-10-31T11:43:40.649Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>一共有n张扑克牌，第i张扑克牌的编号为$a_i$，这里保证n为偶数。<br>先将n张牌随机的分成两堆大小为$\frac{n}{2}$的牌，一人拿一堆，随机为均匀随机。<br>将n张牌随机打乱，两人开始比大小，按顺序翻各自的牌，如果前者大于后者，那么前者得一分，否则后者得一分，问前者和后者得分的期望，输出答案乘上n!然后对1e9+7取模的值。</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>4<br>1 2 3 2</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>20 28</p><h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><p>$n&lt;=10^5$</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>其实是个假期望题。<br>发现总方案数是n!，所以实际上是找全排列并统计得分。然后发现是排列，所以每次可以固定两个不同的数，然后乘上(n-2)!</p><p>上代码：</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxn 100005using namespace std;typedef long long ll;const ll mod=1e9+7;int n,a[maxn];ll jc;void init(){    scanf(&quot;%d&quot;,&amp;n);    jc=1ll;    for(int i=1;i&lt;=n;i++){    scanf(&quot;%d&quot;,&amp;a[i]);    if(i&lt;=n-2) jc=jc*(ll)i%mod;        }    sort(a+1,a+n+1);    ll ans1=0;    ll cnt=0;    ll len=n/2;     ll ans2=0;    for(int i=1;i&lt;=n;i++){        if(a[i]==a[i+1]){            cnt++;        }        else{            cnt++;            ans1=(ans1+cnt*jc%mod*(ll)(n-i)%mod)%mod;            ans2=(ans2+cnt*jc%mod*(ll)(n-i+cnt-1)%mod)%mod;            cnt=0;        }    }    ans1=ans1*len%mod;    ans2=ans2*len%mod;    printf(&quot;%lld &quot;,ans1);    printf(&quot;%lld&quot;,ans2);} int main(){    init();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;一共有n张扑克牌，第i张扑克牌的编号为$a_i$，这里保证n为偶数。
      
    
    </summary>
    
      <category term="正睿" scheme="www.degage.xyz/categories/%E6%AD%A3%E7%9D%BF/"/>
    
    
      <category term="概率期望" scheme="www.degage.xyz/tags/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/"/>
    
      <category term="数学" scheme="www.degage.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>当那一天来临</title>
    <link href="www.degage.xyz/2018/10/30/41/"/>
    <id>www.degage.xyz/2018/10/30/41/</id>
    <published>2018-10-30T15:17:20.000Z</published>
    <updated>2018-10-30T15:30:11.322Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>一条线段上有n个点，每个点有一个权值，要是一个人经过一个权值为w的点，那么他的金钱就增加w（w可以为负数）。<br>现在Jack最开始在1号点，Rose最开始在n号点（此时Jack只有1号点的金钱，Rose只有n号点的金钱），他们要走到某个站点相会，整个过程中只能相向而行，并且每一次走一个点。首先是Jack选择自己向右走一个点或者让Rose向左做一个点；接着是Rose选择让Jack向右走一个点或者自己向左走一个点；接着又是Jack选择，直到两个人相遇。<br>现在两人都采用最优策略，问相遇之后他们谁金钱多。如果Jack比Rose的金钱多，输出“win”，相等输出“tie”，少则输出“lose”。（T组数据，T≤10,1≤n≤10000）</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><p>3<br>4<br>1 3 2 3<br>4<br>1 2 2 3<br>5<br>-1 -2 -1 -1 -1 </p><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><p>win<br>tie<br>lose</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>对于100%的数据，1&lt;=N&lt;=10000.</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先我们可以将题目的选项实际化，让自己走就是正常，让别人走就是让终点往自己这边移动，然后我们发现答案只与最终相遇位置有关。那么举几个例子，发现在n为偶数时，先手能够决定终点是在n/2+1或者n/2.而在n为奇数时，若先手先让自己走，那么后手能决定终点在n/2+1或n/2+1+1;若先手先让对面走，那么后手能决定终点在n/2+1或n/2。(所以大力分情况讨论即可)实际上n为奇数就是-1变成n为偶数然后交换先手权罢了。</p><p>上代码：</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxn 10005using namespace std;int t,n,a[maxn],sum1,sum2;void init(){    sum1=sum2=0;    scanf(&quot;%d&quot;,&amp;n);    int z=n/2+1;    for(int i=1;i&lt;=n;i++){    scanf(&quot;%d&quot;,&amp;a[i]);    if(i&lt;=z) sum1+=a[i];    if(i&gt;=z) sum2+=a[i];    }    if(n&amp;1){        int t=sum1-sum2;        int changez=-a[z]-a[z-1];        int changey=a[z]+a[z+1];        int change=max(changey,changez);//由先手决定        t=min(t,t+change);//由后手决定        if(t&gt;0) printf(&quot;win\n&quot;);        if(t==0) printf(&quot;tie\n&quot;);        if(t&lt;0) printf(&quot;lose\n&quot;);    }    else{        int t=sum1-sum2;        int change=-a[z]-a[z-1];        if(change&gt;0) t+=change;        if(t&gt;0) printf(&quot;win\n&quot;);        if(t==0) printf(&quot;tie\n&quot;);        if(t&lt;0) printf(&quot;lose\n&quot;);    }}int main(){    scanf(&quot;%d&quot;,&amp;t);    for(int i=1;i&lt;=t;i++) init();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;一条线段上有n个点，每个点有一个权值，要是一个人经过一个权值为w的点
      
    
    </summary>
    
      <category term="正睿" scheme="www.degage.xyz/categories/%E6%AD%A3%E7%9D%BF/"/>
    
    
      <category term="博弈论" scheme="www.degage.xyz/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>假如战争今天爆发</title>
    <link href="www.degage.xyz/2018/10/30/40/"/>
    <id>www.degage.xyz/2018/10/30/40/</id>
    <published>2018-10-30T09:48:28.000Z</published>
    <updated>2018-11-06T16:36:24.609Z</updated>
    
    <content type="html"><![CDATA[<p><font color="green">假如<del>战争今天爆发</del>生活欺骗了你</font></p><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>有n件物品，每件物品要被三个机器一次加工（即是说，只有被第一个机器加工后才能被第二个机器加工，被第二个机器加工后才能被第三个机器加工）。第i件物品被三个机器加工所需要的时间分别为$A_i,B_i,C_i$，保证 $min(C_i)≥max(B_i)$。每个机器同一时刻只能加工一件物品，求让每件物品都被三个机器加工完所需要的最少时间。$（1≤n≤100000,0&lt;A_i,B_i,C_i&lt;106）$</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><p>3<br>5 3 4<br>3 2 9<br>3 4 8</p><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><p>26</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先可以假设已经排好了顺序，那么计算最终时间，设dp(i,j)表示第i个被第j个机器加完工的时间，那么:<br>$dp[i][j]=max(dp[i][j-1],dp[i-1][j])+a_{ij}$，那我们把它转移到图上面即从(1,1)到(n,3)，每次可以从左边或上边转移过来，实际上就发现是求最长路，如图：<br><img src="https://i.loli.net/2018/11/06/5be1a22f9e267.png" alt=""><br>那么对于绿色和黄色的我们交换其间任意两个是没有影响的，而对于蓝色和黄色处便会有影响，这便是决定排列顺序的，所以当i要排在j前面的条件如下：</p><script type="math/tex; mode=display">max(a_{i1}+a_{i2}+a_{i3}+a_{j3},a_{i1}+a_{j1}+a_{j2}+a_{j3})<=max(a_{j1}+a_{j2}+a_{j3}+a_{i3},a_{j1}+a_{i1}+a_{i2}+a_{i3})</script><script type="math/tex; mode=display">max(a_{i2}+a_{i3},a_{j1}+a_{j2})+a_{i1}+a_{j3}<=max(a_{j2}+a_{j3},a_{i1}+a_{i2})+a_{j1}+a_{i3}</script><p>设$a_{i1}+a_{i2}$为$A_i$，$a_{i2}+a_{i3}$为$B_i$，那么，转化为：</p><script type="math/tex; mode=display">max(B_i,A_j)+A_i-B_i<=max(B_j,A_i)+A_j-B_j</script><p>进一步转化为：</p><script type="math/tex; mode=display">max(-A_j,-B_i)<=max(-A_i,-B_j)</script><p>那么以这个为关键字排序就欧克了，就可以得到最终的最优排列顺序。</p><p>上代码：</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxn 100005using namespace std;typedef long long ll;ll suma[maxn],sumc[maxn];struct node{    int a,b,c;    friend bool operator&lt;(node x,node y){        int ai=x.a+x.b,aj=y.a+y.b,bi=x.b+x.c,bj=y.b+y.c;        return max(-aj,-bi)&lt;=max(-ai,-bj);    }}nd[maxn];int n;void init(){    scanf(&quot;%d&quot;,&amp;n);    for(int i=1;i&lt;=n;i++) scanf(&quot;%d%d%d&quot;,&amp;nd[i].a,&amp;nd[i].b,&amp;nd[i].c);    sort(nd+1,nd+n+1);    ll ta=0,tb=0,tc=0;    for(int i=1;i&lt;=n;i++){        ta+=nd[i].a;        if(tb&lt;ta) tb=ta;        tb+=nd[i].b;        if(tc&lt;tb) tc=tb;        tc+=nd[i].c;    }    printf(&quot;%lld&quot;,tc);} int main(){    init();        return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font color=&quot;green&quot;&gt;假如&lt;del&gt;战争今天爆发&lt;/del&gt;生活欺骗了你&lt;/font&gt;&lt;/p&gt;
&lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Descriptio
      
    
    </summary>
    
      <category term="正睿" scheme="www.degage.xyz/categories/%E6%AD%A3%E7%9D%BF/"/>
    
    
      <category term="贪心" scheme="www.degage.xyz/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="dp" scheme="www.degage.xyz/tags/dp/"/>
    
      <category term="最长路" scheme="www.degage.xyz/tags/%E6%9C%80%E9%95%BF%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>强军战歌</title>
    <link href="www.degage.xyz/2018/10/30/39/"/>
    <id>www.degage.xyz/2018/10/30/39/</id>
    <published>2018-10-30T09:26:39.000Z</published>
    <updated>2018-10-30T11:53:53.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给出一个数列<script type="math/tex">A</script>，当这个数列不是不下降的时候我们删除其中一个数，直到它是不下降的。求不同的删除方案总数，答案对<script type="math/tex">1000000007</script>取模。我们定义删除方案不同有两种情况：</p><ul><li>删掉的数构成的集合不同</li><li>删掉的数构成的集合相同，但删除顺序不同</li></ul><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><p>3<br>1 7 5</p><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><p>4</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>$1&lt;=n&lt;=2000,1&lt;=A_i&lt;=2000$</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>探究问题本质，发现是删掉数后刚好(首次)是个非严格LIS，那么我们如果去掉刚好这个限制，总方案数就会是$\sum_{i=1}^{n} cnt_i \ast (n-i)!$，其中$cnt_i$为长度为i的LIS个数，那么显然这样是不行的，因为有很多不合法的计入了。<br>那么什么样的是不合法的呢，即已经是LIS之后还继续删除，这样的数即为$\sum_{i=2}^{n} cnt_i \ast i \ast (n-i)!$，注意这里1的没有计入，因为1删完之后就没了a23333.<br>综上，$ans=\sum_{i=1}^{n} cnt_i \ast (n-i)!-\sum_{i=2}^{n} cnt_i \ast i \ast (n-i)!$.<br>然后是对于$cnt_i$的计算，我们设dp(i,j)表示以i结尾长度为j的LIS个数，那么：<br>(tips:可以了解一下这个思路，以后统计找结尾和长度以便于统计，因为LIS结尾要求递增，可以dp)<br>$dp[i][j]+=dp[k][j-1] k在j前面且a[k]&lt;=a[j]$<br>由于范围限制，我们使用树状数组来维护将其优化到$n^2logn$，那么这里需要离散化来确定哪些比它小。(详见代码注释)</p><p>上代码：</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxn 2005 using namespace std;typedef long long ll;const ll mod=1000000007;int n,a[maxn],aa[maxn];ll dp[maxn][maxn];//以i结尾,长度为j ll cnt[maxn];ll jc[maxn];ll c[maxn][maxn];//c[i][j]：长度为i，在j前面(lowbit长度)的方案数 void ready(){    jc[0]=1;    for(ll i=1;i&lt;=2000;i++) jc[i]=jc[i-1]*i%mod;}void update(int w,int i,ll d){     while(i&lt;=n){         c[w][i]=(c[w][i]+d)%mod;         i+=(i&amp;-i);     }}ll sum(int w,int i){    ll res=0;    while(i&gt;0){        res=(res+c[w][i])%mod;        i-=(i&amp;-i);    }    return res;}void init(){    scanf(&quot;%d&quot;,&amp;n);    for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);    /*for(int i=1;i&lt;=n;i++){       rear=0;       for(int j=i;j&lt;=n;j++){           int t=upper_bound(q+1,q+rear+1,a[j])-q;           if(t==rear+1) q[++rear]=a[j];else{               if(t==1) continue;//头不能更换 来保证独立性，以当前为开头                q[t]=a[j];        }         cnt[t]++;           for(int k=t-1;k&gt;=2;k--) cnt[k]++;        }    }*///干！不行aaaaaaaaaaaa    memcpy(aa,a,sizeof(a));    sort(aa+1,aa+n+1);    int cntt=unique(aa+1,aa+n+1)-aa-1;    /*for(int i=1;i&lt;=n;i++){//枚举开头         memset(c,0,sizeof(c));        dp[i][1]=1;        int pos=lower_bound(aa+1,aa+n+1,a[i])-aa;        update(1,pos,1);         for(int j=2;j&lt;=n;j++){        ll calc=0;            for(int k=i+1;k&lt;=n;k++){            pos=lower_bound(aa+1,aa+n+1,a[k])-aa;            int tt=sum(j-1,pos-1);            calc+=tt;            update(j,pos,tt);        }        dp[i][j]=calc;            }    }*/    for(int i=1;i&lt;=n;i++){        dp[i][1]=1;         for(int j=2;j&lt;=i;j++){        int pos=lower_bound(aa+1,aa+cntt+1,a[i])-aa;        dp[i][j]=sum(j-1,pos);//等于长度为j-1的         }        for(int k=1;k&lt;=i;k++){        int pos=lower_bound(aa+1,aa+cntt+1,a[i])-aa;        update(k,pos,dp[i][k]);            }      }    for(int i=1;i&lt;=n;i++)    for(int j=1;j&lt;=n;j++) cnt[j]=(cnt[j]+dp[i][j])%mod;    ll all=0;    for(int i=1;i&lt;=n;i++){        all=(all+cnt[i]*jc[n-i]%mod)%mod;    }    ll del=0;    for(int i=2;i&lt;=n;i++){        del=(del+cnt[i]*i%mod*jc[n-i]%mod)%mod;    }    ll ans=(all-del+mod)%mod;    printf(&quot;%lld&quot;,ans);}int main(){    ready();    init();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;给出一个数列&lt;script type=&quot;math/tex&quot;&gt;A&lt;/s
      
    
    </summary>
    
      <category term="正睿" scheme="www.degage.xyz/categories/%E6%AD%A3%E7%9D%BF/"/>
    
    
      <category term="dp" scheme="www.degage.xyz/tags/dp/"/>
    
      <category term="LIS" scheme="www.degage.xyz/tags/LIS/"/>
    
      <category term="离散化" scheme="www.degage.xyz/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    
      <category term="树状数组" scheme="www.degage.xyz/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
</feed>
