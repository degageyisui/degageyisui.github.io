<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>祎隋</title>
  
  <subtitle>祎隋如你，春风十里不及你</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="www.degage.xyz/"/>
  <updated>2019-01-18T07:22:15.502Z</updated>
  <id>www.degage.xyz/</id>
  
  <author>
    <name>degage</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>平衡树板子</title>
    <link href="www.degage.xyz/2019/01/18/%E6%9D%83%E5%80%BC%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    <id>www.degage.xyz/2019/01/18/权值平衡树/</id>
    <published>2019-01-18T01:46:45.000Z</published>
    <updated>2019-01-18T07:22:15.502Z</updated>
    
    <content type="html"><![CDATA[<p>qwq蒟蒻太蒻了a发现自己splay都不会敲了</p><p>权值平衡树：（按照权值的大小来维护，左边小右边大</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxn 100005int val[maxn],cnt[maxn],ch[maxn][2],fa[maxn],sz[maxn],rt=0,np=0;bool check(int x){return x==ch[fa[x]][1];}void link(int x,int y,bool kind){    fa[x]=y;ch[y][kind]=x;}void upload(int x){    sz[x]=sz[ch[x][0]]+sz[ch[x][1]]+cnt[x]; }void rotate(int x){    int y=fa[x],z=fa[y];    bool kind=check(x);    int k=ch[x][!kind];    link(k,y,kind);    link(x,z,check(y));//原来y在z哪边 在y连x之前，否则就变了     link(y,x,!kind);     upload(y);upload(x); }void splay(int x,int goal){//代入的为编号,val[x]才为它实际值     while(fa[x]!=goal){        int y=fa[x],z=fa[y];        if(z!=goal) (check(x)^check(y))?rotate(x):rotate(y);//z等于goal旋一次就欧克了         rotate(x);    }    if(fa[x]==0) rt=x;}void find(int x){    int now=rt;    while(ch[now][x&gt;val[now]]&amp;&amp;val[now]!=x)      now=ch[now][x&gt;val[now]];//如果没有这个数就停顿     splay(now,0);} void insert(int x){//插入权值     int f=0,now=rt;    while(now&amp;&amp;val[now]!=x) f=now,now=ch[now][x&gt;val[now]];    if(now) cnt[now]++;    else{        now=++np;        val[now]=x;        if(f) ch[f][x&gt;val[f]]=now;        fa[now]=f;        cnt[now]=1;    }    splay(now,0);}int prnx(int x,bool f){//x为值，返回的为编号     find(x);    int now=rt;    if(val[now]&lt;x&amp;&amp;!f||val[now]&gt;x&amp;&amp;f) return now;    now=ch[now][f];    while(ch[now][!f]) now=ch[now][!f];    return now;}void del(int x){    int pre=prnx(x,0),last=prnx(x,1);    splay(pre,0);splay(last,pre);    int delt=ch[last][0];    if(cnt[delt]&gt;1) {cnt[delt]--,splay(delt,0);}    else{ch[last][0]=0;splay(last,0);}}int kth(int now,int k){//查询当前子树的第k的编号     if(sz[now]&lt;k) return 0;//不存在的    while(1){        if(k&gt;sz[ch[now][0]]+cnt[now]) k-=cnt[now]+sz[ch[now][0]],now=ch[now][1];        else{            if(sz[ch[now][0]]&gt;=k) now=ch[now][0];            else{                splay(now,0);return now;            }        }    } }int kth(int x){//查询值为x的排名第几     find(x);    return sz[ch[rt][0]]+1;}int n,opt,x;void init(){    insert(INT_MIN);    insert(INT_MAX);    scanf(&quot;%d&quot;,&amp;n);    for(int i=1;i&lt;=n;i++){        scanf(&quot;%d%d&quot;,&amp;opt,&amp;x);        if(opt==1){            insert(x);        }        if(opt==2){            del(x);        }        if(opt==3){            printf(&quot;%d\n&quot;,kth(x)-1);        }        if(opt==4){            printf(&quot;%d\n&quot;,val[kth(rt,x+1)]);        }        if(opt==5){            printf(&quot;%d\n&quot;,val[prnx(x,0)]);        }        if(opt==6){            printf(&quot;%d\n&quot;,val[prnx(x,1)]);        }    }}int main(){    init();    return 0;}</code></pre><p>文艺平衡树：（按照中序遍历来维护，中序遍历不会变，如果插入是按照编号顺序的，那么可以理解为左边编号小，右边编号大</p><p>所以如果你在一个文艺平衡树中写find同时又要维护它的性质，那么就可以加一个rank函数来返回值在其中的编号，来维持中序遍历</p><p>code:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxn 100005using namespace std;int n,m,l,r;int val[maxn],cnt[maxn],sz[maxn],ch[maxn][2],fa[maxn],rt=0,np=0;bool check(int x){return x==ch[fa[x]][1];}bool rev[maxn];void link(int x,int y,bool kind){    fa[x]=y;ch[y][kind]=x;}void download(int x){    if(!rev[x]) return;    swap(ch[x][0],ch[x][1]);    rev[ch[x][0]]^=1;rev[ch[x][1]]^=1;    rev[x]=0;}void upload(int x){    sz[x]=sz[ch[x][0]]+sz[ch[x][1]]+1;}void rotate(int x){    int y=fa[x],z=fa[y];    bool kind=check(x);    int k=ch[x][!kind];    link(k,y,kind);    link(x,z,check(y));    link(y,x,!kind);    upload(y);upload(x); }void splay(int x,int goal){    while(fa[x]!=goal){         int y=fa[x],z=fa[y];         if(z!=goal) (check(x)^check(y))?rotate(x):rotate(y);         rotate(x);    }    if(fa[x]==0) rt=x;}void find(int x){    int now=rt;    while(ch[now][x&gt;val[now]]&amp;&amp;val[now]!=x) now=ch[now][x&gt;val[now]];    splay(now,0);}void insert(int x){    int now=rt,f=0;    while(now) f=now,now=ch[now][1];    now=++np;    link(now,f,1);cnt[now]=1;val[now]=x;    splay(now,0);}int prnx(int x,bool f){    find(x);    int now=rt;    if(val[now]&lt;x&amp;&amp;!f||val[now]&gt;x&amp;&amp;f) return now;    now=ch[now][f];    while(ch[now][!f]) now=ch[now][!f];    return now;}int kth(int now,int k){    download(now);    if(k&lt;=sz[ch[now][0]]) return kth(ch[now][0],k);    if(k&gt;sz[ch[now][0]]+1) return kth(ch[now][1],k-sz[ch[now][0]]-1);    splay(now,0);    return now;}void rvs(int l,int r){    int x=kth(rt,l);    int y=kth(rt,r+2);    splay(x,0);splay(y,x);    rev[ch[y][0]]^=1;}void out(int now){    download(now);    if(ch[now][0]) out(ch[now][0]);    if(now!=1&amp;&amp;now!=n+2) printf(&quot;%d &quot;,val[now]);    if(ch[now][1]) out(ch[now][1]);}void init(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=0;i&lt;=n+1;i++) insert(i);    for(int i=1;i&lt;=m;i++){        scanf(&quot;%d%d&quot;,&amp;l,&amp;r);        rvs(l,r);    }    out(rt);}int main(){    init();     return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;qwq蒟蒻太蒻了a发现自己splay都不会敲了&lt;/p&gt;
&lt;p&gt;权值平衡树：（按照权值的大小来维护，左边小右边大&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-c++&quot;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
#define maxn 100005
      
    
    </summary>
    
      <category term="省选" scheme="www.degage.xyz/categories/%E7%9C%81%E9%80%89/"/>
    
    
      <category term="平衡树" scheme="www.degage.xyz/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>后缀数组性质及模板</title>
    <link href="www.degage.xyz/2019/01/18/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E6%80%A7%E8%B4%A8%E5%8F%8A%E6%A8%A1%E6%9D%BF/"/>
    <id>www.degage.xyz/2019/01/18/后缀数组性质及模板/</id>
    <published>2019-01-18T00:11:48.000Z</published>
    <updated>2019-01-18T00:12:59.259Z</updated>
    
    <content type="html"><![CDATA[<p>后缀数组：</p><p>suff(i):以s的第i个字符为第一个元素的后缀</p><p>后缀数组sa[i]就表示排名为i的后缀的起始位置的下标</p><p>而它的映射数组rk[i]就表示起始位置的下标为i的后缀的排名</p><p>LCP(i,j)为suff(sa[i])与suff(sa[j])的最长公共前缀</p><ol><li><p>$LCP(i,j)=LCP(j,i);$</p></li><li><p>$LCP(i,i)=len(sa[i])=n-sa[i]+1$</p><p>性质：</p><p>$LCP(i,k)=min(LCP(i,j),LCP(j,k)) 对于任意1&lt;=i&lt;=j&lt;=k&lt;=n​$</p><p>$LCP(i,k)=min(LCP(j,j-1)) 对于任意1&lt;i&lt;j&lt;=k&lt;=n$</p><p>设$pub(i)=lcp(i,i-1)$,$h(i)=pub(rk[i])=suff(i)和suff(sa[rk[i]-1])的最长公共前缀$</p><p>结论：$h(i)&gt;=h(i-1)-1$</p></li></ol><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxn 1000005using namespace std;char s[maxn];int t1[maxn],t2[maxn],c[maxn],sa[maxn],a[maxn],pub[maxn];void solve(int n,int m){    int *x=t1,*y=t2;    for(int i=1;i&lt;=n;i++) c[x[i]=a[i]]++;    for(int i=1;i&lt;=m;i++) c[i]+=c[i-1];    for(int i=n;i&gt;=1;i--) sa[c[x[i]]--]=i;    for(int k=1;k&lt;=n;k&lt;&lt;=1){        int num=0;        for(int i=n-k+1;i&lt;=n;i++) y[++num]=i;        for(int i=1;i&lt;=n;i++) if(sa[i]&gt;k) y[++num]=sa[i]-k;        for(int i=1;i&lt;=m;i++) c[i]=0;        for(int i=1;i&lt;=n;i++) c[x[i]]++;        for(int i=1;i&lt;=m;i++) c[i]+=c[i-1];        for(int i=n;i&gt;=1;i--) sa[c[x[y[i]]]--]=y[i],y[i]=0;//y[i]表示y排名为i的下标         swap(x,y);        num=1;x[sa[1]]=1;        for(int i=2;i&lt;=n;i++){            x[sa[i]]=(y[sa[i]]==y[sa[i-1]]&amp;&amp;y[sa[i]+k]==y[sa[i-1]+k])?num:++num;        }        if(num==n) break;        m=num;    }    for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,sa[i]);}void lcp(){    int k=0;    for(int i=1;i&lt;=n;i++) rk[sa[i]]=i;    for(int i=1;i&lt;=n;i++){        if(rk[i]==1) continue;        if(k) k--;        int j=sa[rk[i]-1];        while(i+k&lt;=n&amp;&amp;j+k&lt;=n&amp;&amp;s[i+k]==s[j+k]) k++;        pub[rk[i]]=k;    }}int n;void init(){    scanf(&quot;%s&quot;,s);    int len=strlen(s);    n=0;    for(int i=0;i&lt;len;i++) a[++n]=s[i];    solve(n,122);    lcp(); }int main(){    init();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;后缀数组：&lt;/p&gt;
&lt;p&gt;suff(i):以s的第i个字符为第一个元素的后缀&lt;/p&gt;
&lt;p&gt;后缀数组sa[i]就表示排名为i的后缀的起始位置的下标&lt;/p&gt;
&lt;p&gt;而它的映射数组rk[i]就表示起始位置的下标为i的后缀的排名&lt;/p&gt;
&lt;p&gt;LCP(i,j)为suff(sa[i
      
    
    </summary>
    
      <category term="省选" scheme="www.degage.xyz/categories/%E7%9C%81%E9%80%89/"/>
    
    
      <category term="后缀数组" scheme="www.degage.xyz/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>生成函数预备</title>
    <link href="www.degage.xyz/2019/01/17/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E9%A2%84%E5%A4%87/"/>
    <id>www.degage.xyz/2019/01/17/生成函数预备/</id>
    <published>2019-01-17T03:33:02.000Z</published>
    <updated>2019-01-18T14:58:38.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="真的就是一些杂七杂八有用没用的东西…"><a href="#真的就是一些杂七杂八有用没用的东西…" class="headerlink" title="真的就是一些杂七杂八有用没用的东西…."></a>真的就是一些杂七杂八有用没用的东西….</h2><p>生成函数:</p><p>斐波那契数列：s(n)=f(n+2)-1</p><p>设一个数列$a_0,a_1,a_2….a_n…$</p><p>则其生成函数$g(x)=\sum_{i=0}^{\infty} a_i\times x^i$</p><p>卡特兰数前7项：1, 1, 2, 5, 14, 42, 132</p><p>$C_{n+1}=C_1C_n+C_2C_{n-1}+……+C_nC_1$</p><p>通项公式$h(n)=C(2n,n)-C(2n,n-1)$</p><p>递推公式$h(n)=h(n-1)<em>(4</em>n-2)/(n+1)$</p><p>多项式的逆：</p><p>$B=2B’-AB’^2 （mod x^n)$ 最高次数n项</p><p>$A\times B \equiv 1(mod x^n)$，如遇到mod n+1项则再添一项</p><p>$A \times B’ \equiv 1(mod x^{\lfloor n/2 \rfloor})​$</p><p>$A(1)^{-1}=a[0]^{p-2}$ </p><p>卷积的定义</p><p>$(f\ast g)(n)=\int_{-\infty}^{\infty} f(i)g(n-i)di$ 连续定义</p><p>$(f\ast g)(n)=\sum_{-\infty}^{\infty} f(i)g(n-i)$离散定义</p><p>连续卷积的例子：做馒头</p><p>楼下早点铺子生意太好了，供不应求，就买了一台机器，不断的生产馒头。<br>假设馒头的生产速度是 f(t) ，那么一天后生产出来的馒头总量为： $\int_0^{24} f(t)dt$<br>馒头生产出来之后，就会慢慢腐败，假设腐败函数为 g(t) ，比如，10个馒头，24小时会腐败：$10 \ast g(t)$<br>想想就知道，第一个小时生产出来的馒头，一天后会经历24小时的腐败，第二个小时生产出来的馒头，一天后会经历23小时的腐败。<br>如此，我们可以知道，一天后，馒头总共腐败了： $\int_0^{24} f(t)g(24-t) dt$</p><p>两个多项式相乘，卷积f(i)对应其次数为i的系数(比如分治fft利用了这个思想)</p><p>多项式开根：<a href="https://www.cnblogs.com/yoyoball/p/8724115.html" target="_blank" rel="noopener">较优博文推导</a></p><p>tips:大抵推导思路就是先指数除2的同余多项式，然后通过平方相乘等来使指数恢复，从而可以用倍增将复杂度降到一半.</p><script type="math/tex; mode=display">(\frac{G^2(x)+A(x)}{2G(x)})^2\equiv A(x)(mod\ x^{2n})</script><script type="math/tex; mode=display">B(x)=(\frac{G^2(x)+A(x)}{2G(x)})^2(mod x^{2n})</script><p>泰勒公式：</p><p>定义：泰勒公式是将一个在$x=x0$处具有n阶导数的函数f(x)利用关于$(x-x0)$的n次多项式来逼近函数的方法。</p><p><img src="https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D561/sign=143f6442fadeb48fff69a1d8c11e3aef/a686c9177f3e670920f8bbdc32c79f3df8dc551d.jpg" alt=""></p><p>等号后的多项式称为函数f(x)在x0处的泰勒展开式，剩余的Rn(x)是泰勒公式的余项，是$(x-x0)^n$的高阶无穷小。</p><p>还可以看作<img src="https://img-blog.csdn.net/20180602214026172" alt=""></p><p>常见泰勒展开：(一般取$x_0=0$得到)<br><img src="https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D240/sign=af5105143cfae6cd08b4ac653fb30f9e/4bed2e738bd4b31cbf7b70988ed6277f9e2ff84a.jpg" alt="">取$x_0=0$<br><img src="https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D216/sign=010037de72899e517c8e3d1574a6d990/f9198618367adab47e17ff6082d4b31c8601e4ca.jpg" alt=""> 取$x_0 = 0$<br><img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D235/sign=aa5a1804763e6709ba0042fc0ec69fb8/7a899e510fb30f244f7b0820c195d143ad4b032b.jpg" alt=""><br>$ln(1-x)=-x-\frac{x^2}{2}-\frac{x^3}{3}-…..$<br><img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D217/sign=6137b9730533874498c5287d660fd937/b3b7d0a20cf431ad5cfca41a4236acaf2edd98e3.jpg" alt=""><br><img src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D208/sign=f90c39d7be4543a9f11bfdcc26178a7b/03087bf40ad162d9b8c6853f18dfa9ec8a13cded.jpg" alt=""><br><img src="https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D403/sign=40cad0fa3001213fcb334fdc67e636f8/9358d109b3de9c821c821dac6581800a19d8432a.jpg" alt=""></p><p>多项式除法：</p><p>$A^R(x) = x^n A(\frac{1}{x})$</p><p>反转系数（随便举个栗子就行</p><script type="math/tex; mode=display">x^n A(\frac{1}{x}) = x^{n - m}D(\frac{1}{x}) x^mB(\frac{1}{x}) + x^{n - m + 1}x^{m - 1}R(\frac{1}{x})</script><script type="math/tex; mode=display">A^R(x) = D^R(x)B^R(x) + x^{n - m + 1}R^R(x)</script><p>因为$R^R(x)$的次数大于等于n-m+1，所以$mod x^{n-m+1}$可以全部消去(次数大于它的相当于乘了个倍数)</p><p>$A^R(x) = D^R(x)B^R(x) \pmod {x^{n - m + 1}}$</p><p>多项式取模：</p><p>$A(x)\equiv R(x)\pmod{B(x)}$</p><p>就是多项式除法搞余数</p><p>牛顿迭代法：</p><p>求函数f(x)的零点</p><p>方法：选一个$x_0$将f(x)泰勒展开，选取泰勒前几项来寻找$f(x)=0$的根.</p><p>通常只保留线性部分。</p><p>$f(x)=f(x_0)+f’(x_0)(x-x0)=0$</p><p>得到：$x=x0-\frac{f(x_0)}{f’(x_0)}$</p><p>多带几个$x_0$得到近似解</p><p>多项式牛顿迭代法：</p><p>问题：<strong>求函数g(f(x))的零点多项式f(x)</strong><br>解释：g(f(x))是一个关于多项式f(x)的函数，其中f(x)是变量。<br>即求一个多项式f(x)使得</p><script type="math/tex; mode=display">g(f(x))\equiv0\pmod{x^n}</script><p>e.g.</p><script type="math/tex; mode=display">g(f(x))=lnf(x)-A(x)</script><p>这个函数的零点为eA(x)eA(x)</p><script type="math/tex; mode=display">g(f(x))=f(x)-A^k(x)</script><p>这个函数的零点即Ak(x)</p><p>多项式牛顿迭代法用来解关于多项式方程</p><p><a href="https://blog.csdn.net/semiwaker/article/details/73251486" target="_blank" rel="noopener">留坑链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;真的就是一些杂七杂八有用没用的东西…&quot;&gt;&lt;a href=&quot;#真的就是一些杂七杂八有用没用的东西…&quot; class=&quot;headerlink&quot; title=&quot;真的就是一些杂七杂八有用没用的东西….&quot;&gt;&lt;/a&gt;真的就是一些杂七杂八有用没用的东西….&lt;/h2&gt;&lt;p&gt;生成函数
      
    
    </summary>
    
      <category term="省选" scheme="www.degage.xyz/categories/%E7%9C%81%E9%80%89/"/>
    
    
      <category term="数学" scheme="www.degage.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>多项式板子</title>
    <link href="www.degage.xyz/2019/01/16/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%9D%BF%E5%AD%90/"/>
    <id>www.degage.xyz/2019/01/16/多项式板子/</id>
    <published>2019-01-16T15:02:54.000Z</published>
    <updated>2019-01-17T02:46:46.738Z</updated>
    
    <content type="html"><![CDATA[<p>fft板子：</p><pre><code class="lang-c++">const double pi=acos(-1.0);struct cp{    double x,y;//x实部y虚部     cp operator+(const cp &amp;a){        return (cp){x+a.x,y+a.y};    }     cp operator-(const cp &amp;a){        return (cp){x-a.x,y-a.y};    }    cp operator*(const cp &amp;a){        return (cp){x*a.x-y*a.y,x*a.y+y*a.x};    }};cp x1[maxn*3],x2[maxn*3];//内存经常有不够的情况void change(cp y[],int len){    for(int i=1,j=len/2;i&lt;len-1;i++){        if(i&lt;j) swap(y[i],y[j]);        int k=len&gt;&gt;1;        while(j&gt;=k){            j-=k;            k&gt;&gt;=1;        }        if(j&lt;k) j+=k;    } }void fft(cp y[],int len,int on){    change(y,len);    for(int h=2;h&lt;=len;h&lt;&lt;=1){        cp base=(cp){cos(2*pi/h),sin(2*pi*on/h)};        for(int j=0;j&lt;len;j+=h){            cp w=(cp){1,0};            for(int k=j;k&lt;j+h/2;k++){                cp t1=y[k];                cp t2=w*y[k+h/2];                y[k]=t1+t2;                y[k+h/2]=t1-t2;                w=w*base;            }        }    }    if(on==-1){        for(int i=0;i&lt;len;i++) y[i].x/=len;    }}void init(){    int len=1;    while(len&lt;len1*2||len&lt;len2*2) len&lt;&lt;=1;    for(int i=0;i&lt;len1;i++) x1[i]=(cp){a[i],0};    for(int i=len1;i&lt;len;i++) x1[i]=(cp){0,0};    for(int i=0;i&lt;len2;i++) x2[i]=(cp){b[i],0};    for(int i=len2;i&lt;len;i++) x2[i]=(cp){0,0};    fft(x1,len,1);    fft(x2,len,1);    for(int i=0;i&lt;len;i++) x1[i]=x1[i]*x2[i];    fft(x1,len,-1);}</code></pre><p>ntt板子:</p><pre><code class="lang-c++">typedef long long ll;ll x1[maxn*3],x2[maxn*3];ll qkpow(ll t,int pos){    ll ans=1,base=t;    while(pos){        if(pos&amp;1) ans=ans*base%mod;        base=base*base%mod;        pos&gt;&gt;=1;    }    return ans;}void change(ll y[],int len){    for(int i=1,j=len/2;i&lt;len-1;i++){        if(i&lt;j) swap(y[i],y[j]);        int k=len&gt;&gt;1;        while(j&gt;=k){            j-=k;            k&gt;&gt;=1;        }        if(j&lt;k) j+=k;    }}void ntt(ll y[],int len,int on){    change(y,len);    for(int h=2;h&lt;=len;h&lt;&lt;=1){        ll base=qkpow(3,(mod-1)/h);//改动1         if(on==-1) base=qkpow(base,mod-2);//改动2        for(int j=0;j&lt;len;j+=h){            ll w=1;            for(int k=j;k&lt;j+h/2;k++){                ll t1=y[k];                ll t2=w*y[k+h/2]%mod;                y[k]=(t1+t2)%mod;                y[k+h/2]=(t1-t2+mod)%mod;                w=w*base%mod;            }        }    }    ll inv=qkpow(len,mod-2);    if(on==-1){        for(int i=0;i&lt;len;i++) y[i]=y[i]*inv%mod; //改动3     }}void init(){    int len=1;    while(len&lt;len1*2||len&lt;len2*2) len&lt;&lt;=1;    for(int i=0;i&lt;len1;i++) x1[i]=a[i];    for(int i=len1;i&lt;len;i++) x1[i]=0;    for(int i=0;i&lt;len2;i++) x2[i]=b[i];    for(int i=len2;i&lt;len;i++) x2[i]=0;    ntt(x1,len,1);ntt(x2,len,1);    for(int i=0;i&lt;len;i++) x1[i]=x1[i]*x2[i];    ntt(x1,len,-1); }</code></pre><p>多项式求逆：</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxlen 100005#define maxn maxlen*3 using namespace std;typedef long long ll;const ll mod=998244353;ll a[maxn],b[2][maxn],x1[maxn],x2[maxn];int n;ll qkpow(ll t,int pos){    ll ans=1,base=t;    while(pos){        if(pos&amp;1) ans=ans*base%mod;        base=base*base%mod;        pos&gt;&gt;=1;    }    return ans;} void change(ll y[],int len){    for(int i=1,j=len/2;i&lt;len-1;i++){        if(i&lt;j) swap(y[i],y[j]);        int k=len&gt;&gt;1;        while(j&gt;=k){            j-=k;k&gt;&gt;=1;        }        if(j&lt;k) j+=k;    }}void ntt(ll y[],int len,int on){    change(y,len);    for(int h=2;h&lt;=len;h&lt;&lt;=1){        ll base=qkpow(3,(mod-1)/h);//改动1         if(on==-1) base=qkpow(base,mod-2);//改动2        for(int j=0;j&lt;len;j+=h){            ll w=1;            for(int k=j;k&lt;j+h/2;k++){                ll t1=y[k];                ll t2=w*y[k+h/2]%mod;                y[k]=(t1+t2)%mod;                y[k+h/2]=(t1-t2+mod)%mod;                w=w*base%mod;            }        }    }    ll inv=qkpow(len,mod-2);    if(on==-1){        for(int i=0;i&lt;len;i++) y[i]=y[i]*inv%mod; //改动3     }}void mul(ll a[],ll b[],int len){    memset(x1,0,sizeof(x1));    memset(x2,0,sizeof(x2));    for(int i=0;i&lt;len/2;i++){        x1[i]=a[i];x2[i]=b[i];    }    ntt(x1,len,1);ntt(x2,len,1);    for(int i=0;i&lt;len;i++) x1[i]=x2[i]*x1[i]%mod;    ntt(x1,len,-1);    for(int i=0;i&lt;len;i++) a[i]=x1[i];}void init(){    scanf(&quot;%d&quot;,&amp;n);    for(int i=0;i&lt;n;i++) scanf(&quot;%lld&quot;,&amp;a[i]);    int cur=0;    b[cur][0]=qkpow(a[0],mod-2);    int bas=1,len=2;    while(bas&lt;=(n&lt;&lt;1)){        cur^=1;        memset(b[cur],0,sizeof(b[cur]));        for(int i=0;i&lt;bas;i++) b[cur][i]=(b[cur][i]+b[cur^1][i]*2ll)%mod;        mul(b[cur^1],b[cur^1],len);        mul(b[cur^1],a,len);        for(int i=0;i&lt;bas;i++) b[cur][i]=(b[cur][i]-b[cur^1][i]+mod)%mod;        bas&lt;&lt;=1;len&lt;&lt;=1;    }    for(int i=0;i&lt;n;i++) printf(&quot;%lld &quot;,b[cur][i]);}int main(){    init();    return 0;}</code></pre><p>多项式除法：</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxlen 100005#define maxn maxlen*3using namespace std;typedef long long ll;const ll mod=998244353;int n,m;ll f[maxn],g[maxn],d[maxn],r[maxn],gr[maxn],fr[maxn],t[2][maxn],x1[maxn],x2[maxn];ll qkpow(ll t,int pos){    ll ans=1,base=t;    while(pos){        if(pos&amp;1) ans=ans*base%mod;        base=base*base%mod;        pos&gt;&gt;=1;    }    return ans;} void change(ll y[],int len){    for(int i=1,j=len/2;i&lt;len-1;i++){        if(i&lt;j) swap(y[i],y[j]);        int k=len&gt;&gt;1;        while(j&gt;=k){            j-=k;k&gt;&gt;=1;        }        if(j&lt;k) j+=k;    }}void ntt(ll y[],int len,int on){    change(y,len);    for(int h=2;h&lt;=len;h&lt;&lt;=1){        ll base=qkpow(3,(mod-1)/h);//改动1         if(on==-1) base=qkpow(base,mod-2);//改动2        for(int j=0;j&lt;len;j+=h){            ll w=1;            for(int k=j;k&lt;j+h/2;k++){                ll t1=y[k];                ll t2=w*y[k+h/2]%mod;                y[k]=(t1+t2)%mod;                y[k+h/2]=(t1-t2+mod)%mod;                w=w*base%mod;            }        }    }    ll inv=qkpow(len,mod-2);    if(on==-1){        for(int i=0;i&lt;len;i++) y[i]=y[i]*inv%mod; //改动3     }}void mul(ll a[],ll b[],int len){    memset(x1,0,sizeof(x1));    memset(x2,0,sizeof(x2));    for(int i=0;i&lt;len/2;i++){        x1[i]=a[i];x2[i]=b[i];    }    ntt(x1,len,1);ntt(x2,len,1);    for(int i=0;i&lt;len;i++) x1[i]=x2[i]*x1[i]%mod;    ntt(x1,len,-1);    for(int i=0;i&lt;len;i++) a[i]=x1[i];}void mull(ll a[],ll b[],int len1){    int len=1;    while(len&lt;len1*2) len&lt;&lt;=1;    memset(x1,0,sizeof(x1));    memset(x2,0,sizeof(x2));    for(int i=0;i&lt;len1;i++) x1[i]=a[i];    for(int i=0;i&lt;len1;i++) x2[i]=b[i];    ntt(x1,len,1);ntt(x2,len,1);    for(int i=0;i&lt;len;i++) x1[i]=x2[i]*x1[i]%mod;    ntt(x1,len,-1);    for(int i=0;i&lt;len;i++) a[i]=x1[i];}int cur;void inv(ll a[],int tot){    cur=0;    t[cur][0]=qkpow(a[0],mod-2);    int bas=1,len=2;    while(bas&lt;=(tot&lt;&lt;1)){        cur^=1;        memset(t[cur],0,sizeof(t[cur]));        for(int i=0;i&lt;bas;i++) t[cur][i]=(t[cur][i]+t[cur^1][i]*2ll)%mod;        mul(t[cur^1],t[cur^1],len);        mul(t[cur^1],a,len);        for(int i=0;i&lt;bas;i++) t[cur][i]=(t[cur][i]-t[cur^1][i]+mod)%mod;        bas&lt;&lt;=1;len&lt;&lt;=1;    }}void init(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=0;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;f[i]),fr[n-i]=f[i];    for(int i=0;i&lt;=m;i++) scanf(&quot;%lld&quot;,&amp;g[i]),gr[m-i]=g[i];    inv(gr,n-m+1);//t[cur]现在为gr的逆元     mull(fr,t[cur],n+1);//fr变为dr    for(int i=0;i&lt;=n-m;i++) d[i]=fr[n-m-i];    for(int i=0;i&lt;=n-m;i++) printf(&quot;%lld &quot;,d[i]);    printf(&quot;\n&quot;);    mull(d,g,n+1);    for(int i=0;i&lt;=n;i++) r[i]=(f[i]-d[i]+mod)%mod;    for(int i=0;i&lt;=m-1;i++) printf(&quot;%lld &quot;,r[i]);   }int main(){    init();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;fft板子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-c++&quot;&gt;const double pi=acos(-1.0);
struct cp{
    double x,y;//x实部y虚部 
    cp operator+(const cp &amp;amp;a){
      
    
    </summary>
    
      <category term="省选" scheme="www.degage.xyz/categories/%E7%9C%81%E9%80%89/"/>
    
    
      <category term="多项式" scheme="www.degage.xyz/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
      <category term="ntt" scheme="www.degage.xyz/tags/ntt/"/>
    
      <category term="fft" scheme="www.degage.xyz/tags/fft/"/>
    
  </entry>
  
  <entry>
    <title>终</title>
    <link href="www.degage.xyz/2019/01/16/d1t1/"/>
    <id>www.degage.xyz/2019/01/16/d1t1/</id>
    <published>2019-01-16T14:18:14.000Z</published>
    <updated>2019-01-16T15:03:32.222Z</updated>
    
    <content type="html"><![CDATA[<p>首先题目中的贡献式子</p><script type="math/tex; mode=display">\frac{(A_i - A_j)B_iB_j}{2A_iA_j}</script><p>化简得$\frac{1}{2}(B_i\frac{B_j}{A_j}-B_j\frac{B_i}{A_i})$</p><p>发现可以看成一个向量叉积，转成面积，再观察题目中的特殊性质$B_i$先单调不降，再单调不增，看上去就联想到做一个凸包，使得面积最大（权值越大，得解</p><p>code:</p><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define maxn 100010using namespace std;struct point{    double x,y;    point operator-(const point &amp;a){        return (point){x-a.x,y-a.y};    }    point operator+(const point &amp;a){        return (point){x+a.x,y+a.y};    }    friend bool operator&lt;(point a,point b){        return a.x&lt;b.x||(a.x==b.x&amp;&amp;a.y&lt;b.y);    }}p[maxn],st[maxn];double operator^(point a,point b){    return a.x*b.y-b.x*a.y;}double dist(point a,point b){    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}int n,a[maxn],b[maxn];double calc(point a,point b,point c){    return (b-a)^(c-a);}void init(){    scanf(&quot;%d&quot;,&amp;n);    int sum=0;    for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),b[i]=(sum+=a[i]);    for(int i=1;i&lt;=n;i++){       p[i]=(point){(double)b[i],(double)b[i]*1.0/(double)a[i]};    }    sort(p+1,p+n+1);    int top=0;    for(int i=1;i&lt;=n;i++){        while(top&gt;1&amp;&amp;calc(st[top-1],st[top],p[i])&lt;=0) top--;//保证了单调性 后面=0的肯定比前面长         st[++top]=p[i];    }    int tmp=top;    for(int i=n-1;i&gt;=1;i--){        while(top&gt;tmp&amp;&amp;calc(st[top-1],st[top],p[i])&lt;=0) top--;        st[++top]=p[i];     }    double ans=0;    for(int i=2;i&lt;=top;i++){        ans+=(st[i-1]^st[i])/2;    }    printf(&quot;%.5f&quot;,ans);}int main(){    init();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先题目中的贡献式子&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{(A_i - A_j)B_iB_j}{2A_iA_j}&lt;/script&gt;&lt;p&gt;化简得$\frac{1}{2}(B_i\frac{B_j}{A_j}-B_j\
      
    
    </summary>
    
      <category term="省选" scheme="www.degage.xyz/categories/%E7%9C%81%E9%80%89/"/>
    
    
      <category term="计算几何" scheme="www.degage.xyz/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>计算几何初步</title>
    <link href="www.degage.xyz/2019/01/15/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%88%9D%E6%AD%A5/"/>
    <id>www.degage.xyz/2019/01/15/计算几何初步/</id>
    <published>2019-01-15T06:15:14.000Z</published>
    <updated>2019-01-16T13:29:24.274Z</updated>
    
    <content type="html"><![CDATA[<pre><code class="lang-c++">struct point{  double x,double y;  bool operator&lt;(const point &amp;a,const point &amp;b){    return a.x&lt;b.x||a.x==b.x&amp;&amp;a.y&lt;b.y;  }}</code></pre><p>利用点积求夹角：$acos(dot(a,b)/len(a)/len(b))$</p><p>叉积：$T=\vec{a} \times \vec{b}=-\vec{b} \times \vec{a} =X_aY_b-X_bY_a=\vline \vec{a} \vline \vline \vec{b} \vline sin(vec{a},vec{b})$</p><p>方向用右手定则判断，垂直平面</p><p>T=0: 两向量共线或反向<br>T&gt;0:b在a左侧<br>T&lt;0:b在a右侧<br><img src="https://i.loli.net/2019/01/15/5c3d307ad09be.png" alt=""></p><p>两向量所构平行四边形面积为叉积</p><p>旋转:<br>向量(x,y)绕坐标原点逆时针旋转$\theta$度<br>（用三垂直定理）</p><script type="math/tex; mode=display">x'=xcos\theta-ysin\theta</script><script type="math/tex; mode=display">y'=xsin\theta+ycos\theta</script><p>tips:<br>在读入时对每个点进行微小扰动<br>point a=(point){x+eps(),y+eps()};<br>或point a=rotate(a,1e-7)<br>以避免出现斜率不存在的情况</p><p>数据存储<br>1.直线/线段：斜截式或一般式<br>$Ax + By + C = 0 or y = kx + b$<br>2.圆：圆⼼坐标，圆的半径<br>$(x − a)^2 + (y − b)^2 = r2$<br>3.多边形：多边形上所有点坐标（推荐使用逆时针）<br>4.半平面：<br>$Ax + By + C ≥ 0$</p><p>公式定理：<br>1.正弦定理：AAS/ASA解三角形<br>2.余弦定理：SAS/SSS解三角形<br>3.质⼼：点集的加权平均数，就是好⼏个杠杆原理<br>$x_0=\frac{1}{N}\sum_{i=1}^N x_im_i,y_0=\frac{1}{N}\sum_{i=1}^N y_im_i$<br>三角形质⼼：中线交点<br>四边形质⼼：两个三角形质⼼的质⼼，权重为三角形面积<br>定比分点：杠杆原理坐标化<br>4.三角形面积:正弦定理，叉积，海伦公式:$p = (a + b + c)/2; S = \sqrt{p(p − a)(p − b)(p− c)}$</p><p>应用：<br>1.判折线段的拐向 a,b,c $\vec{ab} \times \vec{bc}$ 叉积大于0则左拐，否则右拐<br>2.判断点是否在线段上: a,b,c </p><p>（忘了按保存键就先咕咕咕了2333</p><p>C 语言里 double atan2(double y,double x) 返回的是原点至点(x,y)的方位角，即与 x 轴的夹角。</p><p>取值范围为 <img src="https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D47/sign=f817c2ad06e9390152028c3979ec2ec3/dcc451da81cb39db32331ddbd7160924aa18304f.jpg" alt="img"> ；</p><pre><code class="lang-c++">//得到两直线相交的交点point getpoint(line a,line b){     point aa=a.e-a.s,bb=b.e-b.s,cc=b.s-a.s;   double t=(bb^cc)/(aa^bb);   return (point){a.s+aa*t}; }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code class=&quot;lang-c++&quot;&gt;struct point{
  double x,double y;
  bool operator&amp;lt;(const point &amp;amp;a,const point &amp;amp;b){
    return a.x&amp;lt
      
    
    </summary>
    
      <category term="省选" scheme="www.degage.xyz/categories/%E7%9C%81%E9%80%89/"/>
    
    
      <category term="计算几何" scheme="www.degage.xyz/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>马拉车算法</title>
    <link href="www.degage.xyz/2019/01/13/%E9%A9%AC%E6%8B%89%E8%BD%A6/"/>
    <id>www.degage.xyz/2019/01/13/马拉车/</id>
    <published>2019-01-13T07:49:38.000Z</published>
    <updated>2019-01-16T13:29:31.432Z</updated>
    
    <content type="html"><![CDATA[<p>马拉车算法</p><pre><code class="lang-c++">int init(char *str){    int n=strlen(str);    for(int i=1,j=0;i&lt;=2*n;j++,i+=2)    {        s[i]=&#39;#&#39;;        s[i+1]=str[j];    }    s[0]=&#39;$&#39;;    s[2*n+1]=&#39;#&#39;;    s[2*n+2]=&#39;@&#39;;    s[2*n+3]=&#39;\n&#39;;    return 2*n+1;}</code></pre><pre><code class="lang-c++">void manacher(int n){    int mx=0,p=0;    for(int i=1;i&lt;=n;i++)    {        if(mx&gt;i)len[i]=min(mx-i,len[2*p-i]);        else len[i]=1;        while(s[i-len[i]]==s[i+len[i]])len[i]++;        if(len[i]+i&gt;mx)mx=len[i]+i,p=i;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;马拉车算法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-c++&quot;&gt;int init(char *str)
{
    int n=strlen(str);
    for(int i=1,j=0;i&amp;lt;=2*n;j++,i+=2)
    {
        
      
    
    </summary>
    
      <category term="省选" scheme="www.degage.xyz/categories/%E7%9C%81%E9%80%89/"/>
    
    
      <category term="马拉车算法" scheme="www.degage.xyz/tags/%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="www.degage.xyz/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>莫比乌斯反演未整理</title>
    <link href="www.degage.xyz/2019/01/02/58/"/>
    <id>www.degage.xyz/2019/01/02/58/</id>
    <published>2019-01-02T15:07:13.000Z</published>
    <updated>2019-01-16T13:29:00.580Z</updated>
    
    <content type="html"><![CDATA[<p>$\sigma(p^k)=k+1$<br>$phi(p^k)=p^{k-1}\times(p-1)$<br>$(phi\star1)(p^k)=p^k$</p><p>证明：</p><p>$1(i)=1$</p><p>$(phi\star1)(n)=\sum_{i|n}(phi(i)\times 1)$<br>$(phi\star1)(p^k)=(phi)(1)+(phi)(p^1)+….+(phi)(p^k)$<br>套公式$phi(p^k)=p^{k-1}\times(p-1)$<br>化为$(p-1)\times(p^0+p^1+…+p^{k-1})=p^k$</p><p>由于$(phi\star1)(p^k)$是积性函数，所以$phi\star1=id$</p><p>莫比乌斯反演：</p><p>定义<strong>1</strong>的逆是$\mu​$（莫比乌斯函数）</p><p>如果$g=f\star1$，就有$f=f\ \star 1\ \star\mu=g\ \star\mu$</p><p>所以$g(n)=\sum_{d|n}f(d)$则$f(n)=\sum_{d|n}g(d)\times\mu(n/d)$ （莫比乌斯反演定理）</p><p>另一个方向：$g(n)=\sum_{n|d}f(d)$ 则$f(n)=\sum_{n|d}g(d)\times \mu(d/n)$  其中d的取值范围为f的定义域</p><script type="math/tex; mode=display">\mu(n)=(-1)^{t}</script><p>当 <script type="math/tex">n=p_1\times p_2\times ...\times p_t且p_i各不相同</script></p><script type="math/tex; mode=display">else  \mu(i)=0</script><p>结论： $phi=\mu \star id$  </p><p>莫比乌斯函数常用的两个性质：</p><ul><li>对于任意正整数$n$，$\sum_{d|n}\mu(d)=[n=1]$。（$[n=1]$表示只有当$n=1$成立时，返回值为1；否则，值为0；(这个就是用μ是容斥系数的性质可以证明)<strong>(PS:这一条性质是莫比乌斯反演中最常用的)</strong></li><li>对于任意正整数n，$\sum_{d|n}\frac{\mu(d)}{d}=\frac{\phi(n)}{n}$。（这个性质很奇妙，它把欧拉函数和莫比乌斯函数结合起来）</li></ul><p>整除分块：</p><ul><li>对于每一个$\lfloor\frac{n}{i}\rfloor$我们可以通过打表<del>(或理性的证明)</del>可以发现：有许多$\lfloor\frac{n}{i}\rfloor$的值是一样的，而且它们呈一个块状分布；再通过打表之类的各种方法,我们惊喜的发现对于每一个值相同的块，它的最后一个数就是$n/(n/i)$。得出这个结论后，我们就可以做的$O(\sqrt{n})$处理了。<br>附一个整除分块的代码吧：</li></ul><pre><code class="lang-c++">for(int l=1,r;l&lt;=n;l=r+1){    r=n/(n/l);    ans+=(r-l+1)\star(n/l);}</code></pre><pre><code class="lang-c++">void get_mu(int n){    mu[1]=1;    for(int i=2;i&lt;=n;i++)    {        if(!vis[i]){prim[++cnt]=i;mu[i]=-1;}        for(int j=1;j&lt;=cnt&amp;&amp;prim[j]\stari&lt;=n;j++)        {            vis[prim[j]\stari]=1;            if(i%prim[j]==0)break;            else mu[i\starprim[j]]=-mu[i];        }    } }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;$\sigma(p^k)=k+1$&lt;br&gt;$phi(p^k)=p^{k-1}\times(p-1)$&lt;br&gt;$(phi\star1)(p^k)=p^k$&lt;/p&gt;
&lt;p&gt;证明：&lt;/p&gt;
&lt;p&gt;$1(i)=1$&lt;/p&gt;
&lt;p&gt;$(phi\star1)(n)=\sum_{i|n}
      
    
    </summary>
    
      <category term="省选" scheme="www.degage.xyz/categories/%E7%9C%81%E9%80%89/"/>
    
    
      <category term="数学" scheme="www.degage.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>祎隋</title>
    <link href="www.degage.xyz/2019/01/02/57/"/>
    <id>www.degage.xyz/2019/01/02/57/</id>
    <published>2019-01-02T15:07:03.000Z</published>
    <updated>2019-01-16T13:29:33.892Z</updated>
    
    <content type="html"><![CDATA[<h2 id="我愿…"><a href="#我愿…" class="headerlink" title="我愿…"></a>我愿…</h2><p><font face="等线">《祎隋》</font>&lt;/br&gt;  </p><p><font face="等线">我愿意是歌声不成形体</font>&lt;/br&gt;    </p><p><font face="等线">又发自于你</font> &lt;/br&gt;   </p><p><font face="等线">轻托你的灵动美丽</font>&lt;/br&gt;    </p><p><font face="等线">我愿意是烟火转瞬即逝</font>&lt;/br&gt;    </p><p><font face="等线">又引你一视</font>&lt;/br&gt;    </p><p><font face="等线">映亮你的天真欣喜</font>&lt;/br&gt;    </p><p><font face="等线">我愿意是微风不被注意</font>&lt;/br&gt;    </p><p><font face="等线">又轻拂着你</font>&lt;/br&gt;    </p><p><font face="等线">飘扬你的醉人芳香</font>&lt;/br&gt;    </p><p><font face="等线">我愿意是皎月独凌寒处</font>&lt;/br&gt;    </p><p><font face="等线">又照你一世</font>&lt;/br&gt;   </p><p><font face="等线">平稳你的夜夜美梦</font>&lt;/br&gt;   </p><p><font face="等线">我愿意是时光静默流淌</font> &lt;/br&gt;  </p><p><font face="等线">又伴你一生</font>&lt;/br&gt;    </p><p><font face="等线">承载你的所有过往</font>&lt;/br&gt;    </p><p><img src="https://i.loli.net/2019/01/02/5c2cd3d567883.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;我愿…&quot;&gt;&lt;a href=&quot;#我愿…&quot; class=&quot;headerlink&quot; title=&quot;我愿…&quot;&gt;&lt;/a&gt;我愿…&lt;/h2&gt;&lt;p&gt;&lt;font face=&quot;等线&quot;&gt;《祎隋》&lt;/font&gt;&amp;lt;/br&amp;gt;  &lt;/p&gt;
&lt;p&gt;&lt;font face=&quot;等线&quot;&gt;我愿
      
    
    </summary>
    
      <category term="杂诗" scheme="www.degage.xyz/categories/%E6%9D%82%E8%AF%97/"/>
    
    
      <category term="杂诗" scheme="www.degage.xyz/tags/%E6%9D%82%E8%AF%97/"/>
    
  </entry>
  
  <entry>
    <title>网络流</title>
    <link href="www.degage.xyz/2018/12/16/56/"/>
    <id>www.degage.xyz/2018/12/16/56/</id>
    <published>2018-12-16T15:18:54.000Z</published>
    <updated>2019-01-16T13:28:53.474Z</updated>
    
    <content type="html"><![CDATA[<p>首先主要是关于退流的理解，仔细理解这张图：<br><img src="https://i.loli.net/2018/12/16/5c166eaf19395.png" alt=""></p><p>然后上模板：<br>最大流<br>(1)EK:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxn 205#define maxm 2005using namespace std;int n,m,x,y,z;struct eage{    int from,to,next,cap,flow;}e[maxm&lt;&lt;1];int first[maxn],np=0;void add(int u,int v,int c){    e[++np]=(eage){u,v,first[u],c,0};    first[u]=np;    e[++np]=(eage){v,u,first[v],0,0};    first[v]=np;} int a[maxn],fa[maxn];int other(int i){    return i&amp;1?i+1:i-1;}int bfs(int s,int t){    queue&lt;int&gt;q;    memset(a,0,sizeof(a));    a[s]=0x3f3f3f3f;    fa[s]=0;    q.push(s);    while(!q.empty()){        int i=q.front();q.pop();        for(int p=first[i];p;p=e[p].next){            int j=e[p].to;            if(!a[j]&amp;&amp;e[p].cap&gt;e[p].flow){                a[j]=min(a[i],e[p].cap-e[p].flow);                fa[j]=p;                q.push(j);                if(j==t) return a[j];            }        }    }    return 0;//如果没有找到任意一条 }int ek(){    int maxflow=0;    while(1){        int del=bfs(1,n);        if(del==0) break;        maxflow+=del;        int f=fa[n];        while(f){            e[f].flow+=del;            e[other(f)].flow-=del;            f=fa[e[f].from];        }    }    return maxflow;}void init(){     scanf(&quot;%d%d&quot;,&amp;m,&amp;n);     for(int i=1;i&lt;=m;i++){         scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);         add(x,y,z);     }         printf(&quot;%d&quot;,ek());}int main(){    init();    return 0;}</code></pre><p>(2)Dinic</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxn 205#define maxm 2005#define inf 0x3f3f3f3fusing namespace std;struct eage{    int from,to,next,cap,flow;}e[maxm&lt;&lt;1];int first[maxn],np=0;void add(int u,int v,int c){    e[++np]=(eage){u,v,first[u],c,0};    first[u]=np;    e[++np]=(eage){v,u,first[v],0,0};    first[v]=np;}int n,m,x,y,z,s,t;bool vis[maxn];int other(int i){    return i&amp;1?i+1:i-1;}int dfs(int i,int mn){    vis[i]=1;    if(i==t) return mn;    for(int p=first[i];p;p=e[p].next){        int j=e[p].to;        int dis=e[p].cap-e[p].flow;        if(vis[j]||dis==0) continue;        int del=dfs(j,min(mn,dis));        if(del==0) continue;        e[p].flow+=del;        e[other(p)].flow-=del;        return del;     }    return 0;}int ek(){    int maxflow=0;    while(1){        memset(vis,0,sizeof(vis));        int del=dfs(s,inf);        if(del==0) break;        maxflow+=del;    }        return maxflow;}void init(){    scanf(&quot;%d%d&quot;,&amp;m,&amp;n);    s=1,t=n;    for(int i=1;i&lt;=m;i++){        scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);        add(x,y,z);    }    printf(&quot;%d&quot;,ek());}int main(){    init();    return 0;}</code></pre><p>费用流:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxn 305#define maxm 3005#define inf 0x3f3f3f3fusing namespace std;struct eage{    int from,to,next,cap,flow,w;}e[maxm&lt;&lt;1];int first[maxn],np=0;void add(int u,int v,int c,int w){    e[++np]=(eage){u,v,first[u],c,0,w};    first[u]=np;    e[++np]=(eage){v,u,first[v],0,0,-w};    first[v]=np;}int other(int i){    return i&amp;1?i+1:i-1;}int n,m,x,y,z,w,dist[maxn],a[maxn],fa[maxn];bool vis[maxn];int spfa(){    queue&lt;int&gt;q;    memset(vis,0,sizeof(vis));    memset(a,0,sizeof(a));    a[1]=inf;    fa[1]=0;q.push(1);    memset(dist,0x3f,sizeof(dist));    dist[1]=0;    while(!q.empty()){        int i=q.front();q.pop();        vis[i]=0;        for(int p=first[i];p;p=e[p].next){            int j=e[p].to;            if(e[p].cap&gt;e[p].flow)            if(dist[j]&gt;dist[i]+e[p].w){                dist[j]=dist[i]+e[p].w;                a[j]=min(a[i],e[p].cap-e[p].flow);                fa[j]=p;                if(!vis[j]) q.push(j),vis[j]=1;            }        }    }    return a[n];}void ek(){    int maxflow=0;    int cost=0;    while(spfa()){        maxflow+=a[n];        cost+=dist[n]*a[n];        int f=fa[n];        while(f){            e[f].flow+=a[n];            e[other(f)].flow-=a[n];            f=fa[e[f].from];        }    }    printf(&quot;%d %d&quot;,maxflow,cost);}void init(){    scanf(&quot;%d%d&quot;,&amp;m,&amp;n);    for(int i=1;i&lt;=m;i++){        scanf(&quot;%d%d%d%d&quot;,&amp;x,&amp;y,&amp;z,&amp;w);        add(x,y,z,w);    }    ek();}int main(){    init();    return 0;}</code></pre><p>二分图:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxn 405#define maxm 40005#define inf 0x3f3f3f3fusing namespace std;struct eage{    int from,to,next,cap,flow;}e[maxm&lt;&lt;1];int first[maxn],np=0;void add(int u,int v,int c){    e[++np]=(eage){u,v,first[u],c,0};    first[u]=np;    e[++np]=(eage){v,u,first[v],0,0};    first[v]=np;}int other(int i){    return i&amp;1?i+1:i-1;}int n,m,x,y,s,t;bool vis[maxn];int dfs(int i,int mn){    vis[i]=1;    if(i==t) return mn;    for(int p=first[i];p;p=e[p].next){        int j=e[p].to,dis=e[p].cap-e[p].flow;        if(vis[j]||dis==0) continue;        int del=dfs(j,min(mn,dis));        if(del==0) continue;        e[p].flow+=del;        e[other(p)].flow-=del;        return del;    }    return 0;}void ek(){    int maxflow=0;    while(1){        memset(vis,0,sizeof(vis));        int del=dfs(s,inf);        if(del==0) break;        maxflow+=del;     }    printf(&quot;%d&quot;,maxflow);}void init(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    s=401,t=402;    for(int i=1;i&lt;=n;i++){        scanf(&quot;%d&quot;,&amp;y);        for(int j=1;j&lt;=y;j++){            scanf(&quot;%d&quot;,&amp;x);            add(i,x+n,1);        }        add(s,i,1);    }    for(int i=1;i&lt;=m;i++) add(i+n,t,1);//最多只出去一个，保证两边不连到一个点上     ek();}int main(){    init();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先主要是关于退流的理解，仔细理解这张图：&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2018/12/16/5c166eaf19395.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后上模板：&lt;br&gt;最大流&lt;br&gt;(1)EK:&lt;/p&gt;
&lt;pre&gt;&lt;code
      
    
    </summary>
    
      <category term="省选" scheme="www.degage.xyz/categories/%E7%9C%81%E9%80%89/"/>
    
    
      <category term="网络流" scheme="www.degage.xyz/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>划分物品</title>
    <link href="www.degage.xyz/2018/11/08/55/"/>
    <id>www.degage.xyz/2018/11/08/55/</id>
    <published>2018-11-08T08:33:39.000Z</published>
    <updated>2019-01-16T13:28:49.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>你有 n 个物品，第 i 个物品的重量是$w_i$。</p><p>你需要把这些物品划分成若干组，满足每一组的重量和都是质数。</p><p>两个方案是不同的当且仅当存在两个物品 i 和 j，在第一个方案里他们处在同一组，第二个方案里他们不处在同一组。（对998244353取模）</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>$n&lt;=16,w_i&lt;=100$</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>10<br>2 3 4 5 6 7 8 9 10 11</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>1177</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>一道经典的状压dp题，我们可以用$sum_i$来表示状态为i的集合所表示的重量和(类似思路也可以搞其他的)设$dp_i$表示状态为i的集合所能容纳的方案数，那么$dp_i=\sum_{(j属于i且j为素数)}dp_{i-j}$。显然这样是不正确的，因为有重复的，所以我们便固定一个x属于i，然后可以正确dp。</p><p>上代码:</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxv 1605using namespace std;typedef long long ll;const ll mod=998244353;ll dp[1&lt;&lt;18];int sum[1&lt;&lt;18];int n,w[20];bool vis[maxv];int prime[maxv&gt;&gt;1],top=0;void ready(){    vis[0]=vis[1]=1;    for(int i=1;i&lt;=maxv-5;i++){        if(!vis[i]) prime[++top]=i;        for(int j=1;j&lt;=top&amp;&amp;prime[j]*i&lt;=maxv-5;j++){            vis[prime[j]*i]=1;            if(i%prime[j]==0) break;        }    }}void init(){    scanf(&quot;%d&quot;,&amp;n);    int all=(1&lt;&lt;n)-1;    for(int i=1;i&lt;=n;i++){    scanf(&quot;%d&quot;,&amp;w[i]);sum[1&lt;&lt;i-1]=w[i];        }    dp[0]=1;    for(int i=1;i&lt;=all;i++)    for(int j=1;j&lt;=n;j++){        if((i|(1&lt;&lt;j-1))!=i) continue;        if((1&lt;&lt;j-1)==i) continue;        sum[i]=sum[i-(1&lt;&lt;j-1)]+w[j];//可用如此方式来记录每个状态代表的值     }    for(int i=1;i&lt;=all;i++){        int x=i&amp;(-i);//固定一个 注意i&amp;-i的值是1&lt;&lt;后的         for(int j=i;j;j=i&amp;(j-1)){            if((x|j)!=j) continue;            if(vis[sum[j]]) continue;            dp[i]=(dp[i]+dp[i-j])%mod;        }     }    printf(&quot;%lld&quot;,dp[all]);}int main(){    ready();    init();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;你有 n 个物品，第 i 个物品的重量是$w_i$。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="正睿" scheme="www.degage.xyz/categories/%E6%AD%A3%E7%9D%BF/"/>
    
    
      <category term="dp" scheme="www.degage.xyz/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>计数</title>
    <link href="www.degage.xyz/2018/11/07/54/"/>
    <id>www.degage.xyz/2018/11/07/54/</id>
    <published>2018-11-07T13:04:13.000Z</published>
    <updated>2019-01-16T13:28:45.547Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>既然是萌萌哒 visit_world 的比赛，那必然会有一道计数题啦！<br>考虑一个N个节点的二叉树，它的节点被标上了$1-N$的编号. 并且，编号为i的节点在二叉树的前序遍历中恰好是第i个出现.<br>我们定义$A_i$表示编号为i的点在二叉树的中序遍历中出现的位置.<br>现在，给出m个限制条件，第i个限制条件给出了$u_i,v_i$,表示$A_{u_i}&lt;A_{v_i}$，也即中序遍历中$u_i$在$v_i$之前出现.<br>你需要计算有多少种不同的带标号二叉树满足上述全部限制条件，答案对$1e9+7$取模.</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>$T&lt;=5,N&lt;=400,M&lt;=10^3$</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>3 5<br>0<br>3 2<br>1 2<br>2 3<br>3 3<br>1 2<br>2 3<br>3 1</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>42<br>1<br>0</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先M=0可以看出是个卡特兰数。<br>然后我们知道先序遍历，根据其特性来枚举出合法的中序遍历，每次找到一个根，枚举它左边有多少个，右边有多少个，然后判断是否合法，合法的话方案数乘起来累加。<br>见图：<br><img src="https://i.loli.net/2018/11/07/5be3017335edf.png" alt=""><br>首先枚举后有三个大小关系：根的中序遍历大于任意左子树的，任意右子树的大于根的，任意右子树的大于左子树的。<br>然后发现check是$n^2$的，而dp又是$n^3$的，这样就$n^5$了，<font color="red">这里有个很nice的思路</font>，用二维前缀和优化，如果要求i的中序遍历小于j的，那么$a[i][j]=1$，然后sum求一波二维前缀和，对于$sum[i][j]$其含义便是1-i中小于1-j中的个数和，那么我们询问$[l1,r1]小于[l2,r2]$就为$sum[r1,r2]-sum[l1-1,r2]-sum[r1,l2-1]+sum[l1-1,l2-1]$然后就优化成$O(1)$的check了，整体复杂度就被优化至了$O(n^3)$，真的TQL%%%</p><p>上代码：</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxn 405using namespace std;typedef long long ll;const ll mod=1e9+7;int a[maxn][maxn],n,t,m,x,y,sum[maxn][maxn];ll dp[maxn][maxn];int calc(int l1,int r1,int l2,int r2){//如果返回值说l1~r1有小于l2~r2的     return sum[r1][r2]-sum[l1-1][r2]-sum[r1][l2-1]+sum[l1-1][l2-1];}bool check(int now,int l1,int r1,int l2,int r2){    if(calc(l2,r2,l1,r1))return false;    if(calc(now,now,l1,r1))return false;    if(calc(l2,r2,now,now))return false;    return true;}void init(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    memset(a,0,sizeof(a));    memset(sum,0,sizeof(sum));    memset(dp,0,sizeof(dp));    for(int i=1;i&lt;=m;i++){        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);        a[x][y]=1;    }     for(int i=1;i&lt;=n;i++)    for(int j=1;j&lt;=n;j++){        sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j];    }    for(int i=1;i&lt;=n;i++) dp[i][i]=1;    for(int len=1;len&lt;=n;len++)    for(int i=1;i&lt;=n;i++){        int j=i+len;        if(j&gt;n) break;        //其实这余下三坨是可以归在一起算的         if(!calc(i,i,i+1,j))dp[i][j]=(dp[i][j]+dp[i+1][j])%mod;//如果没有限制         if(!calc(i+1,j,i,i))dp[i][j]=(dp[i][j]+dp[i+1][j])%mod;        for(int k=i+1;k&lt;j;k++){            if(check(i,i+1,k,k+1,j)) dp[i][j]=(dp[i][j]+dp[i+1][k]*dp[k+1][j])%mod;        }     }         printf(&quot;%lld\n&quot;,dp[1][n]);} int main(){    scanf(&quot;%d&quot;,&amp;t);    for(int i=1;i&lt;=t;i++)    init();        return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;既然是萌萌哒 visit_world 的比赛，那必然会有一道计数题啦
      
    
    </summary>
    
      <category term="正睿" scheme="www.degage.xyz/categories/%E6%AD%A3%E7%9D%BF/"/>
    
    
      <category term="dp" scheme="www.degage.xyz/tags/dp/"/>
    
      <category term="二维前缀和" scheme="www.degage.xyz/tags/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>购物</title>
    <link href="www.degage.xyz/2018/11/07/53/"/>
    <id>www.degage.xyz/2018/11/07/53/</id>
    <published>2018-11-07T13:04:04.000Z</published>
    <updated>2019-01-16T13:28:41.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>visit_world 有一个商店，商店里卖 个商品，第 i 个的价格为$a_i$<br>我们称一个正整数 K 是美妙的，当且仅当我们可以在商店里选购若干个商品，使得价格之和落在区间$ [K, 2K]$ 中。<br>问：有多少个美妙的数。</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>$N&lt;=10^5,a_i&lt;=10^9$<br>时空限制：1s / 512MB</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>3<br>1 2 3</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>6</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>我们将$a_i$从小到大排序，对于前i个，假设它们和为sum,那么k能去到的范围即为$[\frac{sum+1}{2},sum]$，那么对于$\frac{sum-1}{2}$开始是覆盖的不到，我们便会减去一些来使覆盖，所以肯定是逐渐拿小的来，到最后剩下$a_i$，那么设前i-1个的和为sum’，则$[sum’+1,\frac{a_i-1}{2}]$是覆盖不到，所以最终把这些空隙减掉即可。</p><p>上代码：</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxn 100005using namespace std;typedef long long ll;int n;ll a[maxn];void init(){    scanf(&quot;%d&quot;,&amp;n);    for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]);    ll sum=0,del=0;    sort(a+1,a+n+1);    for(int i=1;i&lt;=n;i++){        del+=max((a[i]+1)/2-sum-1,0ll);        sum+=a[i];     }    printf(&quot;%lld&quot;,sum-del);}int main(){    init();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;visit_world 有一个商店，商店里卖 个商品，第 i 个的价
      
    
    </summary>
    
      <category term="正睿" scheme="www.degage.xyz/categories/%E6%AD%A3%E7%9D%BF/"/>
    
    
      <category term="数学" scheme="www.degage.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>physics</title>
    <link href="www.degage.xyz/2018/11/06/52/"/>
    <id>www.degage.xyz/2018/11/06/52/</id>
    <published>2018-11-06T11:34:13.000Z</published>
    <updated>2019-01-16T13:28:38.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>一个n行m列的矩阵，每个为0或1，如果一个边长为K的正方形包含的所有数都为1，那么会形成一个强度为K的电场，有q次询问，每次询问会把1个1变做0，求每次询问的最大电场强度值。</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>$n,m&lt;=2 \ast 10^3 ,1&lt;=q&lt;=10^4$</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>5 5 5<br>+-+++<br>+++++<br>+++++<br>+++++<br>++++-<br>1 5<br>2 2<br>5 3<br>2 3<br>1 1</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>4<br>3<br>3<br>2<br>2</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先会想到用单调栈$n^2$计算最大1正方形，然后发现每改一个只会影响一列的up数组，然后发现如果答案递减不好维护，那么正难则反，我们先将所有的改动加进来，然后倒序考虑所有操作。<br>那么答案是会依次递增的，我们维护一个up和一个down数组来记录每个格子向上和向下最多多少格，对于每次询问，O(N)更新那一列的up和down，再O(n)单调队列扫一遍那一行，类似滑动窗口的来查询长度为k的序列的$min(up_i)和min(down_i)$，看它们加起来是否大于等于k，如果满足继续扩大k，否则标记答案。</p><p>上代码：</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxn 2005 #define maxq 10005#define inf 0x3f3f3f3fusing namespace std;struct node{    int x,y,ans;}nd[maxq];int n,m,a[maxn][maxn],q,st[maxn],top=0,up[maxn][maxn],down[maxn][maxn];char s[maxn];int maxx=0;void calc(){    for(int j=1;j&lt;=m;j++)    for(int i=1;i&lt;=n;i++) up[i][j]=(a[i][j]==0?0:up[i-1][j]+1);     for(int j=1;j&lt;=m;j++)    for(int i=n;i&gt;=1;i--) down[i][j]=(a[i][j]==0?0:down[i+1][j]+1);    st[0]=0;    for(int i=1;i&lt;=n;i++){        top=0;        for(int j=1;j&lt;=m;j++){            while(top&amp;&amp;up[i][j]&lt;=up[i][st[top]]){//单调栈                 maxx=max(maxx,min(up[i][st[top]],j-1-st[top-1]));                top--;            }            st[++top]=j;        }        while(top){            maxx=max(maxx,min(up[i][st[top]],m-st[top-1]));            top--;        }    }}void calcc(int j){    for(int i=1;i&lt;=n;i++) up[i][j]=(a[i][j]==0?0:up[i-1][j]+1);     for(int i=n;i&gt;=1;i--) down[i][j]=(a[i][j]==0?0:down[i+1][j]+1);}int q1[maxn],q2[maxn],front1,front2,rear1,rear2;bool check(int i,int len){    if(len&gt;min(n,m)) return false;    front1=front2=rear1=rear2=0;    for(int j=1;j&lt;=m;j++){        while(front1&lt;rear1&amp;&amp;j-q1[front1]&gt;=len)front1++;        while(front1&lt;rear1&amp;&amp;up[i][q1[rear1-1]]&gt;=up[i][j])rear1--;        q1[rear1++]=j;        while(front2&lt;rear2&amp;&amp;j-q2[front2]&gt;=len)front2++;        while(front2&lt;rear2&amp;&amp;down[i][q2[rear2-1]]&gt;=down[i][j])rear2--;        q2[rear2++]=j;        if(j&gt;=len&amp;&amp;up[i][q1[front1]]+down[i][q2[front2]]-1&gt;=len)return true;    }    return false;}void init(){    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q);    for(int i=1;i&lt;=n;i++){        scanf(&quot;%s&quot;,s+1);        for(int j=1;j&lt;=m;j++) a[i][j]=(s[j]==&#39;+&#39;?1:0);    }    for(int i=1;i&lt;=q;i++){        scanf(&quot;%d%d&quot;,&amp;nd[i].x,&amp;nd[i].y);a[nd[i].x][nd[i].y]=0;    }    calc();    nd[q].ans=maxx;    for(int i=q;i&gt;=2;i--){        a[nd[i].x][nd[i].y]=1;        calcc(nd[i].y);//更新         nd[i-1].ans=nd[i].ans;        while(check(nd[i].x,maxx+1)) maxx++,nd[i-1].ans=maxx;//只改动了这一行     }    for(int i=1;i&lt;=q;i++) printf(&quot;%d\n&quot;,nd[i].ans); }int main(){    init();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;一个n行m列的矩阵，每个为0或1，如果一个边长为K的正方形包含的所有
      
    
    </summary>
    
      <category term="正睿" scheme="www.degage.xyz/categories/%E6%AD%A3%E7%9D%BF/"/>
    
    
      <category term="正难则反" scheme="www.degage.xyz/tags/%E6%AD%A3%E9%9A%BE%E5%88%99%E5%8F%8D/"/>
    
      <category term="单调队列" scheme="www.degage.xyz/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
      <category term="单调栈" scheme="www.degage.xyz/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>Chinese</title>
    <link href="www.degage.xyz/2018/11/06/51/"/>
    <id>www.degage.xyz/2018/11/06/51/</id>
    <published>2018-11-06T11:34:05.000Z</published>
    <updated>2019-01-16T13:28:34.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>一个n行m列的矩阵，每个格子可以填一个$1~k$的整数，矩阵中的一个格子为炼字当且仅当其值比其所在行和列的其它数都大，定义一个矩阵的精彩度为炼字的个数。设$f_i$为精彩度为i的方案数，显然:$\sum_{i=0}^{n \ast m} f_i=k^{n \ast m}$。现在你需要求出$\sum_{i=0}^{n \ast m} f_i \ast i mod (1e9+7)$</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>$n,m&lt;=10^9,k&lt;=10^6$</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>2 2 2</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>8</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先，对$\sum_{i=0}^{n \ast m} f_i \ast i$的理解为所有方案中炼字的个数和，那么考虑对每个格子单独计算贡献，如图：<br><img src="https://i.loli.net/2018/11/06/5be18a56030c0.jpg" alt=""><br>那么每个格子产生的贡献即为</p><script type="math/tex; mode=display">\sum_{i=1}^{k} k^{(n-1) \ast (m-1)} \ast (i-1)^{n-1} \ast (i-1)^{m-1}</script><p>因为相应性质，我们只要再乘上$n \ast m$即为最终答案。</p><p>上代码：</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod=1e9+7;ll n,m,k;ll qkpow(ll t,ll pos){    ll ans=1,base=t;    while(pos){        if(pos&amp;1) ans=ans*base%mod;        base=base*base%mod;        pos&gt;&gt;=1;    }    return ans;}void init(){    scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;k);    ll t1=qkpow(k,(n-1)*(m-1));     ll ans=0;    for(int i=1;i&lt;k;i++) ans=(ans+qkpow(i,n-1)*qkpow(i,m-1)%mod*t1%mod)%mod;    ans=ans*n%mod*m%mod;    printf(&quot;%lld&quot;,ans);}int main(){    init();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;一个n行m列的矩阵，每个格子可以填一个$1~k$的整数，矩阵中的一个
      
    
    </summary>
    
      <category term="正睿" scheme="www.degage.xyz/categories/%E6%AD%A3%E7%9D%BF/"/>
    
    
      <category term="数学" scheme="www.degage.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Certificate</title>
    <link href="www.degage.xyz/2018/11/05/50/"/>
    <id>www.degage.xyz/2018/11/05/50/</id>
    <published>2018-11-05T09:33:25.000Z</published>
    <updated>2019-01-16T13:28:28.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>已知有$N(N≤14)$个变量，变量取值0或1。<br>已知$f(0,0,⋯,0)，⋯，f(1,1,⋯,1)$的函数值。<br>对于每种输入$x=(x_0,x_1,⋯,x_n)$，求最少需要知道几个变量的值即可确定函数值。<br>举个例子：假设有两个变量，函数$f(a,b)=a\&amp;b$，那么对于$f(x)=0$，我们只要知道其中一个变量为0即可确定函数值为0，否则我们需要知道两个变量是否都为1，才能确定函数值为1。</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>可以先$2^N$枚举选出的t个关键问题，再$2^N$判断，复杂度为$4^N$，可以勉强卡过。</p><p>上代码：</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxn 16using namespace std;int ans[1&lt;&lt;maxn],check[1&lt;&lt;maxn],n,a[1&lt;&lt;maxn];char s[1&lt;&lt;maxn];int calc(int x){    int cnt=0;    while(x){        cnt++;        x-=x&amp;(-x);    }    return cnt;}void init(){    scanf(&quot;%d&quot;,&amp;n);    int all=1&lt;&lt;n;    scanf(&quot;%s&quot;,s);    memset(ans,0x3f,sizeof(ans));    for(int i=0;s[i];i++) a[i]=(s[i]==&#39;0&#39;?0:1);    for(int i=0;i&lt;all;i++){        memset(check,-1,sizeof(check));        for(int j=0;j&lt;all;j++){            if(check[i&amp;j]==-1) check[i&amp;j]=a[j];            else if(check[i&amp;j]!=a[j]) check[i&amp;j]=2;        }        int len=calc(i);        for(int j=0;j&lt;all;j++) if(check[i&amp;j]==a[j]) ans[j]=min(ans[j],len);    }     for(int i=0;i&lt;all;i++) printf(&quot;%d &quot;,ans[i]);}int main(){    init();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;已知有$N(N≤14)$个变量，变量取值0或1。&lt;br&gt;已知$f(0
      
    
    </summary>
    
      <category term="正睿" scheme="www.degage.xyz/categories/%E6%AD%A3%E7%9D%BF/"/>
    
    
      <category term="枚举" scheme="www.degage.xyz/tags/%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>树的距离</title>
    <link href="www.degage.xyz/2018/11/03/48/"/>
    <id>www.degage.xyz/2018/11/03/48/</id>
    <published>2018-11-03T02:25:50.000Z</published>
    <updated>2019-01-16T13:28:24.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>开始有一个空的集合S，进行Q次操作：</p><p>1.插入一个数x（如果已存在就忽略）<br>2.删除一个数x（如果不存在就忽略）<br>3.询问点集中数与x的最短距离<br>定义两个数a,b的距离为，每次将a乘一个质数或除以一个质数因子，使a变成b的最小步数。$（Q≤50000,x≤1000000，时限2秒）$</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>对于两个数A,B:</p><script type="math/tex; mode=display">A=p_1^{a_1}+p_2^{a_2}+.....p_n^{a_n}</script><script type="math/tex; mode=display">B=p_1^{b_1}+p_2^{b_2}+.....p_n^{b_n}</script><p>(如果某些$p_i$，相应的次数为0)<br>那么A,B的距离即为</p><script type="math/tex; mode=display">\sum_{i=1}^n abs(a_i-b_i)</script><p>设gcd(A,B)为g，那么dis可以化为$num(\frac a{g})+num(\frac b{g})$，其中num(x)表示x包含的质数个数。<br>然后我们发现枚举B的话复杂度无法承受，那么转过来枚举A的因数来作为GCD，然后统计相应步数即可。当然这里可以用set或map来维护以谁为gcd的最小B.</p><p>上代码：</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxn 1000005using namespace std;int prime[maxn&gt;&gt;1],top=0,s[maxn];typedef long long ll;bool vis[maxn];void ready(){    vis[0]=vis[1]=1;    for(int i=2;i&lt;=maxn-5;i++){        if(!vis[i]) prime[++top]=i,s[i]=1;        for(int j=1;j&lt;=top&amp;&amp;i*prime[j]&lt;=maxn-5;j++){            vis[prime[j]*i]=1;s[prime[j]*i]=s[i]+1;            if(i%prime[j]==0) break;         }    }}int q,op,x;int c[maxn][20];void init(){    scanf(&quot;%d&quot;,&amp;q);    memset(vis,0,sizeof(vis));    for(int i=1;i&lt;=q;i++){        scanf(&quot;%d%d&quot;,&amp;op,&amp;x);        if(op==1&amp;&amp;!vis[x]){            vis[x]=1;            for(int j=1;1ll*j*j&lt;=x;j++) if(x%j==0){                 c[j][s[x]-s[j]]++;                c[x/j][s[j]]++;            }        }        if(op==2&amp;&amp;vis[x]){            vis[x]=0;            for(int j=1;1ll*j*j&lt;=x;j++) if(x%j==0){                c[j][s[x]-s[j]]--;                c[x/j][s[j]]--;            }        }         if(op==3){            int ans=1e9;            for(int j=1;1ll*j*j&lt;=x;j++) if(x%j==0){                for(int k=0;k&lt;20;k++) if(c[j][k]) ans=min(ans,k+s[x]-s[j]);                for(int k=0;k&lt;20;k++) if(c[x/j][k]) ans=min(ans,k+s[j]);            }            if(ans==1e9) printf(&quot;-1\n&quot;);            else printf(&quot;%d\n&quot;,ans);        }    }}int main(){    ready();    init();    return 0;}</code></pre><p>滔滔的map代码：</p><pre><code class="lang-ruby">#include&lt;map&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000000+5,inf=0x3f3f3f3f;int n,f[maxn];bool vis[maxn];vector&lt;int&gt;primes;map&lt;int,int&gt;mp[maxn];void init(){    for(int i=2;i&lt;=maxn-5;i++){        if(!f[i])f[i]=1,primes.push_back(i);        for(int k=0;k&lt;primes.size()&amp;&amp;i*primes[k]&lt;=maxn-5;k++){            f[i*primes[k]]=f[i]+1;            if(i%primes[k]==0)break;        }    }}void ins(int x){    if(vis[x])return;vis[x]=1;    int sq=sqrt(x+0.5);    for(int i=1;i&lt;=sq;i++){        if(x%i==0)mp[i][f[x]]++;        if(x%i==0&amp;&amp;i*i!=x)mp[x/i][f[x]]++;    }}void del(int x){    if(!vis[x])return;vis[x]=0;    int sq=sqrt(x+0.5);    for(int i=1;i&lt;=sq;i++){        if(x%i==0)if(--mp[i][f[x]]==0)mp[i].erase(f[x]);        if(x%i==0&amp;&amp;i*i!=x)if(--mp[x/i][f[x]]==0)mp[x/i].erase(f[x]);    }}int Find(int i){    if(!mp[i].size())return inf*2;    return mp[i].begin()-&gt;first;}void solve(int x){    int sq=sqrt(x+0.5),ans=inf;    for(int i=1;i&lt;=sq;i++){        if(x%i==0)ans=min(ans,f[x]+Find(i)-2*f[i]);        if(x%i==0&amp;&amp;i*i!=x)ans=min(ans,f[x]+Find(x/i)-2*f[x/i]);    }    if(ans&gt;=inf)printf(&quot;-1\n&quot;);    else printf(&quot;%d\n&quot;,ans);}int main(){    init();    scanf(&quot;%d&quot;,&amp;n);    for(int i=1,op,x;i&lt;=n;i++){        scanf(&quot;%d%d&quot;,&amp;op,&amp;x);        if(op==1)ins(x);        if(op==2)del(x);        if(op==3)solve(x);    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;开始有一个空的集合S，进行Q次操作：&lt;/p&gt;
&lt;p&gt;1.插入一个数x
      
    
    </summary>
    
      <category term="正睿" scheme="www.degage.xyz/categories/%E6%AD%A3%E7%9D%BF/"/>
    
    
      <category term="数学" scheme="www.degage.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="枚举" scheme="www.degage.xyz/tags/%E6%9E%9A%E4%B8%BE/"/>
    
      <category term="map" scheme="www.degage.xyz/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>小G的树</title>
    <link href="www.degage.xyz/2018/11/03/47/"/>
    <id>www.degage.xyz/2018/11/03/47/</id>
    <published>2018-11-03T02:25:42.000Z</published>
    <updated>2019-01-16T13:28:19.957Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>给出n个点的树，每条边长会等概率是1或2，求树的直径的期望。（$n≤60$）</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>只要会树型dp求树的直径，然后枚举就可以$O(n^4)$过了</p><p>上代码：</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxn 70using namespace std;typedef long long ll;ll g[maxn&lt;&lt;1][maxn&lt;&lt;1],ff[maxn][maxn&lt;&lt;1][maxn&lt;&lt;1];int n,x,y;struct eage{    int to,next;}e[maxn&lt;&lt;1];int np=0,first[maxn];void add(int u,int v){    e[++np]=(eage){v,first[u]};    first[u]=np;}int sz[maxn];void dfs(int i,int f){     ff[i][0][0]=sz[i]=1;     for(int p=first[i];p;p=e[p].next){         int j=e[p].to;         if(j==f) continue;         dfs(j,i);         memset(g,0,sizeof(g));         for(int l1=0;l1&lt;=sz[i]*2;l1++)         for(int z1=l1;z1&lt;=sz[i]*2;z1++)if(ff[i][l1][z1])         for(int l2=0;l2&lt;=sz[j]*2;l2++)         for(int z2=l2;z2&lt;=sz[j]*2;z2++) if(ff[j][l2][z2]){             for(int len=1;len&lt;=2;len++){             int t=max(z1,z2);             t=max(t,l1+l2+len);             g[max(l1,l2+len)][t]+=ff[i][l1][z1]*ff[j][l2][z2];;            }        }        sz[i]+=sz[j];        for(int l=0;l&lt;=sz[i]*2;l++)        for(int z=l;z&lt;=sz[i]*2;z++)        ff[i][l][z]=g[l][z];     } } void init(){    scanf(&quot;%d&quot;,&amp;n);    for(int i=1;i&lt;n;i++){        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);add(x,y);add(y,x);    }     dfs(1,0);    double ans=0;    for(int l=0;l&lt;=n*2;l++)    for(int z=l;z&lt;=n*2;z++){        ans+=ff[1][l][z]*z;    }     printf(&quot;%lf&quot;,ans/(1ll&lt;&lt;(n-1)));}int main(){    init();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;给出n个点的树，每条边长会等概率是1或2，求树的直径的期望。（$n≤
      
    
    </summary>
    
      <category term="正睿" scheme="www.degage.xyz/categories/%E6%AD%A3%E7%9D%BF/"/>
    
    
      <category term="概率期望" scheme="www.degage.xyz/tags/%E6%A6%82%E7%8E%87%E6%9C%9F%E6%9C%9B/"/>
    
      <category term="树型dp" scheme="www.degage.xyz/tags/%E6%A0%91%E5%9E%8Bdp/"/>
    
  </entry>
  
  <entry>
    <title>郁闷的小G</title>
    <link href="www.degage.xyz/2018/11/03/46/"/>
    <id>www.degage.xyz/2018/11/03/46/</id>
    <published>2018-11-03T02:25:35.000Z</published>
    <updated>2019-01-16T13:28:16.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>有5种类型的题E,EM,M,MH,H若干，其中E,EM可用来出第一题，EM,M,MH可用来出第二题，MH,H可用来出第三题，求最多可出多少场模拟赛。（设N为最大数，$1≤N≤10^18$）</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>我干考试时懵了直接上了个大模拟，结果用二分简单到爆炸！！！</p><p>模拟：</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll e,em,m,mh,h,a,b,c,x=1,y=1;int main(){     scanf(&quot;%lld%lld%lld%lld%lld&quot;,&amp;e,&amp;em,&amp;m,&amp;mh,&amp;h);     a=e+em,b=m,c=mh+h;     if(a&lt;=b) x=0;     if(c&lt;=b) y=0;     if(!x&amp;&amp;!y){         ll ans=min(a,min(b,c));         printf(&quot;%lld&quot;,ans);     }     else if(!x){         ll mid=(b+c)/2;         if(mid-b&lt;=mh) y=mid-b;         else y=mh;         ll minn=y+b;         ll ans=min(a,minn);         printf(&quot;%lld&quot;,ans);     }     else if(!y){         ll mid=(a+b)/2;         if(mid-b&lt;=em) x=mid-b;         else x=em;         ll minn=b+x;         ll ans=min(minn,c);         printf(&quot;%lld&quot;,ans);     }     else{         if(a&gt;c){             ll mv=a-c;             if(mv&gt;em) mv=em;            a=a-mv;              if(b+mv&gt;=c){                 printf(&quot;%lld&quot;,c);            }            else{                if(mv==em){                    b+=mv;                    ll mid=(b+c)/2;                     if(mid-b&lt;=mh) y=mid-b;                     else y=mh;                     ll minn=y+b;                     printf(&quot;%lld&quot;,minn);                }                else{                    b+=mv;                    em-=mv;//还剩的步数                     ll mvv=min(em,mh);                    ll cnt=(c-b)/3;                    if(cnt&gt;mvv) cnt=mvv;                    ll minn=b+cnt*2;                    c=c-cnt,a=a-cnt;em-=mvv;mh-=mvv;                    if(minn&lt;c){                       if(em){                           ll mid=(minn+c)/2;                         if(mid-minn&lt;=em) y=mid-minn;                         else y=em;                         minn=minn+y;                       }                       if(mh){                           ll mid=(minn+c)/2;                         if(mid-minn&lt;=mh) y=mid-minn;                         else y=mh;                         minn=minn+y;                       }                        }                    printf(&quot;%lld&quot;,minn);                }            }         }         else{             ll mv=c-a;             if(mv&gt;mh) mv=mh;            c=c-mv;              if(b+mv&gt;=a){                 printf(&quot;%lld&quot;,a);            }            else{                if(mv==mh){                    b+=mv;                    ll mid=(a+b)/2;                     if(mid-b&lt;=em) x=mid-b;                     else x=em;                     ll minn=b+x;                     printf(&quot;%lld&quot;,minn);                }                else{                    b+=mv;                    mh-=mv;//还剩的步数                     ll mvv=min(em,mh);                    ll cnt=(c-b)/3;                    if(cnt&gt;mvv) cnt=mvv;                    ll minn=b+cnt*2;                    c=c-cnt,a=a-cnt;em-=mvv;mh-=mvv;                    if(minn&lt;c){                       if(em){                           ll mid=(minn+c)/2;                         if(mid-minn&lt;=em) y=mid-minn;                         else y=em;                         minn=minn+y;                       }                       if(mh){                           ll mid=(minn+c)/2;                         if(mid-minn&lt;=mh) y=mid-minn;                         else y=mh;                         minn=minn+y;                       }                        }                    printf(&quot;%lld&quot;,minn);                }            }         }     }    return 0;}</code></pre><p>滔滔的二分：</p><pre><code class="lang-c++">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;bool check(LL mid,LL A,LL B,LL C,LL A_B,LL B_C){    if(A&lt;mid){if(A+A_B&lt;mid)return false;A_B-=mid-A;}B+=A_B;    if(B&lt;mid){if(B+B_C&lt;mid)return false;B_C-=mid-B;}    C+=B_C;if(C&lt;mid)return false;    return true;}int main(){    LL A,B,C,A_B,B_C;    scanf(&quot;%lld%lld%lld%lld%lld&quot;,&amp;A,&amp;A_B,&amp;B,&amp;B_C,&amp;C);    LL L=min({A,B,C}),R=max({A+A_B,B+A_B+B_C,B_C+C}),ans;    while(L&lt;=R){        LL mid=(L+R)&gt;&gt;1;        if(check(mid,A,B,C,A_B,B_C))ans=mid,L=mid+1;        else R=mid-1;    }    printf(&quot;%lld&quot;,ans);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;有5种类型的题E,EM,M,MH,H若干，其中E,EM可用来出第一题
      
    
    </summary>
    
      <category term="正睿" scheme="www.degage.xyz/categories/%E6%AD%A3%E7%9D%BF/"/>
    
    
      <category term="模拟" scheme="www.degage.xyz/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="二分" scheme="www.degage.xyz/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>取数游戏</title>
    <link href="www.degage.xyz/2018/11/01/45/"/>
    <id>www.degage.xyz/2018/11/01/45/</id>
    <published>2018-11-01T09:39:42.000Z</published>
    <updated>2019-01-16T13:28:12.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>有一个$N \ast M$的矩阵，你需要进行恰好K次操作，每次可以选择其中一行或者其中一列，将其中的元素全部累加到ans里去，然后把全中的这些数全部减去P，问ans最大是多少</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>2 2 2 2<br>1 3<br>2 4</p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>11</p><h1 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h1><p>$N,M&lt;=1000,K&lt;=10^5,0&lt;=P&lt;=100,1&lt;A_{ij}&lt;1000$</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>首先探究性质发现取行或取列只分别对列和行整体造成影响，贪心还是要取大的，所以只考虑对自身的影响。再发现取行或取列都是分别对以后的取列或取行造成-p的影响，所以先后是没有关系的。<br>那么先预处理出去行k次和取列k次最大值，再O(n)枚举行列分别取多少，再减去$i \ast (k-i) \ast p$即可。</p><p>上代码：</p><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;#define maxn 100005using namespace std;typedef long long ll;ll h[maxn],l[maxn],sh[maxn],sl[maxn];int n,m,k,p,x;priority_queue&lt;ll&gt;q,qq;void init(){    scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;k,&amp;p);    for(int i=1;i&lt;=n;i++)    for(int j=1;j&lt;=m;j++){        scanf(&quot;%d&quot;,&amp;x);        h[i]+=x;l[j]+=x;    }    for(int i=1;i&lt;=n;i++) q.push(h[i]);    for(int i=1;i&lt;=k;i++){        ll t=q.top();q.pop();        sh[i]=sh[i-1]+t;t-=m*p;        q.push(t);    }    for(int i=1;i&lt;=m;i++) qq.push(l[i]);    for(int i=1;i&lt;=k;i++){        ll t=qq.top();qq.pop();        sl[i]=sl[i-1]+t;t-=n*p;        qq.push(t);     }    ll ans=-1000000000000;    for(int i=0;i&lt;=k;i++){          ans=max(ans,sh[i]+sl[k-i]-1ll*i*(k-i)*p);    }    printf(&quot;%lld&quot;,ans);} int main(){    init();    return 0; }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;有一个$N \ast M$的矩阵，你需要进行恰好K次操作，每次可以选
      
    
    </summary>
    
      <category term="正睿" scheme="www.degage.xyz/categories/%E6%AD%A3%E7%9D%BF/"/>
    
    
      <category term="贪心" scheme="www.degage.xyz/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="优先队列" scheme="www.degage.xyz/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
